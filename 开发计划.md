# 目标

1. 当前代码中同时存在HttpRespPart和HttpResponsePart，定位重复了。清除掉前者，全部采用后者。

# 核心思路

1. **统一响应模型**：删除 HttpRespPart 体系（HttpRespPart、HttpRespHead、HttpRespBody、FullHttpResp），全面采用 HttpResponsePart 体系。
2. **新建完整响应类**：创建 `FullHttpResponse` 类实现 `HttpResponsePart` 接口，用于服务端编码完整响应，替代原来的 `FullHttpResp`。
3. **适配编码器**：修改 `HttpRespEncoder`，移除对 HttpRespPart 体系的支持，改为支持 `FullHttpResponse`。
4. **迁移使用点**：将所有使用 `FullHttpResp` 的地方改为使用 `FullHttpResponse`。

# 详细实现思路

## 1. 新建 FullHttpResponse 类

创建一个新的 `FullHttpResponse` 类，实现 `HttpResponsePart` 接口，功能上替代 `FullHttpResp`。

该类需要具备：
- 响应状态码（statusCode）
- 响应原因短语（reasonPhrase，可选）
- HTTP 版本（version，默认 "HTTP/1.1"）
- 响应头（headers）
- 响应体内容（支持 IoBuffer、byte[]、String 三种形式，与原 HttpRespBody 保持一致）
- write(IoBuffer) 方法用于编码输出
- 自动补充 Content-Length 和 Content-Type 头（默认 Content-Type 为 `application/json;charset=utf-8`，采用标准写法）

## 2. 修改 HttpRespEncoder

- 移除对 `HttpRespHead`、`HttpRespBody`、`FullHttpResp` 的处理逻辑
- 新增对 `FullHttpResponse` 的编码支持
- 保留对 `HttpResponsePartHead` 的编码支持（用于流式响应场景）

## 3. 修改 CorsEncoder

- 移除对 `FullHttpResp` 的处理逻辑
- 新增对 `FullHttpResponse` 的 CORS 头处理
- 对 `HttpResponsePartHead`（流式/分段响应头）保持现状，仅透传不加 CORS 头

## 4. 迁移所有使用点

将以下文件中的 `FullHttpResp` 替换为 `FullHttpResponse`：
- `AbstractResourceEncoder.java`（3处）
- `NotFoundUrlProcessor.java`（2处）
- `OptionsProcessor.java`（2处）
- `ResourceProcessor.java`（2处）
- `TransferProcessor.java`（1处）
- `FileResourceHandler.java`（2处）
- `ClassResourceHandler.java`（1处）
- `ProxyHttpHandler2.java`（1处）
- `SampleHttpServer.java`（测试文件，1处）
- `README.md`（文档示例，1处）

## 5. 删除 HttpRespPart 体系文件

删除以下文件：
- `HttpRespPart.java`
- `HttpRespHead.java`
- `HttpRespBody.java`
- `FullHttpResp.java`

# 实施步骤

## 步骤1：创建 FullHttpResponse 类

在 `src/main/java/cc/jfire/jnet/extend/http/dto/` 目录下创建 `FullHttpResponse.java`：

```java
package cc.jfire.jnet.extend.http.dto;

import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import lombok.Data;
import lombok.experimental.Accessors;

import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;

@Data
@Accessors(chain = true)
public class FullHttpResponse implements HttpResponsePart
{
    private static final byte[] NEWLINE = "\r\n".getBytes(StandardCharsets.US_ASCII);

    private String              version      = "HTTP/1.1";
    private int                 statusCode   = 200;
    private String              reasonPhrase = "OK";
    private Map<String, String> headers      = new HashMap<>();

    // 响应体，三种形式，优先级：bodyBuffer > bodyBytes > bodyText
    private IoBuffer bodyBuffer;
    private byte[]   bodyBytes;
    private String   bodyText;

    private boolean hasContentLength = false;
    private boolean hasContentType   = false;

    public FullHttpResponse addHeader(String name, String value)
    {
        String lowerName = name.toLowerCase();
        if (lowerName.equals("content-length"))
        {
            hasContentLength = true;
        }
        if (lowerName.equals("content-type"))
        {
            hasContentType = true;
        }
        headers.put(name, value);
        return this;
    }

    public void write(IoBuffer buffer)
    {
        helpSetContentLengthIfNeed();
        helpSetContentTypeIfNeed();
        // 编码响应行
        buffer.put((version + " " + statusCode + " " + reasonPhrase + "\r\n").getBytes(StandardCharsets.US_ASCII));
        // 编码 headers
        headers.forEach((name, value) -> buffer.put((name + ": " + value + "\r\n").getBytes(StandardCharsets.US_ASCII)));
        // 空行结束头部
        buffer.put(NEWLINE);
        // 编码 body
        writeBody(buffer);
    }

    private void helpSetContentLengthIfNeed()
    {
        if (!hasContentLength)
        {
            if (bodyBuffer != null && bodyBuffer.remainRead() > 0)
            {
                addHeader("Content-Length", String.valueOf(bodyBuffer.remainRead()));
            }
            else if (bodyBytes != null)
            {
                addHeader("Content-Length", String.valueOf(bodyBytes.length));
            }
            else if (bodyText != null)
            {
                addHeader("Content-Length", String.valueOf(bodyText.getBytes(StandardCharsets.UTF_8).length));
            }
            else
            {
                addHeader("Content-Length", "0");
            }
        }
    }

    private void helpSetContentTypeIfNeed()
    {
        if (!hasContentType)
        {
            addHeader("Content-Type", "application/json;charset=utf-8");
        }
    }

    private void writeBody(IoBuffer buffer)
    {
        if (bodyBuffer != null)
        {
            buffer.put(bodyBuffer);
            bodyBuffer.free();
            bodyBuffer = null;
        }
        else if (bodyBytes != null)
        {
            buffer.put(bodyBytes);
        }
        else if (bodyText != null)
        {
            buffer.put(bodyText.getBytes(StandardCharsets.UTF_8));
        }
    }

    @Override
    public void free()
    {
        if (bodyBuffer != null)
        {
            bodyBuffer.free();
            bodyBuffer = null;
        }
    }

    @Override
    public boolean isLast()
    {
        return true; // 完整响应总是最后一个部分
    }
}
```

## 步骤2：修改 HttpRespEncoder

修改 `src/main/java/cc/jfire/jnet/extend/http/coder/HttpRespEncoder.java`：

1. 移除对 `HttpRespHead`、`HttpRespBody`、`FullHttpResp` 的 import
2. 新增对 `FullHttpResponse` 的 import
3. 修改 write 方法：
   - 删除 `HttpRespHead`、`HttpRespBody`、`FullHttpResp` 的处理分支
   - 新增 `FullHttpResponse` 的处理分支

```java
// 删除的 import：
// import cc.jfire.jnet.extend.http.dto.FullHttpResp;
// import cc.jfire.jnet.extend.http.dto.HttpRespBody;
// import cc.jfire.jnet.extend.http.dto.HttpRespHead;

// 新增的 import：
import cc.jfire.jnet.extend.http.dto.FullHttpResponse;

// write 方法中新增的分支：
else if (obj instanceof FullHttpResponse fullHttpResponse)
{
    IoBuffer buffer = allocator.allocate(1024);
    fullHttpResponse.write(buffer);
    next.fireWrite(buffer);
}
```

## 步骤3：修改 CorsEncoder

修改 `src/main/java/cc/jfire/jnet/extend/http/coder/CorsEncoder.java`：

1. 移除对 `FullHttpResp`、`HttpRespHead` 的 import
2. 新增对 `FullHttpResponse` 的 import
3. 修改 write 方法中对 `FullHttpResp` 的处理为 `FullHttpResponse`

```java
// 修改前：
if (data instanceof FullHttpResp fullHttpResp)
{
    HttpRespHead head = fullHttpResp.getHead();
    head.addHeader("Access-Control-Allow-Origin", "*")
        .addHeader("access-control-allow-methods", "GET,PUT,POST,HEAD")
        .addHeader("Access-Control-Max-Age", "86400")
        .addHeader("Access-Control-Allow-Headers", "*");
    next.fireWrite(fullHttpResp);
}

// 修改后：
if (data instanceof FullHttpResponse fullHttpResponse)
{
    fullHttpResponse.addHeader("Access-Control-Allow-Origin", "*")
        .addHeader("Access-Control-Allow-Methods", "GET,PUT,POST,HEAD")
        .addHeader("Access-Control-Max-Age", "86400")
        .addHeader("Access-Control-Allow-Headers", "*");
    next.fireWrite(fullHttpResponse);
}
```

## 步骤4：迁移所有使用 FullHttpResp 的代码

以下是需要修改的文件及完整改造清单：

### 4.1 AbstractResourceEncoder.java

**文件路径**：`src/main/java/cc/jfire/jnet/extend/http/coder/AbstractResourceEncoder.java`

**修改 import**（第10行）：
```java
// 修改前：
import cc.jfire.jnet.extend.http.dto.FullHttpResp;
// 修改后：
import cc.jfire.jnet.extend.http.dto.FullHttpResponse;
```

**替换点1**（第136-140行，ClassResourceEncoder.process 方法）：
```java
// 修改前：
FullHttpResp response = new FullHttpResp();
response.getHead().addHeader("Content-Type", staticResource.contentType());
response.getBody().setBodyBytes(staticResource.content());
response.getHead().addHeader("Cache-Control", "max-age=3600");
next.pipeline().fireWrite(response);

// 修改后：
FullHttpResponse response = new FullHttpResponse();
response.addHeader("Content-Type", staticResource.contentType());
response.setBodyBytes(staticResource.content());
response.addHeader("Cache-Control", "max-age=3600");
next.pipeline().fireWrite(response);
```

**替换点2**（第174-177行，FileResourceEncoder.process 方法正常分支）：
```java
// 修改前：
FullHttpResp response = new FullHttpResp();
response.getHead().addHeader("Content-Type", contentType);
response.getBody().setBodyBytes(IoUtil.readAllBytes(inputStream));
next.pipeline().fireWrite(response);

// 修改后：
FullHttpResponse response = new FullHttpResponse();
response.addHeader("Content-Type", contentType);
response.setBodyBytes(IoUtil.readAllBytes(inputStream));
next.pipeline().fireWrite(response);
```

**替换点3**（第181-184行，FileResourceEncoder.process 方法异常分支）：
```java
// 修改前：
FullHttpResp response = new FullHttpResp();
response.getHead().addHeader("Content-Type", "text");
response.getBody().setBodyText("error:" + e.getMessage());
next.pipeline().fireWrite(response);

// 修改后：
FullHttpResponse response = new FullHttpResponse();
response.addHeader("Content-Type", "text");
response.setBodyText("error:" + e.getMessage());
next.pipeline().fireWrite(response);
```

### 4.2 NotFoundUrlProcessor.java

**文件路径**：`src/main/java/cc/jfire/jnet/extend/http/coder/NotFoundUrlProcessor.java`

**修改 import**（第5行）：
```java
// 修改前：
import cc.jfire.jnet.extend.http.dto.FullHttpResp;
// 修改后：
import cc.jfire.jnet.extend.http.dto.FullHttpResponse;
```

**替换点1**（第23-26行，read 方法）：
```java
// 修改前：
FullHttpResp response = new FullHttpResp();
response.getHead().setResponseCode(404);
response.getBody().setBodyText("notAvailable path:" + purePath);
next.pipeline().fireWrite(response);

// 修改后：
FullHttpResponse response = new FullHttpResponse();
response.setStatusCode(404).setReasonPhrase("Not Found");
response.setBodyText("notAvailable path:" + purePath);
next.pipeline().fireWrite(response);
```

**替换点2**（第40-43行，NotFoundBarrier.read 方法）：
```java
// 修改前：
FullHttpResp response = new FullHttpResp();
response.getHead().setResponseCode(404);
response.getBody().setBodyText("notAvailable path:" + purePath);
next.pipeline().fireWrite(response);

// 修改后：
FullHttpResponse response = new FullHttpResponse();
response.setStatusCode(404).setReasonPhrase("Not Found");
response.setBodyText("notAvailable path:" + purePath);
next.pipeline().fireWrite(response);
```

### 4.3 OptionsProcessor.java

**文件路径**：`src/main/java/cc/jfire/jnet/extend/http/coder/OptionsProcessor.java`

**修改 import**（第5行）：
```java
// 修改前：
import cc.jfire.jnet.extend.http.dto.FullHttpResp;
// 修改后：
import cc.jfire.jnet.extend.http.dto.FullHttpResponse;
```

**替换点1**（第15-16行，OPTIONS 请求处理）：
```java
// 修改前：
FullHttpResp response = new FullHttpResp();
next.pipeline().fireWrite(response);

// 修改后：
FullHttpResponse response = new FullHttpResponse();
next.pipeline().fireWrite(response);
```

**替换点2**（第23-25行，favicon.ico/robots.txt 处理）：
```java
// 修改前：
FullHttpResp response = new FullHttpResp();
response.getHead().setResponseCode(404);
next.pipeline().fireWrite(response);

// 修改后：
FullHttpResponse response = new FullHttpResponse();
response.setStatusCode(404).setReasonPhrase("Not Found");
next.pipeline().fireWrite(response);
```

### 4.4 ResourceProcessor.java

**文件路径**：`src/main/java/cc/jfire/jnet/extend/http/coder/ResourceProcessor.java`

**修改 import**（第6行）：
```java
// 修改前：
import cc.jfire.jnet.extend.http.dto.FullHttpResp;
// 修改后：
import cc.jfire.jnet.extend.http.dto.FullHttpResponse;
```

**替换点1**（第94-99行，runInIDE=true 分支）：
```java
// 修改前：
FullHttpResp response = new FullHttpResp();
response.getHead().addHeader("Content-Type", staticResource.contentType);
response.getBody().setBodyBytes(staticResource.content);
response.getHead().addHeader("Cache-Control", "no-cache");
response.getHead().addHeader("Connection", "keep-alive");
next.pipeline().fireWrite(response);

// 修改后：
FullHttpResponse response = new FullHttpResponse();
response.addHeader("Content-Type", staticResource.contentType);
response.setBodyBytes(staticResource.content);
response.addHeader("Cache-Control", "no-cache");
response.addHeader("Connection", "keep-alive");
next.pipeline().fireWrite(response);
```

**替换点2**（第142-146行，runInIDE=false 分支）：
```java
// 修改前：
FullHttpResp response = new FullHttpResp();
response.getHead().addHeader("Content-Type", staticResource.contentType);
response.getBody().setBodyBytes(staticResource.content);
response.getHead().addHeader("Cache-Control", "max-age=3600");
next.pipeline().fireWrite(response);

// 修改后：
FullHttpResponse response = new FullHttpResponse();
response.addHeader("Content-Type", staticResource.contentType);
response.setBodyBytes(staticResource.content);
response.addHeader("Cache-Control", "max-age=3600");
next.pipeline().fireWrite(response);
```

### 4.5 TransferProcessor.java

**文件路径**：`src/main/java/cc/jfire/jnet/extend/reverse/proxy/TransferProcessor.java`

**修改 import**（第6行）：
```java
// 修改前：
import cc.jfire.jnet.extend.http.dto.FullHttpResp;
// 修改后：
import cc.jfire.jnet.extend.http.dto.FullHttpResponse;
```

**替换点1**（第77-80行，processHead 方法无匹配 handler 时）：
```java
// 修改前：
FullHttpResp response = new FullHttpResp();
response.getHead().setResponseCode(404);
response.getBody().setBodyText("not found address:" + path);
next.pipeline().fireWrite(response);

// 修改后：
FullHttpResponse response = new FullHttpResponse();
response.setStatusCode(404).setReasonPhrase("Not Found");
response.setBodyText("not found address:" + path);
next.pipeline().fireWrite(response);
```

### 4.6 FileResourceHandler.java

**文件路径**：`src/main/java/cc/jfire/jnet/extend/reverse/proxy/api/handler/FileResourceHandler.java`

**修改 import**（第7行）：
```java
// 修改前：
import cc.jfire.jnet.extend.http.dto.FullHttpResp;
// 修改后：
import cc.jfire.jnet.extend.http.dto.FullHttpResponse;
```

**替换点1**（第54-57行，processHead 方法文件存在分支）：
```java
// 修改前：
FullHttpResp response = new FullHttpResp();
response.getHead().addHeader("Content-Type", contentType);
response.getBody().setBodyBytes(bytes);
pipeline.fireWrite(response);

// 修改后：
FullHttpResponse response = new FullHttpResponse();
response.addHeader("Content-Type", contentType);
response.setBodyBytes(bytes);
pipeline.fireWrite(response);
```

**替换点2**（第67-70行，processHead 方法文件不存在分支）：
```java
// 修改前：
FullHttpResp response = new FullHttpResp();
response.getHead().addHeader("Content-Type", "text/html;charset=utf-8");
response.getBody().setBodyText(STR.format("not available path:{},not find in :{}", requestUrl, resourceFile.getAbsolutePath()));
pipeline.fireWrite(response);

// 修改后：
FullHttpResponse response = new FullHttpResponse();
response.addHeader("Content-Type", "text/html;charset=utf-8");
response.setBodyText(STR.format("not available path:{},not find in :{}", requestUrl, resourceFile.getAbsolutePath()));
pipeline.fireWrite(response);
```

### 4.7 ClassResourceHandler.java

**文件路径**：`src/main/java/cc/jfire/jnet/extend/reverse/proxy/api/handler/ClassResourceHandler.java`

**修改 import**（第6行）：
```java
// 修改前：
import cc.jfire.jnet.extend.http.dto.FullHttpResp;
// 修改后：
import cc.jfire.jnet.extend.http.dto.FullHttpResponse;
```

**替换点1**（第50-53行，processHead 方法）：
```java
// 修改前：
FullHttpResp response = new FullHttpResp();
response.getHead().addHeader("Content-Type",contentType);
response.getBody().setBodyBytes(tuper.bytes());
pipeline.fireWrite(response);

// 修改后：
FullHttpResponse response = new FullHttpResponse();
response.addHeader("Content-Type", contentType);
response.setBodyBytes(tuper.bytes());
pipeline.fireWrite(response);
```

### 4.8 ProxyHttpHandler2.java

**文件路径**：`src/main/java/cc/jfire/jnet/extend/reverse/proxy/api/handler/ProxyHttpHandler2.java`

**修改 import**：
```java
// 修改前：
import cc.jfire.jnet.extend.http.dto.FullHttpResp;
// 修改后：
import cc.jfire.jnet.extend.http.dto.FullHttpResponse;
```

**替换点1**（第273-276行，sendErrorResponse 方法）：
```java
// 修改前：
FullHttpResp response = new FullHttpResp();
response.getHead().setResponseCode(statusCode);
response.getBody().setBodyText(message);
pipeline.fireWrite(response);

// 修改后：
FullHttpResponse response = new FullHttpResponse();
response.setStatusCode(statusCode);
response.setBodyText(message);
pipeline.fireWrite(response);
```

### 4.9 SampleHttpServer.java

**文件路径**：`src/test/java/cc/jfire/jnet/SampleHttpServer.java`

**修改 import**（第7行）：
```java
// 修改前：
import cc.jfire.jnet.extend.http.dto.FullHttpResp;
// 修改后：
import cc.jfire.jnet.extend.http.dto.FullHttpResponse;
```

**替换点1**（第62-65行，匿名 ReadProcessor 的 read 方法）：
```java
// 修改前：
FullHttpResp resp = new FullHttpResp();
resp.getHead().addHeader("content-type", "text/html");
resp.getBody().setBodyText("hello y");
next.pipeline().fireWrite(resp);

// 修改后：
FullHttpResponse resp = new FullHttpResponse();
resp.addHeader("Content-Type", "text/html");
resp.setBodyText("hello y");
next.pipeline().fireWrite(resp);
```

### 4.10 README.md

**文件路径**：`README.md`

**替换点1**（第144-147行，HTTPS 服务端示例代码）：
```java
// 修改前：
FullHttpResp resp = new FullHttpResp();
resp.getHead().addHeader("content-type", "text/html");
resp.getBody().setBodyText("Hello, HTTPS!");
next.pipeline().fireWrite(resp);

// 修改后：
FullHttpResponse resp = new FullHttpResponse();
resp.addHeader("Content-Type", "text/html");
resp.setBodyText("Hello, HTTPS!");
next.pipeline().fireWrite(resp);
```

**同时需要修改对应的 import 语句**（如有）。

## 步骤5：删除 HttpRespPart 体系文件

删除以下4个文件：
- `src/main/java/cc/jfire/jnet/extend/http/dto/HttpRespPart.java`
- `src/main/java/cc/jfire/jnet/extend/http/dto/HttpRespHead.java`
- `src/main/java/cc/jfire/jnet/extend/http/dto/HttpRespBody.java`
- `src/main/java/cc/jfire/jnet/extend/http/dto/FullHttpResp.java`

## 步骤6：编译验证

执行 `mvn compile` 确保没有编译错误。

# 待办列表

1. 创建 FullHttpResponse 类
2. 修改 HttpRespEncoder 编码器
3. 修改 CorsEncoder 编码器
4. 迁移 AbstractResourceEncoder 中的 FullHttpResp 使用
5. 迁移 NotFoundUrlProcessor 中的 FullHttpResp 使用
6. 迁移 OptionsProcessor 中的 FullHttpResp 使用
7. 迁移 ResourceProcessor 中的 FullHttpResp 使用
8. 迁移 TransferProcessor 中的 FullHttpResp 使用
9. 迁移 FileResourceHandler 中的 FullHttpResp 使用
10. 迁移 ClassResourceHandler 中的 FullHttpResp 使用
11. 迁移 ProxyHttpHandler2 中的 FullHttpResp 使用
12. 迁移 SampleHttpServer 中的 FullHttpResp 使用
13. 更新 README.md 中的示例代码
14. 删除 HttpRespPart.java
15. 删除 HttpRespHead.java
16. 删除 HttpRespBody.java
17. 删除 FullHttpResp.java
18. 执行 mvn compile 验证

# 需要修改或新增的类

## 新增的类
- `FullHttpResponse`

## 需要修改的类
- `HttpRespEncoder`
- `CorsEncoder`
- `AbstractResourceEncoder`
- `NotFoundUrlProcessor`
- `OptionsProcessor`
- `ResourceProcessor`
- `TransferProcessor`
- `FileResourceHandler`
- `ClassResourceHandler`
- `ProxyHttpHandler2`
- `SampleHttpServer`

## 需要更新的文档
- `README.md`

## 需要删除的类
- `HttpRespPart`
- `HttpRespHead`
- `HttpRespBody`
- `FullHttpResp`