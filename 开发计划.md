# 目标

1. 在ProxyHttpHandler2 中不使用 HttpConnection2，而是直接使用 ClientChannel，这样可以避免不必要的绑定，也不需要 future 了。

# 核心思路

1. **移除 HttpConnection2 封装**：ProxyHttpHandler2 直接创建和管理 ClientChannel，不再使用 HttpConnection2 的封装层。

2. **精简编解码器配置**：在 ClientChannel 的 Pipeline 中配置：
   - `HeartBeat`（心跳处理器）
   - `HttpRequestPartEncoder`（HTTP 请求编码器）- 因为请求头被修改过（path、Host），需要重新编码
   - **不需要** `HttpResponsePartDecoder` - 后端响应直接以原始字节流转发给前端，无需解析

3. **直接转发响应**：在 ReadProcessor 中收到后端的原始 IoBuffer 字节流后，直接通过前端 Pipeline 的 `fireWrite` 方法转发，不再使用 ResponseFuture 机制，也不需要解析响应。

4. **简化状态管理**：移除 responseFuture 相关的状态管理，直接通过 ClientChannel 的 alive() 方法判断连接状态。

# 详细实现思路

## 1. 替换连接对象

将 `ProxyHttpHandler2` 中的 `HttpConnection2 httpConnection2` 字段替换为 `ClientChannel clientChannel`。

## 2. Pipeline 配置

在创建 ClientChannel 时，通过 PipelineInitializer 配置 Pipeline：
- **读处理器链**：HeartBeat → 自定义 ReadProcessor（直接转发原始字节流到前端）
- **写处理器链**：HttpRequestPartEncoder → HeartBeat

**注意**：不需要 `HttpResponsePartDecoder`，因为后端响应无需解析，直接以原始 IoBuffer 转发。

## 3. 响应处理机制

自定义的 ReadProcessor 处理的是原始 IoBuffer 字节流（不是解析后的 HttpResponsePart）：
- 持有前端 Pipeline 的引用，以便转发响应
- 在 `read()` 方法中，直接将收到的 IoBuffer 调用前端 Pipeline 的 `fireWrite()` 转发
- 在 `readFailed()` 方法中，关闭 ClientChannel 并调用前端 Pipeline 的 `shutdownInput()`

## 4. 连接状态判断

使用 `clientChannel.alive()` 代替原来的 `httpConnection2.isConnectionClosed()` 判断连接是否可用。

## 5. 请求发送方式

直接调用 `clientChannel.pipeline().fireWrite(requestPart)` 发送请求，不再通过 HttpConnection2 的 write 方法。

# 实施步骤

## 步骤 1：修改字段声明

将 `ProxyHttpHandler2` 中的字段从：
```java
private HttpConnection2 httpConnection2;
```
改为：
```java
private ClientChannel clientChannel;
```

## 步骤 2：添加必要的 import

添加以下导入：
```java
import cc.jfire.jnet.client.ClientChannel;
import cc.jfire.jnet.common.api.ReadProcessor;
import cc.jfire.jnet.common.api.ReadProcessorNode;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.jnet.common.coder.HeartBeat;
import cc.jfire.jnet.common.util.ChannelConfig;
import cc.jfire.jnet.common.util.ReflectUtil;
import cc.jfire.jnet.extend.http.coder.HttpRequestPartEncoder;
```

移除以下导入：
```java
import cc.jfire.jnet.extend.http.client.HttpConnection2;
```

## 步骤 3：修改连接创建逻辑

将 `processHead` 方法中创建 HttpConnection2 的代码：
```java
if (httpConnection2 == null)
{
    try
    {
        httpConnection2 = new HttpConnection2(backendHost, backendPort, 1800);
    }
    catch (Exception e)
    {
        head.close();
        sendErrorResponse(pipeline, 502, "Bad Gateway - Cannot connect to backend");
        return true;
    }
}
```

改为创建 ClientChannel：
```java
if (clientChannel == null)
{
    try
    {
        ChannelConfig channelConfig = new ChannelConfig().setIp(backendHost).setPort(backendPort);
        clientChannel = ClientChannel.newClient(channelConfig, backendPipeline -> {
            backendPipeline.addReadProcessor(new HeartBeat(1800, backendPipeline));
            backendPipeline.addReadProcessor(new ReadProcessor<IoBuffer>()
            {
                @Override
                public void read(IoBuffer buffer, ReadProcessorNode next)
                {
                    if (!pipeline.isOpen())
                    {
                        buffer.free();
                        closeClientChannel();
                        return;
                    }
                    // 直接转发原始字节流到前端
                    pipeline.fireWrite(buffer);
                }

                @Override
                public void readFailed(Throwable e, ReadProcessorNode next)
                {
                    closeClientChannel();
                    pipeline.shutdownInput();
                }
            });
            backendPipeline.addWriteProcessor(new HttpRequestPartEncoder());
            backendPipeline.addWriteProcessor(new HeartBeat(1800, backendPipeline));
        });
        if (!clientChannel.connect())
        {
            ReflectUtil.throwException(new RuntimeException("无法连接 " + backendHost + ":" + backendPort, clientChannel.getConnectionException()));
        }
    }
    catch (Exception e)
    {
        head.close();
        sendErrorResponse(pipeline, 502, "Bad Gateway - Cannot connect to backend");
        return true;
    }
}
```

## 步骤 4：修改连接状态检查

将：
```java
if (httpConnection2.isConnectionClosed())
```
改为：
```java
if (!clientChannel.alive())
```

## 步骤 5：修改请求发送逻辑

将 `processHead` 方法中使用 httpConnection2.write() 的代码：
```java
httpConnection2.write(head, responsePart -> {
    // 响应处理回调
}, error -> {
    // 错误处理回调
});
```

简化为直接发送：
```java
clientChannel.pipeline().fireWrite(head);
```

因为响应处理已经在 Pipeline 的 ReadProcessor 中完成，不再需要回调。

## 步骤 6：修改 processBody 方法

将：
```java
if (httpConnection2 != null && !httpConnection2.isConnectionClosed())
{
    httpConnection2.write(body);
}
```
改为：
```java
if (clientChannel != null && clientChannel.alive())
{
    clientChannel.pipeline().fireWrite(body);
}
```

## 步骤 7：修改关闭连接方法

将 `closeHttpConnection2()` 方法重命名为 `closeClientChannel()` 并修改实现：
```java
private void closeClientChannel()
{
    if (clientChannel != null)
    {
        clientChannel.pipeline().shutdownInput();
        clientChannel = null;
    }
}
```

## 步骤 8：修改 readFailed 方法

将：
```java
closeHttpConnection2();
```
改为：
```java
closeClientChannel();
```

# 待办列表

1. [ ] 修改 ProxyHttpHandler2 的字段声明（HttpConnection2 → ClientChannel）
2. [ ] 添加必要的 import 语句
3. [ ] 重写连接创建逻辑，配置 Pipeline（编解码器 + 响应处理器）
4. [ ] 修改连接状态检查逻辑
5. [ ] 简化请求发送逻辑（移除回调，直接 fireWrite）
6. [ ] 修改 processBody 方法
7. [ ] 重命名并修改关闭连接方法
8. [ ] 修改 readFailed 方法
9. [ ] 编译验证

# 需要修改或新增的类

## 需要修改的类

1. **ProxyHttpHandler2** (`src/main/java/cc/jfire/jnet/extend/reverse/proxy/api/handler/ProxyHttpHandler2.java`)
   - 移除 HttpConnection2 依赖，改用 ClientChannel
   - 修改连接创建、状态检查、请求发送、关闭连接等逻辑

## 不需要新增的类

本次修改仅涉及 ProxyHttpHandler2 的重构，不需要新增任何类。