# 目标

1. 为接口cc.jfire.jnet.extend.http.dto.HttpResponsePart添加方法 isLast，用来表达是否响应流的结尾。
2. 删除不必要的HttpResponsePartEnd

# 核心思路

1. 在解析的时候，如果已经是响应的结尾，对应的实现类都添加这个属性，并且设置为 true。

# 详细实现思路

本次改造参考了 `HttpRequestPart` 的设计模式，通过在接口中添加 `isLast()` 方法来标识是否为响应流的最后一个部分，从而移除独立的 `HttpResponsePartEnd` 结束信号类。

## 接口改造

在 `HttpResponsePart` 接口中添加默认方法 `isLast()`，默认返回 `false`。实现类通过添加 `last` 属性并重写该方法来表达是否为最后一个部分。

## 解析器改造

在 `HttpResponsePartDecoder` 解析器中，根据不同场景设置 `last` 标记：
- **无Body响应**（contentLength=0 且非chunked）：在 `HttpResponsePartHead` 上设置 `last=true`
- **固定长度Body响应**：在最后一个 `HttpResponseFixLengthBodyPart` 上设置 `last=true`
- **Chunked响应**：在最后一个 chunk（chunkSize=0）的 `HttpResponseChunkedBodyPart` 上设置 `last=true`

## 使用端改造

所有使用 `HttpResponsePartEnd` 的地方改为检查 `part.isLast()` 来判断响应是否结束：
- `HttpConnection2`：判断是否清理 `responseFuture`
- `AggregatorResponseFuture`：判断是否组装完整响应
- `ProxyHttpHandler`：判断是否归还后端连接

# 实施步骤

## 步骤1：修改 HttpResponsePart 接口

**文件**: `src/main/java/cc/jfire/jnet/extend/http/dto/HttpResponsePart.java`

添加 `isLast()` 默认方法：

```java
package cc.jfire.jnet.extend.http.dto;

public interface HttpResponsePart
{
    /**
     * 释放该 part 持有的资源（如 IoBuffer）；无资源则为 no-op。
     */
    default void free() { }

    /**
     * 是否是响应流的最后一个部分
     */
    default boolean isLast()
    {
        return false;
    }
}
```

## 步骤2：修改 HttpResponsePartHead 类

**文件**: `src/main/java/cc/jfire/jnet/extend/http/dto/HttpResponsePartHead.java`

添加 `last` 属性：

```java
protected boolean             last          = false;

@Override
public boolean isLast()
{
    return last;
}

public void setLast(boolean last)
{
    this.last = last;
}
```

注意：由于使用了 Lombok `@Data` 注解，`setLast` 方法会自动生成，但需要手动重写 `isLast()` 方法以覆盖接口默认实现。

## 步骤3：修改 HttpResponseFixLengthBodyPart 类

**文件**: `src/main/java/cc/jfire/jnet/extend/http/dto/HttpResponseFixLengthBodyPart.java`

添加 `last` 属性：

```java
protected boolean  last = false;

@Override
public boolean isLast()
{
    return last;
}

public void setLast(boolean last)
{
    this.last = last;
}
```

## 步骤4：修改 HttpResponseChunkedBodyPart 类

**文件**: `src/main/java/cc/jfire/jnet/extend/http/dto/HttpResponseChunkedBodyPart.java`

添加 `last` 属性：

```java
private boolean  last = false;

@Override
public boolean isLast()
{
    return last;
}

public void setLast(boolean last)
{
    this.last = last;
}
```

## 步骤5：修改 HttpResponsePartDecoder 解析器

**文件**: `src/main/java/cc/jfire/jnet/extend/http/coder/HttpResponsePartDecoder.java`

### 5.1 移除 HttpResponsePartEnd 导入

删除：
```java
import cc.jfire.jnet.extend.http.dto.HttpResponsePartEnd;
```

### 5.2 修改 NO_BODY 状态处理

将：
```java
case NO_BODY ->
{
    next.fireRead(new HttpResponsePartEnd());
    resetState();
    yield accumulation != null && accumulation.remainRead() > 0;
}
```

改为：
```java
case NO_BODY ->
{
    respHead.setLast(true);
    next.fireRead(respHead);
    resetState();
    yield accumulation != null && accumulation.remainRead() > 0;
}
```

同时修改 `parseResponseHeader` 方法，在 NO_BODY 情况下不立即发送 respHead：
```java
private boolean parseResponseHeader(ReadProcessorNode next)
{
    for (; lastCheck + 3 < accumulation.getWritePosi(); lastCheck++)
    {
        if (accumulation.get(lastCheck) == '\r' && accumulation.get(lastCheck + 1) == '\n' && accumulation.get(lastCheck + 2) == '\r' && accumulation.get(lastCheck + 3) == '\n')
        {
            lastCheck = -1;
            HttpDecodeUtil.findAllHeaders(accumulation, respHead::addHeader);
            HttpDecodeUtil.findContentLength(respHead.getHeaders(), respHead::setContentLength);
            int bodyStartPosi = accumulation.getReadPosi();
            int headLength = bodyStartPosi - headStartPosi;
            if (headLength > 0)
            {
                accumulation.setReadPosi(headStartPosi);
                respHead.setPart(accumulation.slice(headLength));
            }
            parseBodyType();
            // NO_BODY 情况下不在此处发送，由 NO_BODY 状态处理
            if (state != ParseState.NO_BODY)
            {
                next.fireRead(respHead);
            }
            return true;
        }
    }
    return false;
}
```

### 5.3 修改 parseBodyFixLength 方法

将发送 `HttpResponsePartEnd` 改为设置 `last=true`：

```java
private boolean parseBodyFixLength(ReadProcessorNode next)
{
    if (accumulation == null || accumulation.remainRead() == 0)
    {
        return false;
    }
    int left   = respHead.getContentLength() - bodyRead;
    int remain = accumulation.remainRead();
    if (remain > left)
    {
        HttpResponseFixLengthBodyPart part = new HttpResponseFixLengthBodyPart();
        part.setPart(accumulation.slice(left));
        part.setLast(true);
        next.fireRead(part);
        resetState();
        return accumulation != null && accumulation.remainRead() > 0;
    }
    else if (remain == left)
    {
        HttpResponseFixLengthBodyPart part = new HttpResponseFixLengthBodyPart();
        part.setPart(accumulation);
        part.setLast(true);
        accumulation = null;
        next.fireRead(part);
        resetState();
        return false;
    }
    else
    {
        bodyRead += remain;
        HttpResponseFixLengthBodyPart part = new HttpResponseFixLengthBodyPart();
        part.setPart(accumulation);
        accumulation = null;
        next.fireRead(part);
        return false;
    }
}
```

### 5.4 修改 parseBodyChunked 方法

将发送 `HttpResponsePartEnd` 改为在最后一个 chunk 上设置 `last=true`：

```java
if (chunkSize == 0)
{
    int totalLength = chunkSizeLineLength + 2;
    if (accumulation.remainRead() < totalLength)
    {
        return false;
    }
    // 构造一个内容长度为0的 ChunkedBodyPart，包含 0\r\n\r\n
    HttpResponseChunkedBodyPart part = new HttpResponseChunkedBodyPart();
    part.setHeadLength(chunkSizeLineLength);
    part.setChunkLength(totalLength);
    part.setPart(accumulation.slice(totalLength));
    part.setLast(true);
    next.fireRead(part);
    resetState();
    return accumulation != null && accumulation.remainRead() > 0;
}
```

## 步骤6：修改 HttpConnection2

**文件**: `src/main/java/cc/jfire/jnet/extend/http/client/HttpConnection2.java`

### 6.1 移除 HttpResponsePartEnd 导入

删除导入语句中对 `HttpResponsePartEnd` 的引用（如果有单独导入）。

### 6.2 修改 ReadProcessor 的 read 方法

将：
```java
if (part instanceof HttpResponsePartEnd)
{
    responseFuture = null;
}
```

改为：
```java
if (part.isLast())
{
    responseFuture = null;
}
```

## 步骤7：修改 AggregatorResponseFuture

**文件**: `src/main/java/cc/jfire/jnet/extend/http/client/AggregatorResponseFuture.java`

### 7.1 移除 HttpResponsePartEnd 导入

删除：
```java
import cc.jfire.jnet.extend.http.dto.HttpResponsePartEnd;
```

### 7.2 修改 onReceive 方法

将 `else if (part instanceof HttpResponsePartEnd)` 改为在每个分支末尾检查 `isLast()`：

```java
@Override
public void onReceive(HttpResponsePart part)
{
    if (part instanceof HttpResponsePartHead head)
    {
        if (isTimeout(status))
        {
            head.free();
            return;
        }
        this.headPart = head;
        // 聚合模式不需要保留 head 的原始字节，及时释放
        head.free();
        int contentLength = head.getContentLength();
        if (contentLength > 0)
        {
            bodyBuffer = allocator.allocate(contentLength);
        }
        else if (head.isChunked())
        {
            bodyBuffer = allocator.allocate(1024);
        }
        // 无body响应，head就是最后一个part
        if (head.isLast())
        {
            handleEnd();
        }
    }
    else if (part instanceof HttpResponseFixLengthBodyPart fixPart)
    {
        if (isTimeout(status))
        {
            fixPart.free();
            return;
        }
        appendFixLength(fixPart);
        if (fixPart.isLast())
        {
            handleEnd();
        }
    }
    else if (part instanceof HttpResponseChunkedBodyPart chunkedPart)
    {
        if (isTimeout(status))
        {
            chunkedPart.free();
            return;
        }
        appendChunked(chunkedPart);
        if (chunkedPart.isLast())
        {
            handleEnd();
        }
    }
}

private void handleEnd()
{
    while (true)
    {
        int currentStatus = status;
        if (currentStatus == NO_ERROR_NO_TIMEOUT_NO_END)
        {
            HttpResponse response = assembleResponse();
            if (UNSAFE.compareAndSwapInt(this, STATUS_OFFSET, NO_ERROR_NO_TIMEOUT_NO_END, NO_ERROR_NO_TIMEOUT_END))
            {
                this.httpResponse = response;
                wakeUpWaitingThread();
                break;
            }
            response.free();
        }
        else if (currentStatus == NO_ERROR_TIMEOUT_NO_END)
        {
            if (UNSAFE.compareAndSwapInt(this, STATUS_OFFSET, NO_ERROR_TIMEOUT_NO_END, NO_ERROR_TIMEOUT_END))
            {
                releaseBodyBuffer();
                break;
            }
        }
        else
        {
            break;
        }
    }
}
```

## 步骤8：修改 ProxyHttpHandler

**文件**: `src/main/java/cc/jfire/jnet/extend/reverse/proxy/api/handler/ProxyHttpHandler.java`

### 8.1 移除 HttpResponsePartEnd 导入

删除：
```java
import cc.jfire.jnet.extend.http.dto.HttpResponsePartEnd;
```

### 8.2 修改响应回调处理

将：
```java
else if (responsePart instanceof HttpResponsePartEnd)
{
    ...
}
```

改为在每个分支末尾检查 `isLast()`：

```java
if (responsePart instanceof HttpResponsePartHead respHead)
{
    log.trace("[ProxyHttpHandler] 透传响应头, statusCode: {}", respHead.getStatusCode());
    pipeline.fireWrite(respHead);
    if (respHead.isLast())
    {
        handleResponseEnd(pipeline);
    }
}
else if (responsePart instanceof HttpResponseFixLengthBodyPart body)
{
    log.trace("[ProxyHttpHandler] 透传FixLength响应体, 大小: {}", body.getPart() != null ? body.getPart().remainRead() : 0);
    pipeline.fireWrite(body.getPart());
    if (body.isLast())
    {
        handleResponseEnd(pipeline);
    }
}
else if (responsePart instanceof HttpResponseChunkedBodyPart body)
{
    log.trace("[ProxyHttpHandler] 透传Chunked响应体, 大小: {}", body.getPart() != null ? body.getPart().remainRead() : 0);
    pipeline.fireWrite(body.getPart());
    if (body.isLast())
    {
        handleResponseEnd(pipeline);
    }
}
```

添加辅助方法：
```java
private void handleResponseEnd(Pipeline pipeline)
{
    log.trace("[ProxyHttpHandler] 收到响应结束标记, requestEndReceived: {}", requestEndReceived);
    if (!requestEndReceived)
    {
        log.warn("[ProxyHttpHandler] 响应结束但请求未结束, 连接不可复用");
        dropMode = DropMode.DROP_SILENT;
        closeAndReleaseBackendConn();
        return;
    }
    log.trace("[ProxyHttpHandler] 响应完成, 连接可复用");
    releaseReusableBackendConn();
}
```

## 步骤9：删除 HttpResponsePartEnd 类

**文件**: `src/main/java/cc/jfire/jnet/extend/http/dto/HttpResponsePartEnd.java`

删除整个文件。

# 待办列表

1. 修改 HttpResponsePart 接口，添加 isLast() 默认方法
2. 修改 HttpResponsePartHead 类，添加 last 属性和相关方法
3. 修改 HttpResponseFixLengthBodyPart 类，添加 last 属性和相关方法
4. 修改 HttpResponseChunkedBodyPart 类，添加 last 属性和相关方法
5. 修改 HttpResponsePartDecoder 解析器，在适当位置设置 last 标记
6. 修改 HttpConnection2，使用 isLast() 判断响应结束
7. 修改 AggregatorResponseFuture，使用 isLast() 判断响应结束
8. 修改 ProxyHttpHandler，使用 isLast() 判断响应结束
9. 删除 HttpResponsePartEnd 类

# 需要修改或新增的类

## 需要修改的类

1. `cc.jfire.jnet.extend.http.dto.HttpResponsePart` - 添加 isLast() 方法
2. `cc.jfire.jnet.extend.http.dto.HttpResponsePartHead` - 添加 last 属性
3. `cc.jfire.jnet.extend.http.dto.HttpResponseFixLengthBodyPart` - 添加 last 属性
4. `cc.jfire.jnet.extend.http.dto.HttpResponseChunkedBodyPart` - 添加 last 属性
5. `cc.jfire.jnet.extend.http.coder.HttpResponsePartDecoder` - 修改解析逻辑，设置 last 标记
6. `cc.jfire.jnet.extend.http.client.HttpConnection2` - 使用 isLast() 判断
7. `cc.jfire.jnet.extend.http.client.AggregatorResponseFuture` - 使用 isLast() 判断
8. `cc.jfire.jnet.extend.reverse.proxy.api.handler.ProxyHttpHandler` - 使用 isLast() 判断

## 需要删除的类

1. `cc.jfire.jnet.extend.http.dto.HttpResponsePartEnd` - 删除此类