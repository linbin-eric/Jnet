# 目标

1. 当前的系统存在一个明显的bug，那就是任意的ReadProcessor 可以向后端多次进行 fireRead 调用。但是最尾巴的 ReadProcessor 会因为收到 read 调用而进行 socketChannel 上的读注册，也就是调用方法：cc.jfire.jnet.common.internal.AdaptiveReadCompletionHandler.registerRead。这会导致抛出重复注册读取的异常。需要解决这个 bug

# 核心思路

1. ReadProcessor 需要增加一个方法：readCompleted，用来感知本轮的读取结束。
2. PipeLine 需要增加一个方法：fireReadCompleted 方法，用来在本轮读取的时候进行触发。
3. 其他的类，比如TailReadProcessor ,就需要随之变化。

# 详细实现思路

## 问题根源分析

当前的数据处理流程如下：
1. `AdaptiveReadCompletionHandler.completed()` 从 socketChannel 读取数据后调用 `pipeline.fireRead(ioBuffer)`
2. 数据沿着 ReadProcessor 链条传递（例如：HttpRequestPartDecoder → TransferProcessor → TailReadProcessor）
3. 最终 `TailReadProcessor.read()` 被调用时，如果 data 为 null，则调用 `registerRead()` 注册下一次读取

问题在于：
- `HttpRequestPartDecoder.process0()` 使用 do-while 循环，一次网络读取可能解码出多个请求部分，每个都会调用 `next.fireRead()`
- `TransferProcessor.read()` 在处理完每个请求部分后都调用 `next.fireRead(null)`（第59行）
- 这导致一次网络读取触发多次 `registerRead()` 调用，产生重复注册异常

## 解决方案

引入 `readCompleted` 机制，将"数据处理"和"注册下次读取"分离：
- `fireRead()` 只负责传递数据，不再触发读取注册
- `fireReadCompleted()` 在本轮所有数据处理完成后调用，用于触发读取注册
- `TailReadProcessor` 只在 `readCompleted()` 中调用 `registerRead()`

## 调用流程变更

**变更前：**
```
AdaptiveReadCompletionHandler.completed()
  → pipeline.fireRead(data)
    → 各ReadProcessor处理，可能多次fireRead(null)
      → TailReadProcessor.read(null)
        → registerRead() [可能被多次调用，导致异常]
```

**变更后：**
```
AdaptiveReadCompletionHandler.completed()
  → pipeline.fireRead(data)
    → 各ReadProcessor处理数据（可以多次调用fireRead）
      → TailReadProcessor.read() [不再调用registerRead]
  → pipeline.fireReadCompleted()
    → 各ReadProcessor.readCompleted()
      → TailReadProcessor.readCompleted()
        → registerRead() [只调用一次]
```

# 实施步骤

## 步骤1：修改 ReadProcessor 接口

在 `cc.jfire.jnet.common.api.ReadProcessor` 接口中添加 `readCompleted` 方法：

```java
/**
 * 本轮读取处理完成时触发，用于通知处理器本轮数据已全部处理完毕
 */
default void readCompleted(ReadProcessorNode next)
{
    next.fireReadCompleted();
}
```

## 步骤2：修改 ReadProcessorNode 接口

在 `cc.jfire.jnet.common.api.ReadProcessorNode` 接口中添加 `fireReadCompleted` 方法：

```java
void fireReadCompleted();
```

## 步骤3：修改 ReadProcessorNodeImpl 实现类

在 `cc.jfire.jnet.common.internal.ReadProcessorNodeImpl` 类中实现 `fireReadCompleted` 方法：

```java
@Override
public void fireReadCompleted()
{
    processor.readCompleted(next);
}
```

## 步骤4：修改 InternalPipeline 接口

在 `cc.jfire.jnet.common.api.InternalPipeline` 接口中添加 `fireReadCompleted` 方法声明：

```java
void fireReadCompleted();
```

## 步骤5：修改 DefaultPipeline 实现类

在 `cc.jfire.jnet.common.internal.DefaultPipeline` 类中实现 `fireReadCompleted` 方法：

```java
@Override
public void fireReadCompleted()
{
    try
    {
        readHead.fireReadCompleted();
    }
    catch (Throwable e)
    {
        jvmExistHandler.accept(e);
        System.exit(127);
    }
}
```

## 步骤6：修改 TailReadProcessor 类

修改 `cc.jfire.jnet.common.internal.TailReadProcessor` 类：

1. `read()` 方法被调用时直接抛出异常，因为正常情况下数据不应该传递到末端处理器
2. 新增 `readCompleted()` 方法来调用 `registerRead()`

```java
@Override
public void read(Object data, ReadProcessorNode next)
{
    // 如果数据传递到末端处理器，说明处理链存在问题，应立即抛出异常
    throw new IllegalStateException("数据不应该传递到 TailReadProcessor，请检查处理链配置");
}

@Override
public void readCompleted(ReadProcessorNode next)
{
    completionHandler.registerRead();
}
```

## 步骤7：修改 AdaptiveReadCompletionHandler 类

修改 `cc.jfire.jnet.common.internal.AdaptiveReadCompletionHandler` 类的 `completed()` 方法，在 `fireRead()` 之后调用 `fireReadCompleted()`：

```java
@Override
public void completed(Integer read, AdaptiveReadCompletionHandler handler)
{
    if (read == -1)
    {
        failed(new EndOfStreamException(), this);
        return;
    }
    int      except    = ioBuffer.capacity();
    IoBuffer thisRound = ioBuffer;
    ioBuffer = nextReadBuffer(except, read);
    if (read != 0)
    {
        thisRound.addWritePosi(read);
        pipeline.fireRead(thisRound);
        pipeline.fireReadCompleted();
    }
    else
    {
        thisRound.free();
        System.err.println("读取到了0");
        pipeline.fireReadCompleted();
    }
}
```

## 步骤8：移除 TransferProcessor 中的 fireRead(null) 调用

修改 `cc.jfire.jnet.extend.reverse.proxy.TransferProcessor` 类的 `read()` 方法，移除第59行的 `next.fireRead(null)` 调用，因为现在不再需要通过 `fireRead(null)` 来触发读取注册。

# 待办列表

1. [x] 修改 ReadProcessor 接口，添加 readCompleted 方法
2. [x] 修改 ReadProcessorNode 接口，添加 fireReadCompleted 方法
3. [x] 修改 ReadProcessorNodeImpl 类，实现 fireReadCompleted 方法
4. [x] 修改 InternalPipeline 接口，添加 fireReadCompleted 方法声明
5. [x] 修改 DefaultPipeline 类，实现 fireReadCompleted 方法
6. [x] 修改 TailReadProcessor 类，调整 read 方法并添加 readCompleted 方法
7. [x] 修改 AdaptiveReadCompletionHandler 类，在 completed 方法中调用 fireReadCompleted
8. [x] 修改 TransferProcessor 类，移除 fireRead(null) 调用
9. [x] 编译验证修改是否正确

# 需要修改或新增的类

## 需要修改的类

1. `cc.jfire.jnet.common.api.ReadProcessor` - 添加 readCompleted 方法
2. `cc.jfire.jnet.common.api.ReadProcessorNode` - 添加 fireReadCompleted 方法
3. `cc.jfire.jnet.common.internal.ReadProcessorNodeImpl` - 实现 fireReadCompleted 方法
4. `cc.jfire.jnet.common.api.InternalPipeline` - 添加 fireReadCompleted 方法声明
5. `cc.jfire.jnet.common.internal.DefaultPipeline` - 实现 fireReadCompleted 方法
6. `cc.jfire.jnet.common.internal.TailReadProcessor` - 修改 read 方法，添加 readCompleted 方法
7. `cc.jfire.jnet.common.internal.AdaptiveReadCompletionHandler` - 修改 completed 方法
8. `cc.jfire.jnet.extend.reverse.proxy.TransferProcessor` - 移除 fireRead(null) 调用

## 无需新增的类

本次修改无需新增任何类，只需修改现有类。