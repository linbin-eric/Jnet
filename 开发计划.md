# 目标

1. 设计一个简单的 HttpConnection2的连接池，要实现如下的功能。
   1. 支持设定每一个请求地址的链接数量上限。
   2. 支持借出链接和归还链接。如果借出链接到达上限，则需要超时等待。

# 核心思路

1. 采用 Map<String,Bucket> 的方式来存储，key 为 "host:port" 字符串。
2. Bucket 同时存储了Semaphore和 MPMCArrayQueue，前者用来控制当前 Bucket 可以使用的链接数量许可，后者用来存储池化的链接。
3. 链接在借出和归还的时候都需要检测链接是否有效。
4. 每个 host:port 的默认最大连接数为 10。
5. 借出连接的默认超时时间为 5 秒。
6. 不需要定期清理机制，仅在借出和归还时检测连接有效性。

# 详细实现思路

1. **连接池整体架构**：
   - 使用 `ConcurrentHashMap<String, Bucket>` 存储所有连接桶，key 格式为 "host:port"
   - 每个 Bucket 包含：
     - `Semaphore` 信号量：控制该地址的最大连接数（许可数 = 最大连接数），通过 maxConnections - availablePermits() 可计算当前连接数
     - `MPMCArrayQueue<HttpConnection2>` 队列：存储空闲可复用的连接对象
     - `int maxConnections` 配置：该地址允许的最大连接数

2. **借出连接流程（borrowConnection）**：
   - 根据 host 和 port 构建 key，获取或创建对应的 Bucket
   - 首先尝试从 Bucket 的队列中 poll 获取空闲连接
   - 如果获取到连接，检查连接是否有效（`isConnectionClosed()`）
     - 有效则直接返回
     - 无效则释放信号量许可，继续下一步
   - 如果队列为空，尝试从信号量获取许可（`tryAcquire(timeout, TimeUnit.SECONDS)`）
     - 获取到许可后，再次尝试从队列中 poll（可能其他线程刚归还了连接）
       - 如果获取到有效连接，释放信号量许可并返回连接（避免许可浪费）
       - 如果未获取到连接，创建新的 HttpConnection2 连接并返回
     - 未获取到许可（超时），抛出 TimeoutException

3. **归还连接流程（returnConnection）**：
   - 根据 host 和 port 构建 key，获取对应的 Bucket
   - 检查连接是否有效（`isConnectionClosed()`）
     - 无效则释放信号量许可，不加入队列
     - 有效则尝试放入队列（`offer`）
       - 成功则完成归还
       - 失败（队列满）则关闭连接并释放信号量许可

4. **Bucket 结构设计**：
   ```java
   private static class Bucket {
       private final Semaphore semaphore;                      // 控制最大连接数
       private final MPMCArrayQueue<HttpConnection2> queue;     // 存储空闲连接
       private final int maxConnections;                        // 最大连接数配置

       public Bucket(int maxConnections) {
           this.maxConnections = maxConnections;
           this.semaphore = new Semaphore(maxConnections);
           this.queue = new MpmcArrayQueue<>(maxConnections);
       }
   }
   ```

5. **连接创建参数**：
   - domain: 从 key 中解析的 host
   - port: 从 key 中解析的 port
   - secondsOfKeepAlive: 固定为 1800 秒（30分钟），与 HttpConnectionPool 保持一致

6. **异常处理**：
   - 借出超时抛出 `TimeoutException`
   - 连接创建失败需要释放已获取的信号量许可
   - 无效连接必须释放信号量许可

# 实施步骤

## 步骤1：创建 HttpConnection2Pool 类基础结构

在 `src/main/java/cc/jfire/jnet/extend/http/client/HttpConnection2Pool.java` 创建类，包含以下内容：

```java
package cc.jfire.jnet.extend.http.client;

import org.jctools.queues.MpmcArrayQueue;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

@Slf4j
public class HttpConnection2Pool
{
    private static final int DEFAULT_MAX_CONNECTIONS_PER_HOST = 10;
    private static final int DEFAULT_TIMEOUT_SECONDS = 5;
    private static final int KEEP_ALIVE_SECONDS = 1800; // 30分钟

    private final ConcurrentHashMap<String, Bucket> buckets = new ConcurrentHashMap<>();

    private static class Bucket
    {
        private final Semaphore semaphore;
        private final MpmcArrayQueue<HttpConnection2> queue;
        private final int maxConnections;

        public Bucket(int maxConnections)
        {
            this.maxConnections = maxConnections;
            this.semaphore = new Semaphore(maxConnections);
            this.queue = new MpmcArrayQueue<>(maxConnections);
        }
    }

    private String buildKey(String host, int port)
    {
        return host + ":" + port;
    }
}
```

## 步骤2：实现 borrowConnection 方法

在 HttpConnection2Pool 类中添加借出连接的方法：

```java
public HttpConnection2 borrowConnection(String host, int port) throws TimeoutException, InterruptedException
{
    return borrowConnection(host, port, DEFAULT_TIMEOUT_SECONDS);
}

public HttpConnection2 borrowConnection(String host, int port, int timeoutSeconds) throws TimeoutException, InterruptedException
{
    String key = buildKey(host, port);
    Bucket bucket = buckets.computeIfAbsent(key, k -> new Bucket(DEFAULT_MAX_CONNECTIONS_PER_HOST));

    // 首先尝试从队列获取现有连接
    HttpConnection2 connection = bucket.queue.poll();
    if (connection != null)
    {
        if (!connection.isConnectionClosed())
        {
            log.debug("地址:{}从队列借出连接，当前队列剩余:{}", key, bucket.queue.size());
            return connection;
        }
        else
        {
            // 连接已失效，释放许可
            bucket.semaphore.release();
            log.debug("地址:{}队列中的连接已失效，已清理", key);
        }
    }

    // 队列为空，尝试获取信号量许可
    if (bucket.semaphore.tryAcquire(timeoutSeconds, TimeUnit.SECONDS))
    {
        // 获取许可后再次尝试从队列获取（可能其他线程刚归还）
        connection = bucket.queue.poll();
        if (connection != null && !connection.isConnectionClosed())
        {
            bucket.semaphore.release(); // 释放许可，因为使用的是已有连接
            log.debug("地址:{}从队列借出连接（二次尝试），当前队列剩余:{}", key, bucket.queue.size());
            return connection;
        }

        // 需要创建新连接
        try
        {
            connection = new HttpConnection2(host, port, KEEP_ALIVE_SECONDS);
            log.debug("地址:{}创建新连接，当前连接总数:{}", key, bucket.maxConnections - bucket.semaphore.availablePermits());
            return connection;
        }
        catch (Exception e)
        {
            // 创建失败，释放许可
            bucket.semaphore.release();
            throw new RuntimeException("创建连接失败: " + e.getMessage(), e);
        }
    }
    else
    {
        // 超时未获取到许可
        throw new TimeoutException("无法在 " + timeoutSeconds + " 秒内获取到可用连接，地址: " + key);
    }
}
```

## 步骤3：实现 returnConnection 方法

在 HttpConnection2Pool 类中添加归还连接的方法：

```java
public void returnConnection(String host, int port, HttpConnection2 connection)
{
    if (connection == null)
    {
        return;
    }

    String key = buildKey(host, port);
    Bucket bucket = buckets.get(key);

    if (bucket == null)
    {
        log.warn("地址:{}的Bucket不存在，关闭连接", key);
        connection.close();
        return;
    }

    // 检查连接是否有效
    if (connection.isConnectionClosed())
    {
        // 连接已失效，释放许可
        bucket.semaphore.release();
        log.debug("地址:{}归还的连接已失效，已释放许可，当前连接总数:{}", key, bucket.maxConnections - bucket.semaphore.availablePermits());
        return;
    }

    // 连接有效，尝试放入队列
    boolean offered = bucket.queue.offer(connection);
    if (offered)
    {
        log.debug("地址:{}归还连接到队列，当前队列大小:{}", key, bucket.queue.size());
    }
    else
    {
        // 队列已满，关闭连接并释放许可
        connection.close();
        bucket.semaphore.release();
        log.warn("地址:{}队列已满，关闭归还的连接，当前连接总数:{}", key, bucket.maxConnections - bucket.semaphore.availablePermits());
    }
}
```

## 步骤4：实现辅助方法

在 HttpConnection2Pool 类中添加辅助查询方法：

```java
/**
 * 获取当前连接总数（包括正在使用和队列中的）
 */
public int getConnectionCount(String host, int port)
{
    String key = buildKey(host, port);
    Bucket bucket = buckets.get(key);
    return bucket != null ? bucket.maxConnections - bucket.semaphore.availablePermits() : 0;
}

/**
 * 获取队列中的空闲连接数
 */
public int getPoolSize(String host, int port)
{
    String key = buildKey(host, port);
    Bucket bucket = buckets.get(key);
    return bucket != null ? bucket.queue.size() : 0;
}

/**
 * 获取可用的许可数（还能创建多少新连接）
 */
public int getAvailablePermits(String host, int port)
{
    String key = buildKey(host, port);
    Bucket bucket = buckets.get(key);
    return bucket != null ? bucket.semaphore.availablePermits() : 0;
}
```

# 待办列表

1. 创建 HttpConnection2Pool 类基础结构
2. 实现 borrowConnection 方法（含超时参数重载）
3. 实现 returnConnection 方法
4. 实现辅助查询方法（getConnectionCount、getPoolSize、getAvailablePermits）

# 需要修改或新增的类

## 新增的类

1. **HttpConnection2Pool** - HTTP连接池类
   - 路径：`src/main/java/cc/jfire/jnet/extend/http/client/HttpConnection2Pool.java`
   - 职责：管理 HttpConnection2 连接的借出、归还和生命周期

2. **HttpConnection2Pool.Bucket** - 连接桶内部类
   - 职责：封装每个 host:port 的连接管理数据结构（信号量、队列）

## 依赖的现有类

1. **HttpConnection2** - HTTP客户端连接类
   - 使用其构造方法创建连接
   - 使用 `isConnectionClosed()` 检测连接有效性
   - 使用 `close()` 关闭无效连接

2. **MpmcArrayQueue**（来自 jctools-core）
   - 用于存储空闲的 HttpConnection2 对象

