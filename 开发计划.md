# 目标

1. FullHttpResponse 中不需要自己持有version等这些参数，而是应该直接持有HttpResponsePartHead

# 核心思路

1. 参考 HttpRequest 的重构方式（commit ef5a118），将 FullHttpResponse 从直接持有 version、statusCode、reasonPhrase、headers 等属性改为组合模式持有 HttpResponsePartHead 对象
2. 不添加委托方法，直接暴露 head 属性，让外部通过 `getHead()` 访问 HttpResponsePartHead，实现彻底的重构
3. 修改 write() 方法的实现，利用 HttpResponsePartHead 的能力来编码响应头部
4. 更新所有使用 FullHttpResponse 的代码，改为通过 `getHead()` 访问响应头相关属性

# 详细实现思路

## 1. 重构 FullHttpResponse 类结构

将 FullHttpResponse 从直接持有响应头属性改为持有 HttpResponsePartHead 对象，类似于 HttpRequest 持有 HttpRequestPartHead 的方式。

### 当前结构问题：
- FullHttpResponse 重复定义了 version、statusCode、reasonPhrase、headers 等属性
- 这些属性与 HttpResponsePartHead 中的属性重复
- 违反 DRY 原则，增加维护成本

### 重构后结构：
- FullHttpResponse 持有一个 HttpResponsePartHead 类型的 head 属性
- 直接暴露 head 属性（通过 Lombok @Data 自动生成 getHead() 方法）
- 外部代码通过 `response.getHead().setStatusCode(200)` 等方式访问
- 这样的改造更彻底，避免代码臃肿

## 2. 修改 write() 方法实现

当前 write() 方法直接使用 FullHttpResponse 自己的属性来编码响应。重构后应该：
- 利用 HttpResponsePartHead 的能力
- 可以考虑调用 HttpRespEncoder 中已有的 HttpResponsePartHead 编码逻辑，避免重复代码
- 或者在 HttpResponsePartHead 中添加编码方法，供 FullHttpResponse 调用

## 3. 更新使用方代码

需要检查所有使用 FullHttpResponse 的地方（约14个文件），将所有访问响应头的代码改为通过 `getHead()` 访问：
- `response.setVersion(...)` → `response.getHead().setVersion(...)`
- `response.getStatusCode()` → `response.getHead().getStatusCode()`
- `response.setStatusCode(...)` → `response.getHead().setStatusCode(...)`
- `response.setReasonPhrase(...)` → `response.getHead().setReasonPhrase(...)`
- `response.getHeaders()` → `response.getHead().getHeaders()`
- `response.addHeader(...)` - 保持不变（该方法保留，因为有特殊的 hasContentLength/hasContentType 逻辑）
- 特别关注 HttpRespEncoder、各种 Processor 和测试代码

# 实施步骤

## 步骤1：修改 FullHttpResponse 类结构

在 FullHttpResponse.java 中：

```java
@Data
@Accessors(chain = true)
public class FullHttpResponse implements HttpResponsePart
{
    private static final byte[] NEWLINE = "\r\n".getBytes(StandardCharsets.US_ASCII);

    // 新增：持有 HttpResponsePartHead
    private HttpResponsePartHead head = new HttpResponsePartHead();

    // 删除以下属性（已包含在 head 中）：
    // private String              version      = "HTTP/1.1";
    // private int                 statusCode   = 200;
    // private String              reasonPhrase = "OK";
    // private Map<String, String> headers      = new HashMap<>();

    // 响应体相关属性保持不变
    private IoBuffer bodyBuffer;
    private byte[]   bodyBytes;
    private String   bodyText;

    private boolean hasContentLength = false;
    private boolean hasContentType   = false;

    // 修改 addHeader 方法，直接操作 head
    public FullHttpResponse addHeader(String name, String value)
    {
        String lowerName = name.toLowerCase();
        if (lowerName.equals("content-length"))
        {
            hasContentLength = true;
        }
        if (lowerName.equals("content-type"))
        {
            hasContentType = true;
        }
        head.addHeader(name, value);
        return this;
    }

    // write() 方法需要修改实现
    public void write(IoBuffer buffer)
    {
        helpSetContentLengthIfNeed();
        helpSetContentTypeIfNeed();

        // 编码响应行：HTTP/1.1 200 OK\r\n
        buffer.put((head.getVersion() + " " + head.getStatusCode() + " " + head.getReasonPhrase() + "\r\n")
                   .getBytes(StandardCharsets.US_ASCII));

        // 编码 headers
        head.getHeaders().forEach((name, value) ->
            buffer.put((name + ": " + value + "\r\n").getBytes(StandardCharsets.US_ASCII)));

        // 空行结束头部
        buffer.put(NEWLINE);

        // 编码 body
        writeBody(buffer);
    }

    // helpSetContentLengthIfNeed() 和 helpSetContentTypeIfNeed() 方法保持不变
    // writeBody() 方法保持不变
    // free() 方法需要添加 head 的释放
    @Override
    public void free()
    {
        head.free();
        if (bodyBuffer != null)
        {
            bodyBuffer.free();
            bodyBuffer = null;
        }
    }

    // isLast() 方法保持不变
}
```

**说明**：保留 addHeader() 方法是因为它有额外的逻辑（hasContentLength 和 hasContentType 标记），这些是 FullHttpResponse 特有的。其他属性访问全部通过 `getHead()` 进行。

## 步骤2：初始化 head 的默认值

需要在 FullHttpResponse 构造时或在 head 的初始化时设置默认值：

```java
private HttpResponsePartHead head = new HttpResponsePartHead();

// 在构造函数或初始化块中设置默认值
{
    head.setVersion("HTTP/1.1");
    head.setStatusCode(200);
    head.setReasonPhrase("OK");
}
```

或者修改 HttpResponsePartHead 类，为其属性提供默认值。

## 步骤3：检查并更新使用方代码

需要逐个检查以下文件中使用 FullHttpResponse 的代码，将访问响应头的方式改为通过 `getHead()`：

1. **NotFoundUrlProcessor.java**
   - `response.setStatusCode(404)` → `response.getHead().setStatusCode(404)`
   - `response.setReasonPhrase("Not Found")` → `response.getHead().setReasonPhrase("Not Found")`

2. **SampleHttpServer.java**
   - `resp.addHeader("Content-Type", "text/html")` - 保持不变（addHeader 方法保留）

3. **CorsEncoder.java**
   - `httpResponse.addHeader(...)` - 保持不变（addHeader 方法保留）

4. **ProxyHttpHandler2.java** - 需要逐行检查，修改所有访问响应头的代码

5. **ClassResourceHandler.java** - 需要逐行检查

6. **FileResourceHandler.java** - 需要逐行检查

7. **TransferProcessor.java** - 需要逐行检查

8. **ResourceProcessor.java** - 需要逐行检查

9. **OptionsProcessor.java** - 需要逐行检查

10. **AbstractResourceEncoder.java** - 需要逐行检查

11. **HttpRespEncoder.java** - 只处理编码逻辑，无需修改

对于每个文件的修改原则：
- 除了 `addHeader()` 方法保持不变外
- 所有其他访问响应头的操作都改为 `response.getHead().xxx()`

## 步骤4：运行测试验证

编译项目，确保没有编译错误：
```bash
mvn clean compile
```

如果有测试，运行测试确保功能正常：
```bash
mvn test
```

# 待办列表

1. [ ] 修改 FullHttpResponse 类，删除 version/statusCode/reasonPhrase/headers 属性，新增 head 属性
2. [ ] 修改 FullHttpResponse 的 addHeader() 方法，改为操作 head
3. [ ] 修改 FullHttpResponse 的 write() 方法实现，使用 head 的属性
4. [ ] 修改 FullHttpResponse 的 free() 方法，添加 head 的释放
5. [ ] 为 head 对象设置默认值（version="HTTP/1.1", statusCode=200, reasonPhrase="OK"）
6. [ ] 逐个检查并更新所有使用 FullHttpResponse 的文件，改为通过 getHead() 访问
7. [ ] 编译项目验证无编译错误
8. [ ] 运行测试验证功能正常

# 需要修改或新增的类

## 需要修改的类：

1. **FullHttpResponse** - 主要修改类，从直接持有属性改为持有 HttpResponsePartHead
2. **HttpRespEncoder** - 可能需要微调（需检查）
3. **ProxyHttpHandler2** - 可能需要调整使用方式（需检查）
4. **ClassResourceHandler** - 可能需要调整使用方式（需检查）
5. **FileResourceHandler** - 可能需要调整使用方式（需检查）
6. **TransferProcessor** - 可能需要调整使用方式（需检查）
7. **ResourceProcessor** - 可能需要调整使用方式（需检查）
8. **OptionsProcessor** - 可能需要调整使用方式（需检查）
9. **AbstractResourceEncoder** - 可能需要调整使用方式（需检查）
10. **NotFoundUrlProcessor** - 可能需要调整使用方式（需检查）
11. **CorsEncoder** - 可能需要调整使用方式（需检查）
12. **SampleHttpServer** - 测试代码，可能需要调整（需检查）

## 不需要新增的类

本次重构不需要新增类，仅修改现有类的内部实现。