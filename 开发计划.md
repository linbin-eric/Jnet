# 目标

1. HttpRequest 应该增加 url 参数。当想用 HttpRequest 作为发送的参数，可以将 url 解析后，对 method，path，version 进行设置。
2. HttpRequest 应该增加 domain 和 port 参数，支持从 url 中解析出domain 和 port。并且解析成功后，还需要构建 host 的 header，放入 header 中。
3. HttpRequest 应该增加 strBody 参数。
4. 开发一个 HttpRequestPartEncoder，支持对 HttpRequest 和 HttpRequestPartHead，HttpRequestPartBody 进行编码。开发的要求有：
   1. 对于 HttpRequest，如果 body 不为空，则可以 body 作为请求内容体进行写出；如果 body 为空且 strBody不为空，则将 strBody 按照编码写出。在写出之前，判断是否已经存在 Content-Length 这样的header，如果不存在，则需要明确内容体的长度，补充这个 header。补充后进行写出。
   1. 对于HttpRequestPartHead，如果headBuffer 不存在值，则对head 的部分按照正常方式进行编码后写出；如果存在值，则直接将 headBuffer 写出。
   1. 对于 HttpRequestPartBody，则直接写出。

# 核心思路

1. **HttpRequest 增强**：在现有 HttpRequest 类基础上增加 url、domain、port、strBody 字段。新增 setUrl 方法用于解析 URL 并自动设置 method、path、version，同时解析出 domain 和 port，并构建 Host header。

2. **HttpRequestPartEncoder 设计**：实现 WriteProcessor<Object> 接口，支持编码多种类型的请求对象。使用 instanceof 判断传入对象类型，分别处理：
   - **HttpRequest**：完整请求编码，包含请求行、headers、body
   - **HttpRequestPartHead**：请求头编码，优先使用 headBuffer 直接写出，否则按标准格式编码
   - **HttpRequestPart（Body类型）**：直接写出 body buffer

3. **Content-Length 自动补充**：在写出 HttpRequest 时，使用大小写不敏感的方式检查是否已存在 Content-Length header。如不存在，根据 body 或 strBody 计算长度并补充。

4. **编码优先级**：对于 HttpRequest 的 body，优先使用 IoBuffer 类型的 body，其次使用 strBody 按 UTF-8 编码写出。

# 详细实现思路

## 1. HttpRequest 类增强

在 HttpRequest 类中新增以下字段：
- `url`: String 类型，原始 URL 地址
- `domain`: String 类型，从 URL 解析出的域名
- `port`: int 类型，从 URL 解析出的端口（默认 80/443）
- `strBody`: String 类型，字符串形式的请求体

新增方法：
- `setUrl(String url)`: 解析 URL，自动设置 path、domain、port，并添加 Host header

URL 解析逻辑参考 HttpClient.perfect() 方法：
- 支持 http:// 和 https:// 协议前缀
- 解析域名和端口号
- 提取 path 部分
- 构建 Host header（格式：domain 或 domain:port）

## 2. HttpRequestPartEncoder 实现

创建新类 HttpRequestPartEncoder，实现 WriteProcessor<Object> 接口：

```java
public class HttpRequestPartEncoder implements WriteProcessor<Object>
```

### 2.1 处理 HttpRequest

1. 分配 IoBuffer
2. 写入请求行：`method + " " + path + " " + version + "\r\n"`
3. 计算 body 长度（优先 body IoBuffer，其次 strBody）
4. 使用大小写不敏感的方式检查并补充 Content-Length header（遍历 headers 的 key，使用 equalsIgnoreCase 判断）
5. 写入所有 headers：`name + ": " + value + "\r\n"`
6. 写入空行：`\r\n`
7. 写入 body 内容

### 2.2 处理 HttpRequestPartHead

1. 判断 headBuffer 是否存在
   - 存在：直接将 headBuffer 写出
   - 不存在：按标准格式编码（请求行 + headers + 空行）

### 2.3 处理 HttpRequestPart（Body 类型）

对于 HttpRequestFixLengthBodyPart 和 HttpRequestChunkedBodyPart：
- 直接将其 part buffer 写出

# 实施步骤

## 步骤 1：修改 HttpRequest 类

文件：`src/main/java/cc/jfire/jnet/extend/http/dto/HttpRequest.java`

添加以下字段：
```java
protected String url;
protected String domain;
protected int port = 80;
protected String strBody;
```

添加 setUrl 方法：
```java
public HttpRequest setUrl(String url) {
    this.url = url;
    int index = 0;
    int domainStart = 0;
    boolean isHttps = false;
    if (url.startsWith("http://")) {
        index = url.indexOf("/", 8);
        domainStart = 7;
    } else if (url.startsWith("https://")) {
        index = url.indexOf("/", 9);
        domainStart = 8;
        isHttps = true;
    }
    if (index == -1) {
        index = url.length();
    }
    int portStart = url.indexOf(':', domainStart);
    this.path = index == url.length() ? "/" : url.substring(index);
    this.port = portStart == -1 ? (isHttps ? 443 : 80) : Integer.parseInt(url.substring(portStart + 1, index));
    this.domain = portStart == -1 ? url.substring(domainStart, index) : url.substring(domainStart, portStart);
    // 构建 Host header
    String host = portStart == -1 ? this.domain : url.substring(domainStart, index);
    this.headers.put("Host", host);
    return this;
}
```

## 步骤 2：创建 HttpRequestPartEncoder 类

文件：`src/main/java/cc/jfire/jnet/extend/http/coder/HttpRequestPartEncoder.java`

```java
package cc.jfire.jnet.extend.http.coder;

import cc.jfire.jnet.common.api.WriteProcessor;
import cc.jfire.jnet.common.api.WriteProcessorNode;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.jnet.extend.http.dto.*;

import java.nio.charset.StandardCharsets;
import java.util.Map;

public class HttpRequestPartEncoder implements WriteProcessor<Object> {
    private static final byte[] NEW_LINE = "\r\n".getBytes(StandardCharsets.US_ASCII);
    private static final String CONTENT_LENGTH_HEADER = "Content-Length";

    @Override
    public void write(Object data, WriteProcessorNode next) {
        if (data instanceof HttpRequest) {
            encodeHttpRequest((HttpRequest) data, next);
        } else if (data instanceof HttpRequestPartHead) {
            encodeHttpRequestPartHead((HttpRequestPartHead) data, next);
        } else if (data instanceof HttpRequestFixLengthBodyPart) {
            encodeFixLengthBody((HttpRequestFixLengthBodyPart) data, next);
        } else if (data instanceof HttpRequestChunkedBodyPart) {
            encodeChunkedBody((HttpRequestChunkedBodyPart) data, next);
        } else {
            next.fireWrite(data);
        }
    }

    /**
     * 大小写不敏感地检查 headers 中是否存在指定名称的 header
     */
    private boolean containsHeaderIgnoreCase(Map<String, String> headers, String headerName) {
        for (String key : headers.keySet()) {
            if (key.equalsIgnoreCase(headerName)) {
                return true;
            }
        }
        return false;
    }

    private void encodeHttpRequest(HttpRequest request, WriteProcessorNode next) {
        IoBuffer buffer = next.pipeline().allocator().allocate(1024);

        // 写入请求行
        String requestLine = request.getMethod() + " " + request.getPath() + " " +
                            (request.getVersion() != null ? request.getVersion() : "HTTP/1.1") + "\r\n";
        buffer.put(requestLine.getBytes(StandardCharsets.US_ASCII));

        // 计算 body 长度
        int contentLength = 0;
        byte[] strBodyBytes = null;
        if (request.getBody() != null) {
            contentLength = request.getBody().remainRead();
        } else if (request.getStrBody() != null) {
            strBodyBytes = request.getStrBody().getBytes(StandardCharsets.UTF_8);
            contentLength = strBodyBytes.length;
        }

        // 使用大小写不敏感的方式检查并补充 Content-Length
        if (!containsHeaderIgnoreCase(request.getHeaders(), CONTENT_LENGTH_HEADER)) {
            request.getHeaders().put(CONTENT_LENGTH_HEADER, String.valueOf(contentLength));
        }

        // 写入 headers
        request.getHeaders().forEach((name, value) ->
            buffer.put((name + ": " + value + "\r\n").getBytes(StandardCharsets.US_ASCII)));

        // 写入空行
        buffer.put(NEW_LINE);

        // 写入 body
        if (request.getBody() != null) {
            buffer.put(request.getBody());
        } else if (strBodyBytes != null && strBodyBytes.length > 0) {
            buffer.put(strBodyBytes);
        }

        next.fireWrite(buffer);
    }

    private void encodeHttpRequestPartHead(HttpRequestPartHead head, WriteProcessorNode next) {
        if (head.getHeadBuffer() != null) {
            // 直接写出 headBuffer
            next.fireWrite(head.getHeadBuffer());
        } else {
            // 按标准格式编码
            IoBuffer buffer = next.pipeline().allocator().allocate(1024);
            String requestLine = head.getMethod() + " " + head.getPath() + " " +
                                (head.getVersion() != null ? head.getVersion() : "HTTP/1.1") + "\r\n";
            buffer.put(requestLine.getBytes(StandardCharsets.US_ASCII));

            head.getHeaders().forEach((name, value) ->
                buffer.put((name + ": " + value + "\r\n").getBytes(StandardCharsets.US_ASCII)));

            buffer.put(NEW_LINE);
            next.fireWrite(buffer);
        }
    }

    private void encodeFixLengthBody(HttpRequestFixLengthBodyPart body, WriteProcessorNode next) {
        if (body.getPart() != null) {
            next.fireWrite(body.getPart());
        }
    }

    private void encodeChunkedBody(HttpRequestChunkedBodyPart body, WriteProcessorNode next) {
        if (body.getPart() != null) {
            next.fireWrite(body.getPart());
        }
    }
}
```

# 待办列表

1. [x] 修改 HttpRequest 类，添加 url、domain、port、strBody 字段
2. [x] 为 HttpRequest 类添加 setUrl 方法实现 URL 解析
3. [x] 为 HttpRequest 类添加 strBody 的 getter/setter
4. [x] 创建 HttpRequestPartEncoder 类
5. [x] 实现 HttpRequest 编码逻辑
6. [x] 实现 HttpRequestPartHead 编码逻辑
7. [x] 实现 HttpRequestFixLengthBodyPart 编码逻辑
8. [x] 实现 HttpRequestChunkedBodyPart 编码逻辑
9. [x] 编译验证代码正确性

# 需要修改或新增的类

| 类型 | 类名 | 说明 |
|------|------|------|
| 修改 | `cc.jfire.jnet.extend.http.dto.HttpRequest` | 添加 url、domain、port、strBody 字段及 setUrl 方法 |
| 新增 | `cc.jfire.jnet.extend.http.coder.HttpRequestPartEncoder` | 实现对 HttpRequest、HttpRequestPartHead、HttpRequestPart(Body) 的编码 |