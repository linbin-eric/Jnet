# 目标

1. 修改 TransferProcessor 的实现，让他要能处理 HttpRequestPart 的请求。具体如下：

# 核心思路

1. TransferProcessor 应该增加一个属性，用来保存当前被激活的 handler。该属性默认为 null，当首次处理 HttpRequestPartHead 请求的时候，根据匹配到的 handler，对该属性进行赋值。而当处理到 HttpRequestPartEnd 的时候，清除该属性。
2. ResourceHandler 接口应该加一个 match 方法，用来判断是否吻合当前这个 httpRequestpartHead。应该修改 process 接口，入参修改为 HttpRequestPart。
3. PrefixMatchProxyHttpHandler 和FullMatchProxyHttpHandler 的 process 要重新实现，要求如下：
   1. 当处理 HttpRequestPartHead 的时候，计算正确的后端 url，设置到 url 属性中然后传递给 proxyBackendUrl 方法。
   2. 当处理 HttpRequestPartBody 的时候，不需要处理，直接传递。
4. 方法：cc.jfire.jnet.extend.reverse.proxy.api.handler.ProxyHttpHandler.proxyBackendUrl 要重新实现，修改的点有：
   1. 去掉方法参数的 backendUrl，因为已经在HttpRequestPartHead 中了。
   2. 增加一个属性，存储当前使用的后端 HttpConnection2实例。在第一次处理到 HttpRequestPartHead 的时候，提取有效的domain 和 port，从HttpConnection2Pool 中申请链接。申请成功则设置到当前属性。申请失败不做任何处理。
   3. 当处理 HttpRequestPartBody 的时候，如果HttpConnection2 属性没有值，则直接释放。当处理 HttpRequestPartEnd 的时候，如果HttpConnection2 没有值，则发送链接过多响应内容。
   4. 当处理HttpRequestPartBody 的时候，如果HttpConnection2 属性有值，则将 body 通过 httpConnection2 写出。则直接释放。当处理 HttpRequestPartEnd 的时候，如果HttpConnection2 有值，则将该链接归还连接池，并且清除该属性。
   5. 如果收到HttpRequestPartHead 的时候，HttpConnection2 属性有值，则关闭链接，并且释放当前资源。
   6. 使用 HttpConnection2 的 write 方法，应当选择：cc.jfire.jnet.extend.http.client.HttpConnection2.write(cc.jfire.jnet.extend.http.dto.HttpRequestPartHead, java.util.function.Consumer<cc.jfire.jnet.extend.http.dto.HttpResponsePart>, java.util.function.Consumer<java.lang.Throwable>) 方法，首先写出头部，后续写出请求体。
