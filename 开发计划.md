# 目标

1. 优化下面的这部分代码，代码在cc.jfire.jnet.extend.reverse.proxy.api.handler.ProxyHttpHandler2.processHead中，代码内容是
   private void processHead(HttpRequestPartHead head, Pipeline pipeline)
   {
   log.debug("[ProxyHttpHandler2] processHead() 开始处理请求头, method={}, path={}, isLast={}", head.getMethod(), head.getPath(), head.isLast());
   // 计算后端 URL
   String requestUrl = head.getPath();
   int    index      = requestUrl.indexOf("#");
   if (index != -1)
   {
   requestUrl = requestUrl.substring(0, index);
   }
   String backendUrl = proxy + requestUrl.substring(prefixLen);
   head.setUrl(backendUrl);

优化的方向是，由于 proxy 的固定，实际上每次的 domain、port、host 都是固定的。就不需要每次都调用 setUrl 来进行内部的解析。

# 核心思路

由于 `proxy` 是固定的，在构造函数中已经解析出了 `backendHost` 和 `backendPort`，因此每次请求时不需要重复调用 `setUrl` 进行完整的 URL 解析。可以直接设置 `domain`、`port`、`path` 和 `Host` header，避免每次都调用 `HttpUrl.parse()` 进行重复解析，从而提升性能。

# 详细实现思路

1. **在构造函数中预先计算固定值**：
   - 已有：`backendHost`（domain）
   - 已有：`backendPort`（port）
   - 新增：`backendHostHeader`（Host header 的值，格式为 `domain:port` 或仅 `domain`）

2. **在 processHead 方法中直接设置属性**：
   - 计算后端路径：`requestUrl.substring(prefixLen)`
   - 直接调用 setter 方法设置 `domain`、`port`、`path`
   - 直接替换 `Host` header
   - 清空并释放 `headBuffer`（因为修改了 path，原有 buffer 不能使用）

3. **避免调用 setUrl 方法**：
   - 不再调用 `head.setUrl(backendUrl)`，避免内部的 `HttpUrl.parse()` 解析开销

# 实施步骤

## 步骤1：在构造函数中新增 backendHostHeader 字段

在 `ProxyHttpHandler2` 类中添加字段：
```java
private final String backendHostHeader;
```

在构造函数中初始化该字段（第42行后添加）：
```java
// 构造 Host header
this.backendHostHeader = (backendPort == 80 || backendPort == 443) ? backendHost : (backendHost + ":" + backendPort);
```

## 步骤2：重构 processHead 方法中的 URL 设置逻辑

将第85-96行的代码：
```java
private void processHead(HttpRequestPartHead head, Pipeline pipeline)
{
    log.debug("[ProxyHttpHandler2] processHead() 开始处理请求头, method={}, path={}, isLast={}", head.getMethod(), head.getPath(), head.isLast());
    // 计算后端 URL
    String requestUrl = head.getPath();
    int    index      = requestUrl.indexOf("#");
    if (index != -1)
    {
        requestUrl = requestUrl.substring(0, index);
    }
    String backendUrl = proxy + requestUrl.substring(prefixLen);
    head.setUrl(backendUrl);
```

替换为：
```java
private void processHead(HttpRequestPartHead head, Pipeline pipeline)
{
    log.debug("[ProxyHttpHandler2] processHead() 开始处理请求头, method={}, path={}, isLast={}", head.getMethod(), head.getPath(), head.isLast());
    // 计算后端路径
    String requestUrl = head.getPath();
    int    index      = requestUrl.indexOf("#");
    if (index != -1)
    {
        requestUrl = requestUrl.substring(0, index);
    }
    String backendPath = requestUrl.substring(prefixLen);

    // 直接设置属性，避免重复解析
    head.setPath(backendPath);
    head.setDomain(backendHost);
    head.setPort(backendPort);

    // 替换 Host header
    String matchedKey = null;
    for (String key : head.getHeaders().keySet())
    {
        if (key.equalsIgnoreCase("Host"))
        {
            matchedKey = key;
            break;
        }
    }
    if (matchedKey != null)
    {
        head.getHeaders().remove(matchedKey);
    }
    head.getHeaders().put("Host", backendHostHeader);

    // 清空并释放 headBuffer，让编码器重新构建请求头
    IoBuffer old = head.getHeadBuffer();
    head.setHeadBuffer(null);
    if (old != null)
    {
        old.free();
    }
```

## 步骤3：添加必要的 import

在文件顶部添加：
```java
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
```

# 待办列表

1. 在 ProxyHttpHandler2 类中添加 backendHostHeader 字段
2. 在构造函数中初始化 backendHostHeader
3. 重构 processHead 方法，用直接属性设置替换 setUrl 调用
4. 添加 IoBuffer 的 import 语句

# 需要修改或新增的类

- **修改**：`cc.jfire.jnet.extend.reverse.proxy.api.handler.ProxyHttpHandler2`