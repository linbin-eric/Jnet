# 目标

1. 创建HttpConnection2，用来实现对客户端请求 Http 的包装。

## 核心思路

1. 采用 HttpResponsePartDecoder 作为响应的解析器。
2. HttpConnection2 中需要有 write 方法，该方法的入参是HttpSendRequest和超时参数，响应是HttpResponse。该响应包含了完整的头部和 body，其中 body 只包含有效内容，也就是说，如果响应采用了 chunked 编码，则 body 的内容是各个 chunk 的 body 部分组合在一起。
3. HttpConnection2创建一个 ResponseFuture 对象作为属性，在 write 方法的内部，首先是创建 ResponseFuture 对象，赋值给该属性。该属性采用volatile修饰。
4. ResponseFuture 是一个接口，有聚合（Aggregator）与流式 （Streamable）两种实现。ResponseFuture 有2个方法是 
   1. onReceive（HttpResponsePart），是 IO 线程来调用，用于将获取到的 http 响应传入。
   2. onFail（throwable），是 IO 线程调用，用于通道出现读取异常的时候，将异常传入。
5. 为了统一资源释放职责，`HttpResponsePart` 接口提供 `free()` 方法：
   1. 对于持有 `IoBuffer` 的响应片段（包含 `HttpResponsePartHead`），其 `free()` 需要释放内部 `IoBuffer`。
   2. 对于不持有资源的响应片段（如 `HttpResponsePartEnd`），`free()` 为 no-op。

6. HttpConnection2 的 write 方法有两个版本，一个是带超时参数，返回 HttpResponse；一个不带超时参数，返回 StreamableResponseFuture。
   1. 带超时参数版本，创建AggregatorResponseFuture 对象，赋值给ResponseFuture 属性。在这个对象上调用方法 waitForEnd，执行超时等待。
   2. 不带超时参数的版本，创建StreamableResponseFuture 对象。赋值给ResponseFuture 属性。

7. AggregatorResponseFuture 对象应当包含如下的属性：
   1. status，包含 3 个比特位，初始值为 0b000，含义是 nonError_nonTimeout_nonEnd，也就是非错误、非超时、非读取结束。对于 onReceive 方法，当收到对象是 HttpResponseEnd 的时候，可以采用 CAS 方式，从‘非错误非超时非读取结束’更新到‘非错误非超时读取结束’。如果更新成功，则可以唤醒在这个对象上的等待线程。如果当前状态是‘非错误已超时非读取结束’，则更新到‘非错误已超时读取结束’，并且对获取到的HttpResponsePart 对象，执行释放动作。对于 onFail 方法，首先是将异常对象，设置到当前对象的 error 属性。然后如果当前状态是‘非错误非读取超时非完成’，则更新到‘错误非读取超时非完成’。更新成功，则唤醒该对象上的等待线程，并且对获取到的 HttpResponsePart 对象执行释放动作；如果当前线程是‘非错误读取超时非完成’，则更新到‘错误读取超时非完成’，并且对获取到的HttpResponsePart 对象，执行释放动作。
   2. error，Throwable 类型
   3. httpResponse,HttpResponse 类型（这是一个新的类）。对于 onReceive 方法，如果收到HttpResponseEnd，则首先将收到的内容组装为 HttpResponse 对象，然后执行状态更新。如果状态更新成功，唤醒等待线程。等待线程将读取该对象，并且作为write 方法的返回值。

8. StreamableResponseFuture 对象应当包含如下属性：
   1. httpResponsePartConsumer，Consumer 类型，用于消费 HttpResponsePart，当 onReceive 方法被调用的时候就调用这个。
   2. errorConsumer，用于消费 Throwable，当 onFail 方法被调用的时候就调用这个。

9. HttpConnection2 的 write 方法调用的时候对ResponseFuture 属性进行赋值；当通道收到 HttpResponseEnd 的时候或者执行 readFail 的时候，将该属性清空。
10. 对于 HttpConnection2 的 write 方法，带超时版本的，业务线程首先创建AggregatorResponseFuture 对象，设置给ResponseFuture 属性，并且在AggregatorResponseFuture 对象上执行超时等待，也就是 waitForEnd 方法。如果线程被唤醒后，超过了超时时间，检查状态。
   1. 如果状态是'非错误非超时非结束'，则CAS 更新到'非错误超时非结束'，更新成功，则抛出超时异常。
   2. 如果状态是'非错误非超时结束'，则返回 httpResponse 属性。
   3. 如果状态是'错误非超时非结束'或'错误非超时已结束'，则抛出 error 异常。

## 详细实现思路

### 1. 整体架构

HttpConnection2 是一个独立于现有 HttpConnection 的新实现，用于客户端 HTTP 请求的封装。核心设计采用 `ResponseFuture` 接口抽象响应处理，支持两种模式：
- **聚合模式（Aggregator）**：等待完整响应后返回，适用于需要完整响应体的场景
- **流式模式（Streamable）**：实时消费响应片段，适用于大文件下载或流式处理场景

### 2. 类职责划分

| 类名 | 职责 |
|------|------|
| HttpConnection2 | 管理连接，提供 write 方法发送请求并获取响应 |
| ResponseFuture | 接口，定义 onReceive 和 onFail 方法，由 IO 线程调用 |
| AggregatorResponseFuture | ResponseFuture 的聚合实现，收集完整响应后唤醒等待线程 |
| StreamableResponseFuture | ResponseFuture 的流式实现，实时将响应片段传递给消费者 |
| HttpResponse | 完整的 HTTP 响应对象，包含头部和聚合后的 body |

### 3. 状态机设计（AggregatorResponseFuture）

使用 3 个比特位表示状态：
- bit0: 是否结束（0=未结束，1=已结束）
- bit1: 是否超时（0=未超时，1=已超时）
- bit2: 是否错误（0=无错误，1=有错误）

**重要说明**：
- `onReceive` 和 `onFail` 由 IO 线程调用，且互斥：error 发生后通道关闭，不会再有 `onReceive` 调用
- 因此在 `onReceive` 中只需检查 timeout 状态，不需要检查 error 状态
- `end` 状态只代表一次 HTTP 响应结束，通道可能还会继续复用

实际使用的状态值：
```
0b000 (0): 非错误_非超时_非结束 (初始状态)
0b001 (1): 非错误_非超时_已结束 (正常完成)
0b010 (2): 非错误_已超时_非结束 (超时但未结束，业务线程设置)
0b011 (3): 非错误_已超时_已结束 (超时后IO线程收到End)
0b100 (4): 错误_非超时_非结束 (发生错误，IO线程设置)
0b110 (6): 错误_已超时_非结束 (已超时后发生错误)
```

状态转换图：
```
                    业务线程超时
    0b000 ─────────────────────────> 0b010
      │                                │
      │ IO线程收到End                  │ IO线程收到End
      ▼                                ▼
    0b001                            0b011

      │ IO线程onFail                   │ IO线程onFail
      ▼                                ▼
    0b100                            0b110
```

### 4. 线程交互模型

```
业务线程                              IO 线程
   |                                    |
   |-- 创建 ResponseFuture ------------->|
   |-- 设置到 HttpConnection2 属性 ----->|
   |-- 发送请求 (fireWrite) ------------>|
   |-- 在 ResponseFuture 上等待 -------->|
   |                                    |
   |                     <-- 收到 HttpResponsePart
   |                     <-- 调用 onReceive
   |                     <-- (收到 HttpResponsePartEnd 时)
   |                     <-- CAS 更新状态
   |<-- 唤醒 ----------------------------|
   |                                    |
   |-- 检查状态，返回结果或抛异常        |
```

### 5. 响应数据处理流程

#### 5.1 聚合模式
1. IO 线程收到 `HttpResponsePartHead`，保存头部信息；该对象同时携带“本段头部原始字节”的 `IoBuffer`
2. IO 线程收到 `HttpResponseFixLengthBodyPart` 或 `HttpResponseChunkedBodyPart`，累加 body 数据
3. IO 线程收到 `HttpResponsePartEnd`，组装 `HttpResponse` 对象，CAS 更新状态，唤醒业务线程
4. 业务线程被唤醒后返回 `HttpResponse`

#### 5.2 流式模式
1. IO 线程收到任何 `HttpResponsePart`，立即调用 `httpResponsePartConsumer.accept(part)`
2. 调用者负责处理并调用 `part.free()` 释放资源（若该 part 持有 `IoBuffer`）

### 6. 资源释放策略

- **正常完成**：业务线程获取 `HttpResponse` 后负责释放（如果需要）
- **超时场景**：IO 线程在状态已超时时收到响应，必须调用 `part.free()` 释放 `HttpResponsePart` 内持有的 `IoBuffer`
- **错误场景**：IO 线程在 `onFail` 时需要释放已收集的 `HttpResponsePart`（统一通过 `free()`）

### 7. Pipeline 配置

HttpConnection2 的 Pipeline 配置：
```
Read 方向: HttpResponsePartDecoder -> ResponsePartHandler (调用 ResponseFuture.onReceive)
Write 方向: HttpSendRequestEncoder -> HeartBeat
```

## 实施步骤

### 步骤 0：扩展 HttpResponsePart 的资源释放能力，并让 Head 携带原始字节

目标：让所有 `HttpResponsePart` 都具备统一的资源释放入口（`free()`），并在 `HttpResponsePartHead` 中加入代表该头部数据的 `IoBuffer`，用于在超时/丢弃/流式消费后正确释放底层缓冲。

#### 0.1 修改 HttpResponsePart 接口

在 `cc.jfire.jnet.extend.http.dto` 包下修改 `HttpResponsePart.java`：

```java
package cc.jfire.jnet.extend.http.dto;

public interface HttpResponsePart
{
    /**
     * 释放该 part 持有的资源（如 IoBuffer）；无资源则为 no-op。
     */
    default void free() { }
}
```

#### 0.2 修改 HttpResponsePartHead：增加 IoBuffer，并实现 free()

在 `cc.jfire.jnet.extend.http.dto` 包下修改 `HttpResponsePartHead.java`：

```java
package cc.jfire.jnet.extend.http.dto;

import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import lombok.Data;

import java.util.HashMap;
import java.util.Map;

@Data
public class HttpResponsePartHead implements HttpResponsePart
{
    protected String              version;
    protected int                 statusCode;
    protected String              reasonPhrase;
    protected Map<String, String> headers       = new HashMap<>();
    protected int                 contentLength = 0;
    protected boolean             chunked       = false;

    /**
     * 代表该头部片段（响应行 + headers + CRLFCRLF）的原始字节；用于在被丢弃/超时/流式消费后释放。
     */
    protected IoBuffer            part;

    public void addHeader(String name, String value)
    {
        headers.put(name, value);
    }

    @Override
    public void free()
    {
        if (part != null)
        {
            part.free();
            part = null;
        }
    }
}
```

#### 0.3 修改 BodyPart：实现 free()

在 `cc.jfire.jnet.extend.http.dto` 包下修改以下类，让其 `free()` 释放内部 `IoBuffer`：
- `HttpResponseFixLengthBodyPart`
- `HttpResponseChunkedBodyPart`

说明：`HttpResponsePartEnd` 不持有 `IoBuffer`，不需要改动。

#### 0.4 修改 HttpResponsePartDecoder：为 Head 填充 part(IoBuffer)

在 `cc.jfire.jnet.extend.http.coder` 包下修改 `HttpResponsePartDecoder.java`：
- 在解析一条响应开始时记录 head 的起始读取位置（response line 的起点）。
- 在解析到 `\\r\\n\\r\\n` 时，基于“head 起点”到“headers 结束”的范围 `slice` 出一个 `IoBuffer`，赋值给 `respHead.part`，然后再继续解析并产出 `respHead`。

这样在聚合模式超时丢弃/流式模式消费者处理完毕后，只需调用 `part.free()` 即可释放 head 对应的缓冲区。

### 步骤 1：创建 ResponseFuture 接口

在 `cc.jfire.jnet.extend.http.client` 包下创建 `ResponseFuture.java`：

```java
package cc.jfire.jnet.extend.http.client;

import cc.jfire.jnet.extend.http.dto.HttpResponsePart;

public interface ResponseFuture
{
    /**
     * IO 线程调用，传入收到的 HTTP 响应片段
     */
    void onReceive(HttpResponsePart part);

    /**
     * IO 线程调用，传入通道读取异常
     */
    void onFail(Throwable error);
}
```

### 步骤 2：创建 HttpResponse 类

在 `cc.jfire.jnet.extend.http.client` 包下创建 `HttpResponse.java`：

```java
package cc.jfire.jnet.extend.http.client;

import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import lombok.Data;

import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;

@Data
public class HttpResponse
{
    private String              version;
    private int                 statusCode;
    private String              reasonPhrase;
    private Map<String, String> headers = new HashMap<>();
    private IoBuffer            body;

    public void addHeader(String name, String value)
    {
        headers.put(name, value);
    }

    public String getBodyAsString()
    {
        if (body == null || body.remainRead() == 0)
        {
            return "";
        }
        return StandardCharsets.UTF_8.decode(body.readableByteBuffer()).toString();
    }

    public void free()
    {
        if (body != null)
        {
            body.free();
            body = null;
        }
    }
}
```

### 步骤 3：创建 AggregatorResponseFuture 类

在 `cc.jfire.jnet.extend.http.client` 包下创建 `AggregatorResponseFuture.java`：

```java
package cc.jfire.jnet.extend.http.client;

import cc.jfire.jnet.common.buffer.allocator.BufferAllocator;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.jnet.common.util.UNSAFE;
import cc.jfire.jnet.extend.http.dto.*;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.LockSupport;

/**
 * 聚合模式的 ResponseFuture 实现。
 *
 * 状态机说明：
 * - onReceive 和 onFail 由 IO 线程调用，且互斥（error 后通道关闭，不会再有 onReceive）
 * - waitForEnd 由业务线程调用
 * - 超时由业务线程设置，IO 线程在收到数据时检查超时状态
 */
public class AggregatorResponseFuture implements ResponseFuture
{
    // 状态常量：bit0=结束, bit1=超时, bit2=错误
    private static final int  NO_ERROR_NO_TIMEOUT_NO_END  = 0b000; // 初始状态
    private static final int  NO_ERROR_NO_TIMEOUT_END     = 0b001; // 正常完成
    private static final int  NO_ERROR_TIMEOUT_NO_END     = 0b010; // 超时但未结束
    private static final int  NO_ERROR_TIMEOUT_END        = 0b011; // 超时后结束
    private static final int  ERROR_NO_TIMEOUT_NO_END     = 0b100; // 错误未超时未结束
    private static final int  ERROR_TIMEOUT_NO_END        = 0b110; // 错误且超时未结束
    private static final long STATUS_OFFSET               = UNSAFE.getFieldOffset("status", AggregatorResponseFuture.class);

    private volatile int           status = NO_ERROR_NO_TIMEOUT_NO_END;
    private volatile Throwable     error;
    private volatile HttpResponse  httpResponse;
    private volatile Thread        waitingThread;
    private final    BufferAllocator allocator;

    // 临时存储，用于收集响应数据
    private HttpResponsePartHead headPart;
    private IoBuffer             bodyBuffer;

    public AggregatorResponseFuture(BufferAllocator allocator)
    {
        this.allocator = allocator;
    }

    /**
     * 检查当前状态是否已超时（bit1 为 1）
     */
    private boolean isTimeout(int status)
    {
        return (status & 0b010) != 0;
    }

    /**
     * 检查当前状态是否已出错（bit2 为 1）
     */
    private boolean isError(int status)
    {
        return (status & 0b100) != 0;
    }

    @Override
    public void onReceive(HttpResponsePart part)
    {
        // 注意：onReceive 和 onFail 互斥，error 发生后通道关闭，不会再调用 onReceive
        // 因此这里只需要检查 timeout 状态

        if (part instanceof HttpResponsePartHead head)
        {
            // 检查是否已超时
            if (isTimeout(status))
            {
                head.free();
                return;
            }
            this.headPart = head;
            // 聚合模式不需要保留 head 的原始字节，及时释放
            head.free();
            // 根据 contentLength 预分配 body buffer
            int contentLength = head.getContentLength();
            if (contentLength > 0)
            {
                bodyBuffer = allocator.allocate(contentLength);
            }
            else if (head.isChunked())
            {
                bodyBuffer = allocator.allocate(1024);
            }
        }
        else if (part instanceof HttpResponseFixLengthBodyPart fixPart)
        {
            // 检查是否已超时，如果是则释放资源
            if (isTimeout(status))
            {
                fixPart.free();
                return;
            }
            handleBodyPart(fixPart.getPart(), true);
        }
        else if (part instanceof HttpResponseChunkedBodyPart chunkedPart)
        {
            IoBuffer partBuffer = chunkedPart.getPart();
            // 检查是否已超时，如果是则释放资源
            if (isTimeout(status))
            {
                chunkedPart.free();
                return;
            }
            // 提取有效内容（跳过 chunk 头部和尾部 CRLF）
            int headLength = chunkedPart.getHeadLength();
            int chunkLength = chunkedPart.getChunkLength();
            int effectiveLength = chunkLength - headLength - 2; // 减去头部和尾部 CRLF

            if (effectiveLength > 0)
            {
                int oldReadPosi = partBuffer.getReadPosi();
                partBuffer.addReadPosi(headLength);
                if (bodyBuffer == null)
                {
                    bodyBuffer = allocator.allocate(effectiveLength);
                }
                bodyBuffer.put(partBuffer, effectiveLength);
                partBuffer.setReadPosi(oldReadPosi);
            }
            chunkedPart.free();
        }
        else if (part instanceof HttpResponsePartEnd)
        {
            // CAS 更新状态
            while (true)
            {
                int currentStatus = status;
                if (currentStatus == NO_ERROR_NO_TIMEOUT_NO_END)
                {
                    // 正常情况：组装 HttpResponse 并唤醒等待线程
                    HttpResponse response = assembleResponse();
                    this.httpResponse = response;
                    if (UNSAFE.compareAndSwapInt(this, STATUS_OFFSET, NO_ERROR_NO_TIMEOUT_NO_END, NO_ERROR_NO_TIMEOUT_END))
                    {
                        wakeUpWaitingThread();
                        break;
                    }
                }
                else if (currentStatus == NO_ERROR_TIMEOUT_NO_END)
                {
                    // 已超时：释放资源，更新状态
                    if (UNSAFE.compareAndSwapInt(this, STATUS_OFFSET, NO_ERROR_TIMEOUT_NO_END, NO_ERROR_TIMEOUT_END))
                    {
                        releaseBodyBuffer();
                        break;
                    }
                }
                else
                {
                    // 其他状态（不应该发生，因为 onReceive 不会在 error 后被调用）
                    break;
                }
            }
        }
    }

    /**
     * 组装 HttpResponse 对象
     */
    private HttpResponse assembleResponse()
    {
        HttpResponse response = new HttpResponse();
        if (headPart != null)
        {
            response.setVersion(headPart.getVersion());
            response.setStatusCode(headPart.getStatusCode());
            response.setReasonPhrase(headPart.getReasonPhrase());
            response.setHeaders(headPart.getHeaders());
        }
        response.setBody(bodyBuffer);
        bodyBuffer = null; // 转移所有权，避免重复释放
        return response;
    }

    private void handleBodyPart(IoBuffer partBuffer, boolean needFree)
    {
        if (bodyBuffer == null)
        {
            bodyBuffer = allocator.allocate(partBuffer.remainRead());
        }
        bodyBuffer.put(partBuffer);
        if (needFree)
        {
            partBuffer.free();
        }
    }

    @Override
    public void onFail(Throwable error)
    {
        this.error = error;
        while (true)
        {
            int currentStatus = status;
            if (currentStatus == NO_ERROR_NO_TIMEOUT_NO_END)
            {
                // 未超时未结束 -> 错误未超时未结束
                if (UNSAFE.compareAndSwapInt(this, STATUS_OFFSET, NO_ERROR_NO_TIMEOUT_NO_END, ERROR_NO_TIMEOUT_NO_END))
                {
                    releaseBodyBuffer();
                    wakeUpWaitingThread();
                    break;
                }
            }
            else if (currentStatus == NO_ERROR_TIMEOUT_NO_END)
            {
                // 已超时未结束 -> 错误已超时未结束（保留超时位）
                if (UNSAFE.compareAndSwapInt(this, STATUS_OFFSET, NO_ERROR_TIMEOUT_NO_END, ERROR_TIMEOUT_NO_END))
                {
                    releaseBodyBuffer();
                    break;
                }
            }
            else
            {
                // 其他状态（已结束），不做处理
                break;
            }
        }
    }

    /**
     * 释放 bodyBuffer 资源
     */
    private void releaseBodyBuffer()
    {
        if (bodyBuffer != null)
        {
            bodyBuffer.free();
            bodyBuffer = null;
        }
    }

    private void wakeUpWaitingThread()
    {
        Thread thread = waitingThread;
        if (thread != null)
        {
            waitingThread = null;
            LockSupport.unpark(thread);
        }
    }

    public HttpResponse waitForEnd(long timeoutSeconds) throws Exception
    {
        waitingThread = Thread.currentThread();
        long timeoutNanos = TimeUnit.SECONDS.toNanos(timeoutSeconds);
        long startTime = System.nanoTime();

        while (status == NO_ERROR_NO_TIMEOUT_NO_END)
        {
            long elapsed = System.nanoTime() - startTime;
            long remaining = timeoutNanos - elapsed;
            if (remaining <= 0)
            {
                break;
            }
            LockSupport.parkNanos(remaining);
            if (Thread.interrupted())
            {
                throw new InterruptedException("等待响应被中断");
            }
        }

        waitingThread = null;

        // 检查状态
        int currentStatus = status;
        if (currentStatus == NO_ERROR_NO_TIMEOUT_NO_END)
        {
            // 超时：CAS 更新状态
            if (UNSAFE.compareAndSwapInt(this, STATUS_OFFSET, NO_ERROR_NO_TIMEOUT_NO_END, NO_ERROR_TIMEOUT_NO_END))
            {
                throw new java.net.SocketTimeoutException("等待 HTTP 响应超时");
            }
            // CAS 失败，重新检查状态
            currentStatus = status;
        }

        if (currentStatus == NO_ERROR_NO_TIMEOUT_END)
        {
            return httpResponse;
        }
        else if (isError(currentStatus))
        {
            // 错误状态
            throw new RuntimeException("HTTP 响应接收失败", error);
        }
        else
        {
            // 超时状态
            throw new java.net.SocketTimeoutException("等待 HTTP 响应超时");
        }
    }
}
```

### 步骤 4：创建 StreamableResponseFuture 类

在 `cc.jfire.jnet.extend.http.client` 包下创建 `StreamableResponseFuture.java`：

```java
package cc.jfire.jnet.extend.http.client;

import cc.jfire.jnet.extend.http.dto.HttpResponsePart;

import java.util.function.Consumer;

public class StreamableResponseFuture implements ResponseFuture
{
    private final Consumer<HttpResponsePart> httpResponsePartConsumer;
    private final Consumer<Throwable>        errorConsumer;

    public StreamableResponseFuture(Consumer<HttpResponsePart> httpResponsePartConsumer,
                                    Consumer<Throwable> errorConsumer)
    {
        this.httpResponsePartConsumer = httpResponsePartConsumer;
        this.errorConsumer = errorConsumer;
    }

    @Override
    public void onReceive(HttpResponsePart part)
    {
        if (httpResponsePartConsumer != null)
        {
            httpResponsePartConsumer.accept(part);
        }
    }

    @Override
    public void onFail(Throwable error)
    {
        if (errorConsumer != null)
        {
            errorConsumer.accept(error);
        }
    }
}
```

### 步骤 5：创建 HttpConnection2 类

在 `cc.jfire.jnet.extend.http.client` 包下创建 `HttpConnection2.java`：

说明：本步骤接入并复用现有的 `HttpSendRequest` / `HttpSendRequestEncoder` 等类；`HttpResponsePartDecoder` 与 `HttpResponsePart` 系列的改动见“步骤 0”。

```java
package cc.jfire.jnet.extend.http.client;

import cc.jfire.jnet.client.ClientChannel;
import cc.jfire.jnet.common.api.Pipeline;
import cc.jfire.jnet.common.api.ReadProcessor;
import cc.jfire.jnet.common.api.ReadProcessorNode;
import cc.jfire.jnet.common.coder.HeartBeat;
import cc.jfire.jnet.common.util.ChannelConfig;
import cc.jfire.jnet.common.util.ReflectUtil;
import cc.jfire.jnet.extend.http.coder.HttpResponsePartDecoder;
import cc.jfire.jnet.extend.http.dto.HttpResponsePart;
import cc.jfire.jnet.extend.http.dto.HttpResponsePartEnd;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.net.SocketTimeoutException;
import java.nio.channels.ClosedChannelException;
import java.util.function.Consumer;

@Slf4j
public class HttpConnection2
{
    @Getter
    private final    ClientChannel  clientChannel;
    private volatile ResponseFuture responseFuture;

    public HttpConnection2(String domain, int port, int secondsOfKeepAlive)
    {
        ChannelConfig channelConfig = new ChannelConfig().setIp(domain).setPort(port);
        clientChannel = ClientChannel.newClient(channelConfig, pipeline -> {
            pipeline.addReadProcessor(new HeartBeat(secondsOfKeepAlive, pipeline));
            pipeline.addReadProcessor(new HttpResponsePartDecoder());
            pipeline.addReadProcessor(new ReadProcessor<HttpResponsePart>()
            {
                @Override
                public void read(HttpResponsePart part, ReadProcessorNode next)
                {
                    ResponseFuture future = responseFuture;
                    if (future != null)
                    {
                        future.onReceive(part);
                        if (part instanceof HttpResponsePartEnd)
                        {
                            responseFuture = null;
                        }
                    }
                }

                @Override
                public void readFailed(Throwable e, ReadProcessorNode next)
                {
                    ResponseFuture future = responseFuture;
                    if (future != null)
                    {
                        future.onFail(e);
                        responseFuture = null;
                    }
                }
            });
            pipeline.addWriteProcessor(new HttpSendRequestEncoder());
            pipeline.addWriteProcessor(new HeartBeat(secondsOfKeepAlive, pipeline));
        });
        if (!clientChannel.connect())
        {
            ReflectUtil.throwException(new RuntimeException("无法连接 " + domain + ":" + port, clientChannel.getConnectionException()));
        }
    }

    public boolean isConnectionClosed()
    {
        return !clientChannel.alive();
    }

    /**
     * 带超时的 write 方法，返回完整的 HttpResponse
     */
    public HttpResponse write(HttpSendRequest request, int secondsOfTimeout) throws ClosedChannelException, SocketTimeoutException
    {
        if (isConnectionClosed())
        {
            log.error("连接已关闭，地址：{}", clientChannel.pipeline().getRemoteAddressWithoutException());
            request.close();
            throw new ClosedChannelException();
        }

        AggregatorResponseFuture aggregator = new AggregatorResponseFuture(clientChannel.pipeline().allocator());
        this.responseFuture = aggregator;

        // 发送请求
        clientChannel.pipeline().fireWrite(request);

        try
        {
            return aggregator.waitForEnd(secondsOfTimeout);
        }
        catch (SocketTimeoutException e)
        {
            clientChannel.pipeline().shutdownInput();
            throw e;
        }
        catch (Exception e)
        {
            clientChannel.pipeline().shutdownInput();
            if (e instanceof ClosedChannelException)
            {
                throw (ClosedChannelException) e;
            }
            ReflectUtil.throwException(e);
            return null; // 不会执行到这里
        }
    }

    /**
     * 流式 write 方法，返回 StreamableResponseFuture
     */
    public StreamableResponseFuture write(HttpSendRequest request,
                                          Consumer<HttpResponsePart> partConsumer,
                                          Consumer<Throwable> errorConsumer) throws ClosedChannelException
    {
        if (isConnectionClosed())
        {
            log.error("连接已关闭，地址：{}", clientChannel.pipeline().getRemoteAddressWithoutException());
            request.close();
            throw new ClosedChannelException();
        }

        StreamableResponseFuture streamable = new StreamableResponseFuture(partConsumer, errorConsumer);
        this.responseFuture = streamable;

        // 发送请求
        clientChannel.pipeline().fireWrite(request);

        return streamable;
    }

    public void close()
    {
        clientChannel.pipeline().shutdownInput();
    }
}
```

## 待办列表

1. [ ] 扩展 HttpResponsePart/Head 的 free 与 IoBuffer
2. [ ] 创建 ResponseFuture 接口
3. [ ] 创建 HttpResponse 类
4. [ ] 创建 AggregatorResponseFuture 类
5. [ ] 创建 StreamableResponseFuture 类
6. [ ] 创建 HttpConnection2 类

## 需要修改或新增的类

### 修改的现有类

| 类名 | 包路径 | 说明 |
|------|--------|------|
| HttpResponsePart | cc.jfire.jnet.extend.http.dto | 接口新增 `free()` 作为统一释放入口 |
| HttpResponsePartHead | cc.jfire.jnet.extend.http.dto | 增加 `IoBuffer part` 表示头部原始字节，并实现 `free()` |
| HttpResponseFixLengthBodyPart | cc.jfire.jnet.extend.http.dto | 实现 `free()` 释放内部 `IoBuffer` |
| HttpResponseChunkedBodyPart | cc.jfire.jnet.extend.http.dto | 实现 `free()` 释放内部 `IoBuffer` |
| HttpResponsePartDecoder | cc.jfire.jnet.extend.http.coder | 解析 head 时填充 `HttpResponsePartHead.part` |

### 新增的类

| 类名 | 包路径 | 说明 |
|------|--------|------|
| ResponseFuture | cc.jfire.jnet.extend.http.client | 接口，定义响应处理的抽象 |
| HttpResponse | cc.jfire.jnet.extend.http.client | 完整 HTTP 响应对象 |
| AggregatorResponseFuture | cc.jfire.jnet.extend.http.client | 聚合模式的 ResponseFuture 实现 |
| StreamableResponseFuture | cc.jfire.jnet.extend.http.client | 流式模式的 ResponseFuture 实现 |
| HttpConnection2 | cc.jfire.jnet.extend.http.client | 新的 HTTP 连接封装类 |

### 复用的现有类

说明：以下类在本方案中“涉及但不修改”，仅作为 HttpConnection2 的 Pipeline 组件、请求入参、响应片段数据结构或底层能力被引用/调用。

| 类名 | 用途 |
|------|------|
| HttpSendRequest | 作为请求入参 |
| HttpSendRequestEncoder | 请求编码器 |
| IoBuffer | 缓冲区操作 |
| UNSAFE | CAS 操作支持 |
| ClientChannel | 底层通道管理 |
