# 目标

1. 修改 TransferProcessor 的实现，让他要能处理 HttpRequestPart 的请求。将原来处理完整 HttpRequest 的方式改为处理流式的 HttpRequestPart，支持分部分接收和转发 HTTP 请求。

# 核心思路

1. TransferProcessor 应该增加一个属性，用来保存当前被激活的 handler。该属性默认为 null，当首次处理 HttpRequestPartHead 请求的时候，根据匹配到的 handler，对该属性进行赋值。而当处理到 HttpRequestPartEnd 的时候，清除该属性。
2. ResourceHandler 接口应该加一个 match 方法，用来判断是否吻合当前这个 httpRequestpartHead。应该修改 process 接口，入参修改为 HttpRequestPart。
3. PrefixMatchProxyHttpHandler 和FullMatchProxyHttpHandler 的 process 要重新实现，要求如下：
   1. 当处理 HttpRequestPartHead 的时候，计算正确的后端 url，并通过 `HttpRequestPartHead#setUrl(String url)` 更新 path/Host/domain/port（内部复用统一的 URL 解析逻辑 `HttpUrl.parse`，并负责释放/清空 headBuffer，避免旧头部被直接写出），再交由 ProxyHttpHandler 发往后端。
   2. 当处理 HttpRequestPartBody 的时候，不需要处理，直接传递。
4. ProxyHttpHandler 类需要重构为 `processHead`/`processBody`/`processEnd` 三个方法，并新增 `computeBackendUrl` 抽象方法供子类实现：
   1. 新增 `HttpConnection2Pool pool` 构造函数参数和成员变量。
   2. 新增 `AtomicReference<BackendConn> backendConnRef` 属性，存储当前使用的后端连接上下文（host/port/conn）。在 `processHead` 中从连接池申请连接，申请成功则 `backendConnRef.set(...)`；清理/归还时通过 `backendConnRef.getAndSet(null)` 保证只处理一次。
   3. 在 `processBody` 中，如果 `backendConnRef.get()` 为 null 则直接释放 body；否则通过 `backendConnRef.get().conn().write(body)` 写出。
   4. 在 `processEnd` 中，如果 `backendConnRef.get()` 为 null 则发送"连接过多"响应（若属于后端 End 早到场景则只清理标记不响应）；如果有值则不在此处归还连接（连接归还必须等到后端响应结束）。
   5. 如果收到 `HttpRequestPartHead` 时 `backendConnRef.get() != null`（说明上一个后端响应未结束，不支持 HTTP pipelining），则关闭客户端连接并丢弃该次请求的所有 part（禁止把新请求的 body 写入旧后端连接）。
   6. 使用 `HttpConnection2.write(HttpRequestPartHead, Consumer<HttpResponsePart>, Consumer<Throwable>)` 方法发送请求头，在 `partConsumer` 中透传响应给客户端。
   7. 当客户端断开或读取失败（`readFailed`）时，如果 `backendConnRef.get() != null`，则将该后端连接视为**不可复用**：直接关闭连接并释放连接池许可（不入池复用），随后清空 `backendConnRef` 等状态。
   8. 当后端 `HttpResponsePartEnd` 早于客户端 `HttpRequestPartEnd`（后端提前结束响应）时，同样将该连接视为**不可复用**：关闭连接并释放连接池许可，并清空 `backendConnRef`；同时标记本次请求后续 part 仅做资源释放直到收到 `HttpRequestPartEnd`（避免连接被复用导致后端协议状态错位）。
   9. 并发与线程可见性：`HttpConnection2.write(...)` 的 `partConsumer/errorConsumer` 回调运行在后端连接的 IO 线程（非当前请求线程），`ProxyHttpHandler` 中的后端连接状态会被“前端请求线程 + 后端响应线程”并发读写；不建议仅用 `volatile` 修饰 `httpConnection2`。建议将 `(host, port, conn)` 封装为 `BackendConn`，用 `AtomicReference<BackendConn>` 保存，并通过 `getAndSet(null)` 实现“只清理/归还一次”，避免并发路径导致重复归还/重复释放连接池许可；`dropCurrentRequest/requestEndReceived/responseEndedBeforeRequestEnd` 等跨线程标志使用 `volatile` 保证前端线程可见。
5. ReverseProxyServer 需要修改管线配置，移除 `HttpRequestAggregator`，让 `TransferProcessor` 直接接收 `HttpRequestPart`。
6. 响应流式透传 + CORS 注入：
   - `HttpResponsePartHead`：不直接写出 buffer，而是将 `HttpResponsePartHead` 对象透传给后续写出处理器；由 `CorsEncoder` 在对象层面追加 CORS 头，并释放/清空原始 `part`（避免旧字节被写出）；再由 `HttpRespEncoder` 重新编码响应行+headers+CRLF 写出。
   - `HttpResponseFixLengthBodyPart`：写出 `body.getPart()`（IoBuffer）。
   - `HttpResponseChunkedBodyPart`：写出 `body.getPart()`（IoBuffer，包含 chunkSize=0 的结束块）。
   - `HttpResponsePartEnd`：不写出任何内容；在此处归还连接到连接池并清理状态（连接归还时机以“收到后端响应 End”为准）。
7. 后端 URL 的解析层面同时支持 `http` / `https`：
   - `https://` 仅用于解析默认端口（443）与计算转发目标（Host/path 等），当前阶段 `HttpConnection2` **不支持 TLS/SSL**；如果后端真实为 HTTPS（TLS），会在连接/读写阶段失败，并按 502（Bad Gateway）处理。
8. 未匹配路由时必须严格返回 HTTP 404（设置 `FullHttpResp.getHead().setResponseCode(404)`）。

# 详细实现思路

## 1. TransferProcessor 改造

当前 `TransferProcessor` 实现 `ReadProcessor<HttpRequest>`，需要改为 `ReadProcessor<HttpRequestPart>`。

**状态管理机制：**
- 新增 `currentHandler` 属性（类型为 `ResourceHandler`），用于保存当前激活的处理器
- 当收到 `HttpRequestPartHead` 时：
  1. 遍历所有 handlers，调用 `match(head)` 方法找到匹配的 handler
  2. 如果找到匹配的 handler，将其赋值给 `currentHandler`，然后调用 `process(part, pipeline)`
  3. 如果没有找到匹配的 handler，释放资源并返回 **HTTP 404** 响应（注意：必须在 `head.close()` 前先缓存 `path`，否则 `head.close()` 会将 `path` 置空）
- 当收到 `HttpRequestPartBody`（`HttpRequestFixLengthBodyPart` 或 `HttpRequestChunkedBodyPart`）时：
  1. 如果 `currentHandler` 不为 null，调用 `process(part, pipeline)`
  2. 如果 `currentHandler` 为 null，释放资源（异常情况）
- 当收到 `HttpRequestPartEnd` 时：
  1. 如果 `currentHandler` 不为 null，调用 `process(part, pipeline)`，然后清空 `currentHandler`
  2. 如果 `currentHandler` 为 null，释放资源（异常情况）

## 2. ResourceHandler 接口改造

- 新增 `boolean match(HttpRequestPartHead head)` 方法，用于判断是否能处理该请求
- 修改 `process` 方法签名为 `void process(HttpRequestPart part, Pipeline pipeline)`
- 返回值改为 void，因为匹配逻辑已经移到 `match` 方法

## 3. ProxyHttpHandler 改造

**构造函数改造：**
- 新增构造函数参数 `HttpConnection2Pool pool`
- 保存为成员变量 `pool`

**状态管理：**
- 新增 `AtomicReference<BackendConn> backendConnRef` 属性：保存当前后端连接上下文（conn/host/port），并通过 `getAndSet(null)` 保证连接只会被清理/归还一次（避免并发回调导致重复归还/重复释放连接池许可）。
- 新增 `volatile boolean dropCurrentRequest` 属性：当检测到不支持的 pipelining、后端提前结束响应等场景时，标记本次请求需要丢弃（Head/Body/End 都仅释放资源，不写入后端连接）。该标志会被后端响应线程更新，需要 `volatile` 保证前端线程可见。
- 新增 `volatile boolean requestEndReceived` 属性：标记当前请求是否已收到客户端的 `HttpRequestPartEnd`（用于判断后端连接在收到 `HttpResponsePartEnd` 时是否可复用）。
- 新增 `volatile boolean responseEndedBeforeRequestEnd` 属性：标记是否发生“后端 End 早到”（用于后续请求 End 到达时只做清理，避免误发 503）。

**处理逻辑：**

当处理 `HttpRequestPartHead` 时：
1. 如果 `backendConnRef.get() != null`（说明上一个后端响应没有结束，不支持 pipelining），关闭客户端连接并丢弃本次请求（设置 `dropCurrentRequest=true`，直到本次请求的 End）
2. 调用子类 `computeBackendUrl(head)` 计算 backendUrl，并在其中调用 `head.setUrl(backendUrl)`（该方法内部复用统一的 URL 解析逻辑 `HttpUrl.parse`，并设置 path/domain/port/Host，同时释放/清空 headBuffer）
3. 使用 `head.getDomain()` 与 `head.getPort()` 调用 `pool.borrowConnection(host, port)` 获取连接（兜底：若 domain 未被设置，再从 `Host` header 解析）
4. 如果获取成功：
   - 保存 `(host, port, conn)` 到 `backendConnRef`（`AtomicReference<BackendConn>`）
   - 调用 `conn.write(head, partConsumer, errorConsumer)` 发送请求头
   - `partConsumer` 中：
     - 客户端连接已关闭时：关闭后端连接并释放连接池许可（不复用），并丢弃/释放后端响应 part
     - `HttpResponsePartHead`：`pipeline.fireWrite(respHead)`（由后续写出链完成 CORS 注入与编码）
     - `HttpResponseFixLengthBodyPart` / `HttpResponseChunkedBodyPart`：写出 `part.getPart()`（IoBuffer）
     - `HttpResponsePartEnd`：
       - 若 `requestEndReceived == true`（请求已结束）：归还连接并清理状态（连接可复用）
       - 若 `requestEndReceived == false`（请求未结束）：关闭连接并释放连接池许可（连接不可复用），清理状态，并设置 `dropCurrentRequest=true`、`responseEndedBeforeRequestEnd=true`（后续 body 仅释放直到收到请求 End）
    - `errorConsumer` 中：需要关闭并归还连接（释放连接池许可），再尝试向客户端写出 502（若客户端仍然 open）
5. 如果获取失败（超时）：
   - 不设置 `backendConnRef`，后续 body 和 end 会根据此判断

当处理 `HttpRequestPartBody`（`HttpRequestFixLengthBodyPart` 或 `HttpRequestChunkedBodyPart`）时：
1. 如果 `backendConnRef.get()` 为 null，释放 body 资源
2. 如果 `backendConnRef.get()` 有值，调用 `backendConnRef.get().conn().write(body)` 发送请求体

当处理 `HttpRequestPartEnd` 时：
1. 如果 `backendConnRef.get()` 为 null：
   - 若 `responseEndedBeforeRequestEnd == true`：说明后端已提前结束且连接已关闭/不可复用，此处仅清理标记并结束
   - 否则：发送"连接过多"的响应给客户端
2. 如果 `backendConnRef.get()` 有值：不在此处归还连接（归还时机为后端响应结束，即 `HttpResponsePartEnd`）

**异常/边界处理补充：**
- 客户端断开/读取失败（`readFailed`）：若仍持有后端连接（`backendConnRef.get() != null`），则直接关闭该连接并释放连接池许可（不复用），清理状态，避免连接长期占用。
- 后端 End 早到：若收到 `HttpResponsePartEnd` 时 `requestEndReceived == false`，则该连接不可再复用（后端协议状态可能仍在等待请求体/结束块）。处理方式同上：关闭并释放，同时清空 `backendConnRef`，后续请求 body 仅做释放直到收到 `HttpRequestPartEnd`。

## 4. PrefixMatchProxyHttpHandler 和 FullMatchProxyHttpHandler 改造

**match 方法实现：**
- 复用原有 `process` 方法中的匹配逻辑
- 从 `HttpRequestPartHead` 的 `path` 属性获取请求路径进行匹配

**process 方法实现：**
- 当处理 `HttpRequestPartHead` 时：
  1. 根据匹配规则计算后端 URL
  2. 调用 `HttpRequestPartHead#setUrl(backendUrl)` 完成 URL 解析（复用 `HttpUrl.parse`）、path/Host/domain/port 更新，以及 headBuffer 的释放/清空（避免编码器继续写出旧 headBuffer）
  3. 由父类 `ProxyHttpHandler` 负责在 `processHead` 中向后端写出请求头（以及后续 body/end 的转发）
- 当处理其他类型时：
  1. 直接调用父类的处理方法传递 body 或 end

## 5. ProxyHttpResource 和 ResourceConfig 改造

由于 `ProxyHttpHandler` 需要 `HttpConnection2Pool` 参数，需要修改配置解析逻辑：
- `ResourceConfig` 的 `parse()` 方法需要接收 `HttpConnection2Pool` 参数
- `ProxyHttpResource` 的 `parse()` 方法需要传递 `HttpConnection2Pool` 给 handler 构造函数
- `TransferProcessor` 构造函数需要接收 `HttpConnection2Pool` 参数，并传递给 parse 方法

## 6. ReverseProxyServer 管线改造

当前管线配置为：`HttpRequestPartDecoder` -> `HttpRequestAggregator` -> `TransferProcessor`

`HttpRequestAggregator` 会将 `HttpRequestPart` 聚合成完整的 `HttpRequest`，导致 `TransferProcessor` 无法接收流式的 `HttpRequestPart`。

**改造方案：**
- 移除 `HttpRequestAggregator`
- 创建 `HttpConnection2Pool` 实例（可作为 `ReverseProxyServer` 的成员变量）
- 将 `HttpConnection2Pool` 传递给 `TransferProcessor` 构造函数

改造后管线：`HttpRequestPartDecoder` -> `TransferProcessor`

## 7. 关键约束：修改 HttpRequestPartHead 时必须清空 headBuffer

**问题背景：**
`HttpRequestPartEncoder` 在编码 `HttpRequestPartHead` 时，如果 `headBuffer != null`，会直接写出原始的 `headBuffer`，而忽略 `path` 和 `headers` 属性的修改。

`HttpRequestPartDecoder` 在解析请求头时会将原始头部字节保存到 `headBuffer` 中。

**约束：**
在修改 `HttpRequestPartHead` 的 `path` / `headers` 后，**必须清空并释放原 headBuffer**，否则修改不会生效且会造成内存泄漏。本次通过 `HttpRequestPartHead#setUrl(String url)` 统一完成该逻辑（其内部复用 `HttpUrl.parse` 的 URL 解析逻辑）：
- `IoBuffer old = head.getHeadBuffer(); head.setHeadBuffer(null); if (old != null) old.free();`

## 8. chunked 请求/响应的结束块透传

**问题背景：**
当前 `HttpRequestPartDecoder` 和 `HttpResponsePartDecoder` 在解析 chunked 时，遇到 `chunkSize == 0` 只会发出 `*PartEnd`，而不会发出包含 `0\r\n\r\n` 的 body part。

**改造方案：**
修改 `HttpRequestPartDecoder` 和 `HttpResponsePartDecoder`：当 `chunkSize == 0` 时，先构造一个内容长度为 0 的 `*ChunkedBodyPart`（其 `part` 包含 `0\r\n\r\n`），然后再发出 `*PartEnd`。

这样透传时只需写出 `body.getPart()` 即可包含结束标记，`*PartEnd` 保持纯粹的结束标记作用，不需要写出任何内容。

## 9. 响应流式透传方案

在 `ProxyHttpHandler` 的 `partConsumer` 中处理后端响应：

```java
responsePart -> {
    if (!pipeline.isOpen())
    {
        // 客户端连接已关闭：丢弃并释放后端响应 part，直到 End 才归还连接
        responsePart.free();
        return;
    }
    if (responsePart instanceof HttpResponsePartHead head)
    {
        // 透传对象本身，后续由 CorsEncoder 注入 CORS 头，再由 HttpRespEncoder 编码写出
        pipeline.fireWrite(head);
    }
    else if (responsePart instanceof HttpResponseFixLengthBodyPart body)
    {
        pipeline.fireWrite(body.getPart());
    }
    else if (responsePart instanceof HttpResponseChunkedBodyPart body)
    {
        pipeline.fireWrite(body.getPart());
    }
    else if (responsePart instanceof HttpResponsePartEnd)
    {
        // 不写出任何内容，End 仅作为结束标记
        // 在此处触发连接归还等清理逻辑
    }
}
```

由于 `HttpRespEncoder` 已支持 `IoBuffer` 类型，body 的 IoBuffer 可直接 `pipeline.fireWrite(ioBuffer)`。

# 实施步骤

## 步骤 1：修改 ResourceHandler 接口

文件：`cc/jfire/jnet/extend/reverse/proxy/api/ResourceHandler.java`

修改内容：
```java
package cc.jfire.jnet.extend.reverse.proxy.api;

import cc.jfire.jnet.common.api.Pipeline;
import cc.jfire.jnet.extend.http.dto.HttpRequestPart;
import cc.jfire.jnet.extend.http.dto.HttpRequestPartHead;

public interface ResourceHandler
{
    /**
     * 判断是否能处理该请求头
     */
    boolean match(HttpRequestPartHead head);

    /**
     * 处理请求部分
     */
    void process(HttpRequestPart part, Pipeline pipeline);

    default void readFailed(Throwable e) {}
}
```

## 步骤 2：修改 ResourceConfig 接口

文件：`cc/jfire/jnet/extend/reverse/proxy/api/ResourceConfig.java`

修改内容：
```java
package cc.jfire.jnet.extend.reverse.proxy.api;

import cc.jfire.jnet.extend.http.client.HttpConnection2Pool;
import cc.jfire.jnet.extend.reverse.proxy.api.config.IOResourceConfig;
import cc.jfire.jnet.extend.reverse.proxy.api.config.ProxyHttpResource;

public interface ResourceConfig
{
    ResourceHandler parse(HttpConnection2Pool pool);

    /**
     * 配置的优先级，数字越小优先级越高
     */
    int getOrder();

    static ResourceConfig io(String prefixMatch, String path, int order)
    {
        return new IOResourceConfig(prefixMatch, path, order);
    }

    static ResourceConfig fullMatch(String match, String proxy, int order)
    {
        return new ProxyHttpResource(ProxyHttpResource.MatchType.FULL, match, proxy, order);
    }

    static ResourceConfig prefixMatch(String prefix, String proxy, int order)
    {
        return new ProxyHttpResource(ProxyHttpResource.MatchType.PREFIX, prefix, proxy, order);
    }
}
```

## 步骤 3：修改 ProxyHttpResource 类

文件：`cc/jfire/jnet/extend/reverse/proxy/api/config/ProxyHttpResource.java`

修改内容：
```java
package cc.jfire.jnet.extend.reverse.proxy.api.config;

import cc.jfire.jnet.extend.http.client.HttpConnection2Pool;
import cc.jfire.jnet.extend.reverse.proxy.api.ResourceConfig;
import cc.jfire.jnet.extend.reverse.proxy.api.ResourceHandler;
import cc.jfire.jnet.extend.reverse.proxy.api.handler.FullMatchProxyHttpHandler;
import cc.jfire.jnet.extend.reverse.proxy.api.handler.PrefixMatchProxyHttpHandler;
import lombok.Data;
import lombok.experimental.Accessors;

@Data
@Accessors(chain = true)
public class ProxyHttpResource implements ResourceConfig
{
    private final MatchType matchType;
    private final String    match;
    private final String    proxy;
    private final int       order;

    public enum MatchType
    {
        PREFIX, FULL
    }

    @Override
    public ResourceHandler parse(HttpConnection2Pool pool)
    {
        return switch (matchType)
        {
            case FULL -> new FullMatchProxyHttpHandler(match, proxy, pool);
            case PREFIX -> new PrefixMatchProxyHttpHandler(match, proxy, pool);
        };
    }
}
```

## 步骤 4：修改 IOResourceConfig 类

文件：`cc/jfire/jnet/extend/reverse/proxy/api/config/IOResourceConfig.java`

需要修改 `parse()` 方法签名以接收 `HttpConnection2Pool` 参数（即使不使用）：
```java
@Override
public ResourceHandler parse(HttpConnection2Pool pool)
{
    if (path.startsWith("classpath:"))
    {
        return new ClassResourceHandler(prefixMatch, path);
    }
    else if (path.startsWith("file:"))
    {
        return new FileResourceHandler(prefixMatch, path);
    }
    else
    {
        throw new IllegalArgumentException();
    }
}
```

## 步骤 4.1：修改 AbstractIOResourceHandler 类

文件：`cc/jfire/jnet/extend/reverse/proxy/api/handler/AbstractIOResourceHandler.java`

由于 `ResourceHandler` 接口变更，需要修改此类实现新的接口方法：

```java
package cc.jfire.jnet.extend.reverse.proxy.api.handler;

import cc.jfire.baseutil.StringUtil;
import cc.jfire.jnet.common.api.Pipeline;
import cc.jfire.jnet.common.util.HttpDecodeUtil;
import cc.jfire.jnet.extend.http.dto.HttpRequestPart;
import cc.jfire.jnet.extend.http.dto.HttpRequestPartEnd;
import cc.jfire.jnet.extend.http.dto.HttpRequestPartHead;
import cc.jfire.jnet.extend.reverse.proxy.api.ResourceHandler;

import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;

public sealed abstract class AbstractIOResourceHandler implements ResourceHandler permits FileResourceHandler, ClassResourceHandler
{
    protected String prefixMatch;
    protected int    len;
    protected String path;

    /**
     * 通过matchUrl进行前缀匹配。
     * 匹配成功的情况下，截取地址中非prefixMatch的部分，拼接在path后，作为完整的资源地址进行读取
     *
     * @param prefixMatch
     * @param path
     */
    public AbstractIOResourceHandler(String prefixMatch, String path)
    {
        this.prefixMatch = prefixMatch;
        len              = prefixMatch.length();
        if (path.startsWith("file:"))
        {
            this.path = path.substring("file:".length());
        }
        else
        {
            this.path = path.substring("classpath:".length());
        }
    }

    @Override
    public boolean match(HttpRequestPartHead head)
    {
        String requestUrl = URLDecoder.decode(head.getPath(), StandardCharsets.UTF_8);
        requestUrl = HttpDecodeUtil.pureUrl(requestUrl);
        return requestUrl.startsWith(prefixMatch);
    }

    @Override
    public void process(HttpRequestPart part, Pipeline pipeline)
    {
        // IO 资源处理器只处理 Head，忽略 Body 和 End
        if (part instanceof HttpRequestPartHead head)
        {
            String requestUrl = URLDecoder.decode(head.getPath(), StandardCharsets.UTF_8);
            requestUrl = HttpDecodeUtil.pureUrl(requestUrl);
            requestUrl = requestUrl.substring(len);
            if (StringUtil.isBlank(requestUrl))
            {
                requestUrl = "index.html";
            }
            else if (requestUrl.equals("/"))
            {
                requestUrl = "/index.html";
            }
            processHead(head, pipeline, requestUrl, HttpDecodeUtil.findContentType(requestUrl));
        }
        else if (part instanceof HttpRequestPartEnd)
        {
            // End 不需要处理
        }
        else
        {
            // Body 部分释放资源
            part.close();
        }
    }

    protected abstract void processHead(HttpRequestPartHead head, Pipeline pipeline, String requestUrl, String contentType);
}
```

## 步骤 4.2：修改 ClassResourceHandler 类

文件：`cc/jfire/jnet/extend/reverse/proxy/api/handler/ClassResourceHandler.java`

修改 `process` 方法为 `processHead`：

```java
package cc.jfire.jnet.extend.reverse.proxy.api.handler;

import cc.jfire.baseutil.IoUtil;
import cc.jfire.baseutil.STR;
import cc.jfire.jnet.common.api.Pipeline;
import cc.jfire.jnet.extend.http.dto.FullHttpResp;
import cc.jfire.jnet.extend.http.dto.HttpRequestPartHead;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.ConcurrentHashMap;

public final class ClassResourceHandler extends AbstractIOResourceHandler
{
    record Tuper(String contentType, byte[] bytes)
    {
    }

    public ClassResourceHandler(String matchUrl, String originPath)
    {
        super(matchUrl, originPath);
    }

    private ConcurrentHashMap<String, Tuper> map = new ConcurrentHashMap<>();

    @Override
    protected void processHead(HttpRequestPartHead head, Pipeline pipeline, String requestUrl, String contentType)
    {
        String realClassResourcePath = path + requestUrl;
        Tuper tuper = map.computeIfAbsent(realClassResourcePath, url -> {
            try (InputStream resourceAsStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(realClassResourcePath))
            {
                if (resourceAsStream != null)
                {
                    byte[] bytes = IoUtil.readAllBytes(resourceAsStream);
                    return new Tuper(contentType, bytes);
                }
                else
                {
                    return new Tuper("text/html;charset=utf-8", STR.format("not available path:{},not find in :{}", head.getPath(), realClassResourcePath).getBytes(StandardCharsets.UTF_8));
                }
            }
            catch (IOException e)
            {
                throw new RuntimeException(e);
            }
        });
        head.close();
        FullHttpResp response = new FullHttpResp();
        response.getHead().addHeader("Content-Type", contentType);
        response.getBody().setBodyBytes(tuper.bytes());
        pipeline.fireWrite(response);
    }
}
```

## 步骤 4.3：修改 FileResourceHandler 类

文件：`cc/jfire/jnet/extend/reverse/proxy/api/handler/FileResourceHandler.java`

修改 `process` 方法为 `processHead`：

```java
package cc.jfire.jnet.extend.reverse.proxy.api.handler;

import cc.jfire.baseutil.IoUtil;
import cc.jfire.baseutil.RuntimeJVM;
import cc.jfire.baseutil.STR;
import cc.jfire.jnet.common.api.Pipeline;
import cc.jfire.jnet.extend.http.dto.FullHttpResp;
import cc.jfire.jnet.extend.http.dto.HttpRequestPartHead;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public final class FileResourceHandler extends AbstractIOResourceHandler
{
    private File dir;

    public FileResourceHandler(String prefixMatch, String originPath)
    {
        super(prefixMatch, originPath);
        if (isAbsolutePath(path))
        {
            dir = new File(path);
        }
        else
        {
            File tmp = RuntimeJVM.getDirOfMainClass();
            while (path.startsWith("../"))
            {
                tmp  = tmp.getParentFile();
                path = path.substring(3);
            }
            dir = new File(tmp, path);
        }
        if (!dir.isDirectory())
        {
            throw new IllegalArgumentException(STR.format("路径:{}应该是一个文件夹，而不是文件", originPath));
        }
    }

    @Override
    protected void processHead(HttpRequestPartHead head, Pipeline pipeline, String requestUrl, String contentType)
    {
        File resourceFile = new File(dir, requestUrl);
        if (resourceFile.exists())
        {
            try (InputStream inputStream = new FileInputStream(resourceFile))
            {
                byte[] bytes = IoUtil.readAllBytes(inputStream);
                head.close();
                FullHttpResp response = new FullHttpResp();
                response.getHead().addHeader("Content-Type", contentType);
                response.getBody().setBodyBytes(bytes);
                pipeline.fireWrite(response);
            }
            catch (IOException e)
            {
                throw new RuntimeException("读取文件地址:" + resourceFile.getAbsolutePath() + "出现异常", e);
            }
        }
        else
        {
            head.close();
            FullHttpResp response = new FullHttpResp();
            response.getHead().addHeader("Content-Type", "text/html;charset=utf-8");
            response.getBody().setBodyText(STR.format("not available path:{},not find in :{}", requestUrl, resourceFile.getAbsolutePath()));
            pipeline.fireWrite(response);
        }
    }

    private static boolean isAbsolutePath(String path)
    {
        if (path.length() == 0)
        {
            return false;
        }
        char c = path.charAt(0);
        //这个地址是绝对路径
        return c == '/' || (c >= 'a' && c <= 'z' && path.charAt(1) == ':') || (c >= 'A' && c <= 'Z' && path.charAt(1) == ':');
    }
}
```

## 步骤 5：修改 ProxyHttpHandler 抽象类

文件：`cc/jfire/jnet/extend/reverse/proxy/api/handler/ProxyHttpHandler.java`

修改内容：
```java
package cc.jfire.jnet.extend.reverse.proxy.api.handler;

import cc.jfire.jnet.extend.reverse.proxy.api.ResourceHandler;
import cc.jfire.jnet.common.api.Pipeline;
import cc.jfire.jnet.extend.http.client.HttpConnection2;
import cc.jfire.jnet.extend.http.client.HttpConnection2Pool;
import cc.jfire.jnet.extend.http.dto.*;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicReference;

@Slf4j
public sealed abstract class ProxyHttpHandler implements ResourceHandler permits PrefixMatchProxyHttpHandler, FullMatchProxyHttpHandler
{
    protected final HttpConnection2Pool pool;
    /**
     * 后端连接上下文（用于归还/丢弃时带上 host/port）。
     */
    protected record BackendConn(String host, int port, HttpConnection2 conn) {}
    /**
     * 后端连接上下文，跨线程共享：
     * - 前端请求线程：borrow 后 set
     * - 后端响应 IO 线程 / readFailed 等：getAndSet(null) 清理
     *
     * 使用 AtomicReference 保证“只清理/归还一次”，避免并发路径重复释放连接池许可。
     */
    protected final AtomicReference<BackendConn> backendConnRef = new AtomicReference<>();
    protected Pipeline currentPipeline;
    /**
     * 标记当前请求是否需要丢弃（用于拒绝 pipelining 等不支持场景）。
     * 为 true 时，Head/Body/End 都只做资源释放，不写入后端连接。
     */
    protected volatile boolean dropCurrentRequest;
    /**
     * 标记当前请求是否已收到客户端的 HttpRequestPartEnd。
     * 用于判断后端连接在收到 HttpResponsePartEnd 时是否可复用。
     */
    protected volatile boolean requestEndReceived;
    /**
     * 标记是否发生“后端响应 End 早于请求 End”（后端提前结束响应）。
     * 发生该情况时，后端连接不可复用，后续请求 body 仅做释放直到收到请求 End。
     */
    protected volatile boolean responseEndedBeforeRequestEnd;

    protected ProxyHttpHandler(HttpConnection2Pool pool)
    {
        this.pool = pool;
    }

    @Override
    public void process(HttpRequestPart part, Pipeline pipeline)
    {
        if (part instanceof HttpRequestPartHead head)
        {
            processHead(head, pipeline);
        }
        else if (part instanceof HttpRequestFixLengthBodyPart || part instanceof HttpRequestChunkedBodyPart)
        {
            processBody(part, pipeline);
        }
        else if (part instanceof HttpRequestPartEnd end)
        {
            processEnd(end, pipeline);
        }
    }

    /**
     * 子类实现，计算后端 URL 并设置到 head 中
     */
    protected abstract void computeBackendUrl(HttpRequestPartHead head);

    protected void closeAndReleaseBackendConn()
    {
        BackendConn ctx = backendConnRef.getAndSet(null);
        if (ctx == null)
        {
            return;
        }
        ctx.conn().close();
        pool.returnConnection(ctx.host(), ctx.port(), ctx.conn());
    }

    protected void releaseReusableBackendConn()
    {
        BackendConn ctx = backendConnRef.getAndSet(null);
        if (ctx == null)
        {
            return;
        }
        pool.returnConnection(ctx.host(), ctx.port(), ctx.conn());
    }

    protected void processHead(HttpRequestPartHead head, Pipeline pipeline)
    {
        // 不支持 HTTP pipelining：上一个后端响应未结束又收到新的请求
        if (backendConnRef.get() != null)
        {
            dropCurrentRequest = true;
            head.close();
            pipeline.shutdownInput();
            return;
        }
        dropCurrentRequest = false;
        requestEndReceived = false;
        responseEndedBeforeRequestEnd = false;

        this.currentPipeline = pipeline;

        // 计算后端 URL（由子类实现）
        computeBackendUrl(head);

        // 后端连接信息由 computeBackendUrl -> head.setUrl(backendUrl) 填充
        String host = head.getDomain();
        int port = head.getPort();
        if (host == null)
        {
            // 兜底：从 Host header 解析（历史兼容）
            host = head.getHeaders().get("Host");
            port = 80;
            if (host != null && host.contains(":"))
            {
                int idx = host.indexOf(':');
                port = Integer.parseInt(host.substring(idx + 1));
                host = host.substring(0, idx);
            }
        }

        try
        {
            HttpConnection2 httpConnection2 = pool.borrowConnection(host, port);
            backendConnRef.set(new BackendConn(host, port, httpConnection2));

            // 发送请求头，透传响应给客户端
            httpConnection2.write(head, responsePart -> {
                // 客户端连接已关闭：后端连接不可复用，直接关闭并释放连接池许可（不入池复用）
                if (!pipeline.isOpen())
                {
                    responsePart.free();
                    dropCurrentRequest = true;
                    closeAndReleaseBackendConn();
                    return;
                }
                if (responsePart instanceof HttpResponsePartHead respHead)
                {
                    // 透传对象本身，交由 CorsEncoder 注入 CORS，再由 HttpRespEncoder 编码写出
                    pipeline.fireWrite(respHead);
                }
                else if (responsePart instanceof HttpResponseFixLengthBodyPart body)
                {
                    pipeline.fireWrite(body.getPart());
                }
                else if (responsePart instanceof HttpResponseChunkedBodyPart body)
                {
                    pipeline.fireWrite(body.getPart());
                }
                else if (responsePart instanceof HttpResponsePartEnd)
                {
                    currentPipeline = null;
                    if (!requestEndReceived)
                    {
                        // 后端响应已结束但请求未结束：连接不可复用（避免后端协议状态错位）
                        dropCurrentRequest = true;
                        responseEndedBeforeRequestEnd = true;
                        closeAndReleaseBackendConn();
                        return;
                    }
                    // 请求已结束：连接可复用
                    releaseReusableBackendConn();
                }
            }, error -> {
                log.error("后端请求失败", error);
                // 失败时关闭并归还连接（释放连接池许可）
                currentPipeline = null;
                closeAndReleaseBackendConn();
                // 客户端可能已关闭，写失败不应影响进程
                if (pipeline.isOpen())
                {
                    sendErrorResponse(pipeline, 502, "Bad Gateway");
                }
            });
        }
        catch (TimeoutException e)
        {
            log.error("获取连接超时: {}:{}", host, port, e);
            head.close();
            // backendConnRef 保持为空，后续会在 processEnd 中发送错误响应
        }
        catch (InterruptedException e)
        {
            Thread.currentThread().interrupt();
            log.error("获取连接被中断: {}:{}", host, port, e);
            head.close();
        }
        catch (Exception e)
        {
            log.error("获取连接失败: {}:{}", host, port, e);
            head.close();
            // 借到连接但 write 失败等情况，需关闭并归还（释放许可）
            currentPipeline = null;
            closeAndReleaseBackendConn();
        }
    }

    protected void processBody(HttpRequestPart body, Pipeline pipeline)
    {
        if (dropCurrentRequest)
        {
            body.close();
            return;
        }
        BackendConn ctx = backendConnRef.get();
        if (ctx == null)
        {
            body.close();
            return;
        }
        ctx.conn().write(body);
    }

    protected void processEnd(HttpRequestPartEnd end, Pipeline pipeline)
    {
        requestEndReceived = true;
        if (dropCurrentRequest)
        {
            dropCurrentRequest = false;
            responseEndedBeforeRequestEnd = false;
            end.close();
            return;
        }
        if (backendConnRef.get() == null)
        {
            if (responseEndedBeforeRequestEnd)
            {
                // 后端已提前结束且连接已关闭/不可复用：此处仅做清理，避免误发 503
                responseEndedBeforeRequestEnd = false;
                end.close();
                return;
            }
            // 没有连接，发送"连接过多"响应
            sendErrorResponse(pipeline, 503, "Service Unavailable - Too Many Connections");
            return;
        }
        // 不在此处归还连接：归还时机以“收到后端 HttpResponsePartEnd”为准
    }

    protected void sendErrorResponse(Pipeline pipeline, int statusCode, String message)
    {
        FullHttpResp response = new FullHttpResp();
        response.getHead().setResponseCode(statusCode);
        response.getBody().setBodyText(message);
        pipeline.fireWrite(response);
    }

    @Override
    public void readFailed(Throwable e)
    {
        // 客户端断开/读取失败：后端连接不可复用，直接关闭并释放连接池许可
        currentPipeline = null;
        dropCurrentRequest = true;
        requestEndReceived = false;
        responseEndedBeforeRequestEnd = false;
        closeAndReleaseBackendConn();
    }
}
```

## 步骤 6：修改 PrefixMatchProxyHttpHandler 类

文件：`cc/jfire/jnet/extend/reverse/proxy/api/handler/PrefixMatchProxyHttpHandler.java`

修改内容：
```java
package cc.jfire.jnet.extend.reverse.proxy.api.handler;

import cc.jfire.baseutil.STR;
import cc.jfire.jnet.extend.http.client.HttpConnection2Pool;
import cc.jfire.jnet.extend.http.dto.HttpRequestPartHead;

/**
 * 前缀匹配
 * 匹配规则:
 * 1. 匹配规则必须以"/*"结尾，且规则路径中只能有一个*
 * 2. 匹配规则里非*的部分是请求url的开始部分。
 * 3. 请求url中去掉匹配规则长度（不包含*）的部分拼接上proxy的部分，作为后端的url。
 */
public final class PrefixMatchProxyHttpHandler extends ProxyHttpHandler
{
    private final String prefixMatch;
    private final int    len;
    private final String proxy;

    public PrefixMatchProxyHttpHandler(String prefixMatch, String proxy, HttpConnection2Pool pool)
    {
        super(pool);
        isValidPrefix(prefixMatch);
        this.prefixMatch = prefixMatch.substring(0, prefixMatch.length() - 1);
        len              = this.prefixMatch.length();
        this.proxy       = proxy;
    }

    private void isValidPrefix(String str)
    {
        if (str.endsWith("/*") && str.chars().filter(c -> c == '*').count() == 1)
        {
            ;
        }
        else
        {
            throw new IllegalArgumentException(STR.format("{}不是合规的前缀匹配地址", str));
        }
    }

    @Override
    public boolean match(HttpRequestPartHead head)
    {
        String requestUrl = head.getPath();
        int    index      = requestUrl.indexOf("#");
        if (index != -1)
        {
            requestUrl = requestUrl.substring(0, index);
        }
        return requestUrl.startsWith(prefixMatch);
    }

    @Override
    protected void computeBackendUrl(HttpRequestPartHead head)
    {
        String requestUrl = head.getPath();
        int    index      = requestUrl.indexOf("#");
        if (index != -1)
        {
            requestUrl = requestUrl.substring(0, index);
        }
        String backendUrl = proxy + requestUrl.substring(len);

        // 统一使用 HttpRequestPartHead#setUrl 解析并更新 path/Host，同时释放/清空 headBuffer（避免旧头被直接写出）
        head.setUrl(backendUrl);
    }
}
```

## 步骤 7：修改 FullMatchProxyHttpHandler 类

文件：`cc/jfire/jnet/extend/reverse/proxy/api/handler/FullMatchProxyHttpHandler.java`

修改内容：
```java
package cc.jfire.jnet.extend.reverse.proxy.api.handler;

import cc.jfire.jnet.extend.http.client.HttpConnection2Pool;
import cc.jfire.jnet.extend.http.dto.HttpRequestPartHead;
import lombok.Getter;

/**
 * 请求url完全匹配match，则将请求发向proxy
 */
@Getter
public final class FullMatchProxyHttpHandler extends ProxyHttpHandler
{
    private final String match;
    private final String proxy;

    public FullMatchProxyHttpHandler(String match, String proxy, HttpConnection2Pool pool)
    {
        super(pool);
        this.match = match;
        this.proxy = proxy;
    }

    @Override
    public boolean match(HttpRequestPartHead head)
    {
        String requestUrl = head.getPath();
        int    index      = requestUrl.indexOf("#");
        if (index != -1)
        {
            requestUrl = requestUrl.substring(0, index);
        }
        index = requestUrl.indexOf("?");
        String matchPart = index == -1 ? requestUrl : requestUrl.substring(0, index);
        return matchPart.equals(match);
    }

    @Override
    protected void computeBackendUrl(HttpRequestPartHead head)
    {
        String requestUrl = head.getPath();
        int    index      = requestUrl.indexOf("#");
        if (index != -1)
        {
            requestUrl = requestUrl.substring(0, index);
        }
        index = requestUrl.indexOf("?");
        String backendUrl = index == -1 ? proxy : proxy + requestUrl.substring(index);

        // 统一使用 HttpRequestPartHead#setUrl 解析并更新 path/Host，同时释放/清空 headBuffer（避免旧头被直接写出）
        head.setUrl(backendUrl);
    }
}
```

## 步骤 8：修改 TransferProcessor 类

文件：`cc/jfire/jnet/extend/reverse/proxy/TransferProcessor.java`

修改内容：
```java
package cc.jfire.jnet.extend.reverse.proxy;

import cc.jfire.jnet.common.api.ReadProcessor;
import cc.jfire.jnet.common.api.ReadProcessorNode;
import cc.jfire.jnet.extend.http.client.HttpConnection2Pool;
import cc.jfire.jnet.extend.http.dto.*;
import cc.jfire.jnet.extend.reverse.proxy.api.ResourceConfig;
import cc.jfire.jnet.extend.reverse.proxy.api.ResourceHandler;

import java.util.Comparator;
import java.util.List;

public class TransferProcessor implements ReadProcessor<HttpRequestPart>
{
    private final ResourceHandler[] handlers;
    private ResourceHandler currentHandler;

    public TransferProcessor(List<ResourceConfig> configs, HttpConnection2Pool pool)
    {
        handlers = configs.stream()
                         .sorted(Comparator.comparingInt(ResourceConfig::getOrder))
                         .map(config -> config.parse(pool))
                         .toArray(ResourceHandler[]::new);
    }

    @Override
    public void read(HttpRequestPart part, ReadProcessorNode next)
    {
        if (part instanceof HttpRequestPartHead head)
        {
            processHead(head, next);
        }
        else if (part instanceof HttpRequestFixLengthBodyPart || part instanceof HttpRequestChunkedBodyPart)
        {
            processBody(part, next);
        }
        else if (part instanceof HttpRequestPartEnd end)
        {
            processEnd(end, next);
        }
    }

    private void processHead(HttpRequestPartHead head, ReadProcessorNode next)
    {
        for (ResourceHandler handler : handlers)
        {
            if (handler.match(head))
            {
                currentHandler = handler;
                handler.process(head, next.pipeline());
                return;
            }
        }
        // 没有匹配的 handler
        String path = head.getPath();
        head.close();
        FullHttpResp response = new FullHttpResp();
        response.getHead().setResponseCode(404);
        response.getBody().setBodyText("not found address:" + path);
        next.pipeline().fireWrite(response);
    }

    private void processBody(HttpRequestPart body, ReadProcessorNode next)
    {
        if (currentHandler != null)
        {
            currentHandler.process(body, next.pipeline());
        }
        else
        {
            body.close();
        }
    }

    private void processEnd(HttpRequestPartEnd end, ReadProcessorNode next)
    {
        if (currentHandler != null)
        {
            currentHandler.process(end, next.pipeline());
            currentHandler = null;
        }
        else
        {
            end.close();
        }
    }

    @Override
    public void readFailed(Throwable e, ReadProcessorNode next)
    {
        try
        {
            for (ResourceHandler handler : handlers)
            {
                handler.readFailed(e);
            }
        }
        finally
        {
            currentHandler = null;
        }
        next.fireReadFailed(e);
    }
}
```

## 步骤 9：修改 ReverseProxyServer 类

文件：`cc/jfire/jnet/extend/reverse/proxy/ReverseProxyServer.java`

修改内容：
1. 新增 `HttpConnection2Pool` 成员变量
2. 移除管线中的 `HttpRequestAggregator`
3. 将 `HttpConnection2Pool` 传递给 `TransferProcessor`

```java
package cc.jfire.jnet.extend.reverse.proxy;

import cc.jfire.baseutil.IoUtil;
import cc.jfire.baseutil.RuntimeJVM;
import cc.jfire.jnet.common.api.Pipeline;
import cc.jfire.jnet.common.util.ChannelConfig;
import cc.jfire.jnet.extend.http.coder.*;
import cc.jfire.jnet.extend.http.client.HttpConnection2Pool;
import cc.jfire.jnet.extend.reverse.app.SslInfo;
import cc.jfire.jnet.extend.reverse.proxy.api.ResourceConfig;
import cc.jfire.jnet.server.AioServer;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;

import javax.net.ssl.*;
import java.io.File;
import java.io.FileInputStream;
import java.security.KeyStore;
import java.util.List;
import java.util.function.Consumer;

@Slf4j
public class ReverseProxyServer
{
    private int                  port;
    private List<ResourceConfig> configs;
    private SslInfo              sslInfo;
    private HttpConnection2Pool  pool = new HttpConnection2Pool();

    public ReverseProxyServer(int port, List<ResourceConfig> configs)
    {
        this.port    = port;
        this.configs = configs;
        this.sslInfo = new SslInfo().setEnable(false);
    }

    public ReverseProxyServer(int port, List<ResourceConfig> configs, SslInfo sslInfo)
    {
        this.port    = port;
        this.configs = configs;
        this.sslInfo = sslInfo;
    }

    @SneakyThrows
    public void start()
    {
        if (RuntimeJVM.getDirOfMainClass() == null)
        {
            throw new NullPointerException("Main Class not register");
        }
        ChannelConfig channelConfig = new ChannelConfig();
        channelConfig.setPort(port);
        if (sslInfo.isEnable())
        {
            Consumer<Pipeline> s = pipeline -> {
                try
                {
                    KeyStore keyStore = KeyStore.getInstance("JKS");
                    String   filePath = sslInfo.getCert();
                    if (IoUtil.isFilePathAbsolute(filePath))
                    {
                        try (FileInputStream fileInputStream = new FileInputStream(filePath))
                        {
                            keyStore.load(fileInputStream, sslInfo.getPassword().toCharArray());
                        }
                    }
                    else
                    {
                        try (FileInputStream fileInputStream = new FileInputStream(new File(RuntimeJVM.getDirOfMainClass(), filePath)))
                        {
                            keyStore.load(fileInputStream, sslInfo.getPassword().toCharArray());
                        }
                    }
                    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
                    kmf.init(keyStore, sslInfo.getPassword().toCharArray());
                    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
                    tmf.init(keyStore);
                    SSLContext sslContext = SSLContext.getInstance("TLS");
                    sslContext.init(kmf.getKeyManagers(), null, null);
                    SSLEngine sslEngine = sslContext.createSSLEngine();
                    sslEngine.setUseClientMode(false);
                    sslEngine.setNeedClientAuth(false);
                    sslEngine.setEnabledCipherSuites(sslEngine.getSupportedCipherSuites());
                    sslEngine.setEnabledProtocols(sslEngine.getSupportedProtocols());
                    try
                    {
                        sslEngine.beginHandshake();
                    }
                    catch (SSLException e)
                    {
                        throw new RuntimeException(e);
                    }
                    SSLDecoder sslDecoder = new SSLDecoder(sslEngine);
                    SSLEncoder sslEncoder = new SSLEncoder(sslEngine, sslDecoder);
                    pipeline.addReadProcessor(sslDecoder);
                    pipeline.addReadProcessor(new HttpRequestPartDecoder());
                    // 移除 HttpRequestAggregator，直接传递 HttpRequestPart
                    pipeline.addReadProcessor(new TransferProcessor(configs, pool));
                    pipeline.addWriteProcessor(new CorsEncoder());
                    pipeline.addWriteProcessor(new HttpRespEncoder(pipeline.allocator()));
                    pipeline.addWriteProcessor(sslEncoder);
                }
                catch (Throwable e)
                {
                    e.printStackTrace();
                }
            };
            AioServer aioServer = AioServer.newAioServer(channelConfig, s::accept);
            aioServer.start();
        }
        else
        {
            Consumer<Pipeline> s = pipeline -> {
                pipeline.addReadProcessor(new HttpRequestPartDecoder());
                // 移除 HttpRequestAggregator，直接传递 HttpRequestPart
                pipeline.addReadProcessor(new TransferProcessor(configs, pool));
                pipeline.addWriteProcessor(new CorsEncoder());
                pipeline.addWriteProcessor(new HttpRespEncoder(pipeline.allocator()));
            };
            AioServer aioServer = AioServer.newAioServer(channelConfig, s::accept);
            aioServer.start();
        }
    }
}
```

## 步骤 10：修改 HttpRequestPartDecoder 类（chunked 结束块）

文件：`cc/jfire/jnet/extend/http/coder/HttpRequestPartDecoder.java`

修改 `parseBodyChunked` 方法中 `chunkSize == 0` 的处理逻辑：

原代码：
```java
// 处理chunk size为0的情况（结束标志）
if (chunkSize == 0)
{
    // chunk size为0时，格式为：0\r\n\r\n（chunk size行 + 结尾的CRLF）
    int totalLength = chunkSizeLineLength + 2;
    if (accumulation.remainRead() < totalLength)
    {
        return false;
    }
    // 跳过整个结束chunk
    accumulation.addReadPosi(totalLength);
    next.fireRead(new HttpRequestPartEnd());
    resetState();
    return accumulation != null && accumulation.remainRead() > 0;
}
```

修改为：
```java
// 处理chunk size为0的情况（结束标志）
if (chunkSize == 0)
{
    // chunk size为0时，格式为：0\r\n\r\n（chunk size行 + 结尾的CRLF）
    int totalLength = chunkSizeLineLength + 2;
    if (accumulation.remainRead() < totalLength)
    {
        return false;
    }
    // 构造一个内容长度为0的 ChunkedBodyPart，包含 0\r\n\r\n
    HttpRequestChunkedBodyPart part = new HttpRequestChunkedBodyPart();
    part.setHeadLength(chunkSizeLineLength);
    part.setChunkLength(totalLength);
    part.setPart(accumulation.slice(totalLength));
    next.fireRead(part);
    next.fireRead(new HttpRequestPartEnd());
    resetState();
    return accumulation != null && accumulation.remainRead() > 0;
}
```

## 步骤 11：修改 HttpResponsePartDecoder 类（chunked 结束块）

文件：`cc/jfire/jnet/extend/http/coder/HttpResponsePartDecoder.java`

修改 chunked 解析逻辑中 `chunkSize == 0` 的处理，与步骤 10 类似：

原代码（跳过结束块直接发 End）：
```java
if (chunkSize == 0)
{
    int totalLength = chunkSizeLineLength + 2;
    if (accumulation.remainRead() < totalLength)
    {
        return false;
    }
    accumulation.addReadPosi(totalLength);
    next.fireRead(new HttpResponsePartEnd());
    resetState();
    return accumulation != null && accumulation.remainRead() > 0;
}
```

修改为：
```java
if (chunkSize == 0)
{
    int totalLength = chunkSizeLineLength + 2;
    if (accumulation.remainRead() < totalLength)
    {
        return false;
    }
    // 构造一个内容长度为0的 ChunkedBodyPart，包含 0\r\n\r\n
    HttpResponseChunkedBodyPart part = new HttpResponseChunkedBodyPart();
    part.setHeadLength(chunkSizeLineLength);
    part.setChunkLength(totalLength);
    part.setPart(accumulation.slice(totalLength));
    next.fireRead(part);
    next.fireRead(new HttpResponsePartEnd());
    resetState();
    return accumulation != null && accumulation.remainRead() > 0;
}
```

## 步骤 12：抽取 URL 解析公共逻辑（HttpUrl）并复用到 setUrl

目标：避免 `HttpRequest#setUrl` 与 `HttpRequestPartHead#setUrl` 各自维护一份 URL 解析逻辑（以及重复的 `http`/`https` 默认端口判断）。

### 12.1 新增 HttpUrl（统一 URL 解析结果）

文件：`cc/jfire/jnet/extend/http/dto/HttpUrl.java`

新增一个 record（或普通类）承载解析结果，并提供 `static HttpUrl parse(String url)`：

```java
package cc.jfire.jnet.extend.http.dto;

public record HttpUrl(String domain, int port, String path, String hostHeader)
{
    public static HttpUrl parse(String url)
    {
        int index = 0;
        int domainStart = 0;
        boolean isHttps = false;
        if (url.startsWith("http://"))
        {
            index = url.indexOf("/", 8);
            domainStart = 7;
        }
        else if (url.startsWith("https://"))
        {
            index = url.indexOf("/", 9);
            domainStart = 8;
            isHttps = true;
        }
        // 保持与原 HttpRequest#setUrl 一致：若不是 http/https 开头，则按旧逻辑继续解析（domainStart/index 默认为 0）
        if (index == -1)
        {
            index = url.length();
        }

        int portStart = url.indexOf(':', domainStart);
        if (portStart > index)
        {
            portStart = -1;
        }

        String path = index == url.length() ? "/" : url.substring(index);
        int port = portStart == -1 ? (isHttps ? 443 : 80) : Integer.parseInt(url.substring(portStart + 1, index));
        String domain = portStart == -1 ? url.substring(domainStart, index) : url.substring(domainStart, portStart);
        String hostHeader = portStart == -1 ? domain : url.substring(domainStart, index);
        return new HttpUrl(domain, port, path, hostHeader);
    }
}
```

### 12.2 修改 HttpRequest#setUrl 复用 HttpUrl.parse（消除重复解析逻辑）

文件：`cc/jfire/jnet/extend/http/dto/HttpRequest.java`

将原本内联解析替换为调用 `HttpUrl.parse(url)`：

```java
public HttpRequest setUrl(String url)
{
    this.url = url;
    HttpUrl parsed = HttpUrl.parse(url);
    this.domain = parsed.domain();
    this.port = parsed.port();
    this.path = parsed.path();
    this.headers.put("Host", parsed.hostHeader());
    return this;
}
```

### 12.3 修改 HttpRequestPartHead#setUrl 复用 HttpUrl.parse，并释放 headBuffer

文件：`cc/jfire/jnet/extend/http/dto/HttpRequestPartHead.java`

改动点：
1. 增加字段 `String domain`、`int port`（默认 80），供 `ProxyHttpHandler` 直接取值申请连接（不再依赖 `Host` header 解析端口）
2. 新增 `setUrl(String url)`：调用 `HttpUrl.parse(url)` 设置 `path/domain/port`，并大小写不敏感替换 `Host` header 为 `parsed.hostHeader()`
3. 清空并释放 `headBuffer`（避免编码器继续写出旧头，同时避免内存泄漏）

```java
public HttpRequestPartHead setUrl(String url)
{
    HttpUrl parsed = HttpUrl.parse(url);
    setPath(parsed.path());
    setDomain(parsed.domain());
    setPort(parsed.port());

    // Host header：大小写不敏感替换，避免产生重复 Host
    String matchedKey = null;
    for (String key : headers.keySet())
    {
        if (key.equalsIgnoreCase("Host"))
        {
            matchedKey = key;
            break;
        }
    }
    if (matchedKey != null)
    {
        headers.remove(matchedKey);
    }
    headers.put("Host", parsed.hostHeader());

    // 关键：清空并释放 headBuffer，否则编码器会直接写出原始头部，同时避免内存泄漏
    IoBuffer old = getHeadBuffer();
    setHeadBuffer(null);
    if (old != null)
    {
        old.free();
    }
    return this;
}
```

## 步骤 13：修改 CorsEncoder，支持 HttpResponsePartHead 并注入 CORS

文件：`cc/jfire/jnet/extend/http/coder/CorsEncoder.java`

修改内容：
1. 增加对 `HttpResponsePartHead` 的处理
2. 在修改 headers 前先释放旧的 `part` 并清空 `part` 引用（避免旧字节被写出，也避免内存泄漏）
3. 大小写不敏感地检查并补充 CORS 头

完整代码：

```java
package cc.jfire.jnet.extend.http.coder;

import cc.jfire.jnet.common.api.WriteProcessor;
import cc.jfire.jnet.common.api.WriteProcessorNode;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.jnet.extend.http.dto.FullHttpResp;
import cc.jfire.jnet.extend.http.dto.HttpRespHead;
import cc.jfire.jnet.extend.http.dto.HttpResponsePartHead;

import java.util.Map;

public class CorsEncoder implements WriteProcessor<Object>
{
    @Override
    public void write(Object data, WriteProcessorNode next)
    {
        if (data instanceof FullHttpResp fullHttpResp)
        {
            HttpRespHead head = fullHttpResp.getHead();
            head.addHeader("Access-Control-Allow-Origin", "*")
                .addHeader("access-control-allow-methods", "GET,PUT,POST,HEAD")
                .addHeader("Access-Control-Max-Age", "86400")
                .addHeader("Access-Control-Allow-Headers", "*");
            next.fireWrite(fullHttpResp);
        }
        else if (data instanceof HttpResponsePartHead head)
        {
            // 释放并清空旧的 part，避免编码器写出原始字节
            IoBuffer old = head.getPart();
            head.setPart(null);
            if (old != null)
            {
                old.free();
            }
            // 大小写不敏感地补充 CORS 头
            addCorsHeadersIgnoreCase(head.getHeaders());
            next.fireWrite(head);
        }
        else
        {
            next.fireWrite(data);
        }
    }

    private void addCorsHeadersIgnoreCase(Map<String, String> headers)
    {
        if (!containsIgnoreCase(headers, "Access-Control-Allow-Origin"))
        {
            headers.put("Access-Control-Allow-Origin", "*");
        }
        if (!containsIgnoreCase(headers, "Access-Control-Allow-Methods"))
        {
            headers.put("Access-Control-Allow-Methods", "GET,PUT,POST,HEAD");
        }
        if (!containsIgnoreCase(headers, "Access-Control-Max-Age"))
        {
            headers.put("Access-Control-Max-Age", "86400");
        }
        if (!containsIgnoreCase(headers, "Access-Control-Allow-Headers"))
        {
            headers.put("Access-Control-Allow-Headers", "*");
        }
    }

    private boolean containsIgnoreCase(Map<String, String> headers, String key)
    {
        return headers.keySet().stream().anyMatch(k -> k.equalsIgnoreCase(key));
    }
}
```

## 步骤 14：修改 HttpRespEncoder，增加对 HttpResponsePartHead 的写出能力

文件：`cc/jfire/jnet/extend/http/coder/HttpRespEncoder.java`

修改内容：
1. 增加对 `HttpResponsePartHead` 的处理分支
2. 如果 `head.getPart()` 不为空，则直接写出该 buffer
3. 如果 `head.getPart()` 为空，则基于 `version/statusCode/reasonPhrase/headers` 重新编码（响应行 + headers + CRLFCRLF）并写出 `IoBuffer`

完整代码：

```java
package cc.jfire.jnet.extend.http.coder;

import cc.jfire.baseutil.STR;
import cc.jfire.jnet.common.api.WriteProcessor;
import cc.jfire.jnet.common.api.WriteProcessorNode;
import cc.jfire.jnet.common.buffer.allocator.BufferAllocator;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.jnet.common.util.DataIgnore;
import cc.jfire.jnet.extend.http.dto.FullHttpResp;
import cc.jfire.jnet.extend.http.dto.HttpRespBody;
import cc.jfire.jnet.extend.http.dto.HttpRespHead;
import cc.jfire.jnet.extend.http.dto.HttpResponsePartHead;
import lombok.extern.slf4j.Slf4j;

import java.nio.charset.StandardCharsets;

@Slf4j
public class HttpRespEncoder implements WriteProcessor<Object>
{
    private final       BufferAllocator allocator;
    public static final byte[]          NEWLINE          = "\r\n".getBytes(StandardCharsets.US_ASCII);

    public HttpRespEncoder(BufferAllocator allocator)
    {
        this.allocator = allocator;
    }

    @Override
    public void write(Object obj, WriteProcessorNode next)
    {
        if (obj instanceof HttpRespHead head)
        {
            IoBuffer buffer = allocator.allocate(1024);
            head.write(buffer);
            buffer.put(NEWLINE);
            next.fireWrite(buffer);
        }
        else if (obj instanceof HttpRespBody body)
        {
            IoBuffer buffer = allocator.allocate(1024);
            body.write(buffer);
            next.fireWrite(buffer);
        }
        else if (obj instanceof FullHttpResp fullHttpResp)
        {
            IoBuffer buffer = allocator.allocate(1024);
            fullHttpResp.write(buffer);
            next.fireWrite(buffer);
        }
        else if (obj instanceof HttpResponsePartHead head)
        {
            // 如果 part 不为空，直接写出原始 buffer
            IoBuffer part = head.getPart();
            if (part != null)
            {
                next.fireWrite(part);
            }
            else
            {
                // part 为空，基于属性重新编码
                IoBuffer buffer = allocator.allocate(1024);
                // 编码响应行：HTTP/1.1 200 OK\r\n
                String responseLine = head.getVersion() + " " + head.getStatusCode() + " " +
                                      (head.getReasonPhrase() != null ? head.getReasonPhrase() : "") + "\r\n";
                buffer.put(responseLine.getBytes(StandardCharsets.US_ASCII));
                // 编码 headers
                head.getHeaders().forEach((name, value) -> {
                    buffer.put((name + ": " + value + "\r\n").getBytes(StandardCharsets.US_ASCII));
                });
                // 空行结束头部
                buffer.put(NEWLINE);
                next.fireWrite(buffer);
            }
        }
        else if (obj instanceof IoBuffer || obj instanceof DataIgnore)
        {
            next.fireWrite(obj);
        }
        else
        {
            throw new IllegalArgumentException(STR.format("HttpRespPartEncoder不支持入参类型:{}", obj.getClass()));
        }
    }
}
```

## 步骤 15：修改 ProxyHttpHandler 的响应透传逻辑（含连接归还时机）

修改 `processHead` 方法中的 `partConsumer`，透传 `HttpResponsePartHead` 对象本身，body 透传 IoBuffer，并在 `HttpResponsePartEnd` 时归还连接：

```java
// 发送请求头，透传响应给客户端
httpConnection2.write(head, responsePart -> {
    // 客户端通道已关闭：后端连接不可复用，直接关闭并释放连接池许可（不入池复用）
    if (!pipeline.isOpen())
    {
        responsePart.free();
        dropCurrentRequest = true;
        closeAndReleaseBackendConn();
        return;
    }
    if (responsePart instanceof HttpResponsePartHead respHead)
    {
        pipeline.fireWrite(respHead);
    }
    else if (responsePart instanceof HttpResponseFixLengthBodyPart body)
    {
        pipeline.fireWrite(body.getPart());
    }
    else if (responsePart instanceof HttpResponseChunkedBodyPart body)
    {
        pipeline.fireWrite(body.getPart());
    }
    else if (responsePart instanceof HttpResponsePartEnd)
    {
        // 不写出任何内容，End 仅作为结束标记
        if (!requestEndReceived)
        {
            // 后端 End 早于请求 End：连接不可复用，关闭并释放连接池许可，后续 body 丢弃直到请求 End
            dropCurrentRequest = true;
            closeAndReleaseBackendConn();
            return;
        }
        // 请求已结束：连接可复用
        releaseReusableBackendConn();
    }
}, error -> {
    log.error("后端请求失败", error);
    // 失败时关闭并归还连接（释放许可）
    closeAndReleaseBackendConn();
    if (pipeline.isOpen())
    {
        sendErrorResponse(pipeline, 502, "Bad Gateway");
    }
});
```

# 待办列表

1. [ ] 修改 ResourceHandler 接口，新增 match 方法，修改 process 方法签名
2. [ ] 修改 ResourceConfig 接口，parse 方法增加 HttpConnection2Pool 参数
3. [ ] 修改 ProxyHttpResource 类，parse 方法传递 pool 给 handler 构造函数
4. [ ] 修改 IOResourceConfig 类，parse 方法签名适配新接口
5. [ ] 修改 AbstractIOResourceHandler 类，实现新的 match 和 process 方法
6. [ ] 修改 ClassResourceHandler 类，适配新的方法签名
7. [ ] 修改 FileResourceHandler 类，适配新的方法签名
8. [ ] 修改 ProxyHttpHandler 抽象类，新增连接池管理和请求处理逻辑（AtomicReference 一次性回收/归还）
9. [ ] 新增 HttpUrl（统一 URL 解析）
10. [ ] 修改 HttpRequest#setUrl：复用 HttpUrl.parse（消除重复解析逻辑）
11. [ ] 修改 HttpRequestPartHead：增加 domain/port 字段，setUrl 复用 HttpUrl.parse 并释放 headBuffer
12. [ ] 修改 PrefixMatchProxyHttpHandler 类，实现 match 和 computeBackendUrl 方法，调用 head.setUrl
13. [ ] 修改 FullMatchProxyHttpHandler 类，实现 match 和 computeBackendUrl 方法，调用 head.setUrl
14. [ ] 修改 TransferProcessor 类，改为处理 HttpRequestPart，新增状态管理
15. [ ] 修改 ReverseProxyServer 类，移除 HttpRequestAggregator，新增 HttpConnection2Pool
16. [ ] 修改 HttpRequestPartDecoder 类，chunked 结束时先发 ChunkedBodyPart 再发 End
17. [ ] 修改 HttpResponsePartDecoder 类，chunked 结束时先发 ChunkedBodyPart 再发 End
18. [ ] 修改 CorsEncoder，支持 HttpResponsePartHead 并注入 CORS，同时释放/清空旧 part
19. [ ] 修改 HttpRespEncoder，支持 HttpResponsePartHead（优先使用 part buffer，否则重新编码写出）
20. [ ] 修改 ProxyHttpHandler 响应透传逻辑：Head 透传对象、Body 透传 IoBuffer、响应 End（请求已结束则归还，否则关闭并释放；使用 AtomicReference 避免重复归还）

# 需要修改或新增的类

## 需要新增的类

1. `cc.jfire.jnet.extend.http.dto.HttpUrl` - 统一 URL 解析结果与 `parse` 方法（供 `HttpRequest#setUrl` / `HttpRequestPartHead#setUrl` 复用）

## 需要修改的类

1. `cc.jfire.jnet.extend.reverse.proxy.api.ResourceHandler` - 接口，新增 match 方法，修改 process 签名
2. `cc.jfire.jnet.extend.reverse.proxy.api.ResourceConfig` - 接口，parse 方法增加参数
3. `cc.jfire.jnet.extend.reverse.proxy.api.config.ProxyHttpResource` - parse 方法适配
4. `cc.jfire.jnet.extend.reverse.proxy.api.config.IOResourceConfig` - parse 方法签名适配
5. `cc.jfire.jnet.extend.reverse.proxy.api.handler.AbstractIOResourceHandler` - 实现新的接口方法
6. `cc.jfire.jnet.extend.reverse.proxy.api.handler.ClassResourceHandler` - 适配新的方法签名
7. `cc.jfire.jnet.extend.reverse.proxy.api.handler.FileResourceHandler` - 适配新的方法签名
8. `cc.jfire.jnet.extend.reverse.proxy.api.handler.ProxyHttpHandler` - 重写为流式处理，新增连接池管理，响应透传
9. `cc.jfire.jnet.extend.http.dto.HttpRequest` - `setUrl` 改为复用 `HttpUrl.parse`
10. `cc.jfire.jnet.extend.http.dto.HttpRequestPartHead` - 增加 domain/port 字段，`setUrl` 复用 `HttpUrl.parse`，并释放 headBuffer
11. `cc.jfire.jnet.extend.reverse.proxy.api.handler.PrefixMatchProxyHttpHandler` - 实现新接口方法，调用 head.setUrl
12. `cc.jfire.jnet.extend.reverse.proxy.api.handler.FullMatchProxyHttpHandler` - 实现新接口方法，调用 head.setUrl
13. `cc.jfire.jnet.extend.reverse.proxy.TransferProcessor` - 改为处理 HttpRequestPart
14. `cc.jfire.jnet.extend.reverse.proxy.ReverseProxyServer` - 移除 HttpRequestAggregator，新增 HttpConnection2Pool
15. `cc.jfire.jnet.extend.http.coder.HttpRequestPartDecoder` - chunked 结束块处理
16. `cc.jfire.jnet.extend.http.coder.HttpResponsePartDecoder` - chunked 结束块处理
17. `cc.jfire.jnet.extend.http.coder.CorsEncoder` - 支持 HttpResponsePartHead 并注入 CORS
18. `cc.jfire.jnet.extend.http.coder.HttpRespEncoder` - 支持 HttpResponsePartHead（优先使用 part buffer，否则重新编码写出）

## 不需要新增的类

除新增 `cc.jfire.jnet.extend.http.dto.HttpUrl` 外，不需要新增其他类。
