# 目标

在cc.jfire.jnet.extend.reverse.proxy.api.handler.ProxyHttpHandler
中会需要考虑属性：responseEndedBeforeRequestEnd。当前的代码仅仅通过是否收到 HttpRequestPartEnd
来判断，这个是不太合理的。会出现如下的情况：
1、get 请求没有方法体，已经将 head写出，也收到了响应，但是因为线程异步的原因，客户端的 end
此时才传递到这个方法，这就造成了误判。
2、持续的透传 body，最后一个 body 传递后，收到了下游的 end
响应。同样因为线程异步的原因，导致客户端的 end 此时才传递到这个方法，也会造成误判。

目标是解决这个问题

# 核心思路

我认为解决方法是在在 Head 和 body 中，都加入一个 last 属性，如果last 为 true，则以为请求实际上已经结束了。下游也可以根据这个来判断是否完整请求结束。有了这个 last 属性，那么 end 就不需要了。

# 详细实现思路

## 1. `last` 属性的语义定义

- `last = true` 表示当前 part 是整个 HTTP 请求的最后一个部分，请求已经完整结束
- `last = false` 表示后续还有更多 part 需要处理

## 2. 各类型 Part 的 `last` 设置规则

### 2.1 `HttpRequestPartHead`
- **无 body 的请求**（如 GET、HEAD 等）：`contentLength == 0 && chunked == false` 时，`last = true`
- **有 body 的请求**：`last = false`，后续会有 body part

### 2.2 `HttpRequestFixLengthBodyPart`
- 解码器需要追踪已读取的字节数，当当前 part 包含了剩余所有字节时，`last = true`
- 即：`bodyRead + currentPartLength >= contentLength` 时，该 part 的 `last = true`

### 2.3 `HttpRequestChunkedBodyPart`
- 当 `chunkSize == 0`（终止 chunk）时，`last = true`
- 其他情况 `last = false`

## 3. 废弃 `HttpRequestPartEnd`

- 删除 `HttpRequestPartEnd` 类
- 所有使用 `HttpRequestPartEnd` 的地方改为判断 `part.isLast()`

## 4. 接口设计

在 `HttpRequestPart` 接口中添加默认方法：
```java
default boolean isLast() {
    return false;
}
```

各实现类根据需要覆盖此方法。

## 5. 解决 `responseEndedBeforeRequestEnd` 误判问题

改造后的判断逻辑：
- 在 `processHead` 中：如果 `head.isLast() == true`，直接设置 `requestEndReceived = true`
- 在 `processBody` 中：如果 `body.isLast() == true`，设置 `requestEndReceived = true`
- 不再依赖 `HttpRequestPartEnd` 的到达来设置 `requestEndReceived`

这样，当后端响应 End 到达时，`requestEndReceived` 的值是准确的，不会因线程异步导致误判。

# 实施步骤

## 步骤 1：修改 `HttpRequestPart` 接口

在 `cc.jfire.jnet.extend.http.dto.HttpRequestPart` 接口中添加 `isLast()` 默认方法：

```java
package cc.jfire.jnet.extend.http.dto;

public interface HttpRequestPart
{
    void close();

    default boolean isLast()
    {
        return false;
    }
}
```

## 步骤 2：修改 `HttpRequestPartHead` 类

添加 `last` 属性和相关方法：

```java
// 在类中添加属性
protected boolean last = false;

// 添加 getter 方法（或使用 @Data 自动生成）
public boolean isLast()
{
    return last;
}

public void setLast(boolean last)
{
    this.last = last;
}
```

## 步骤 3：修改 `HttpRequestFixLengthBodyPart` 类

添加 `last` 属性和覆盖 `isLast()` 方法：

```java
// 在类中添加属性
protected boolean last = false;

@Override
public boolean isLast()
{
    return last;
}

public void setLast(boolean last)
{
    this.last = last;
}
```

## 步骤 4：修改 `HttpRequestChunkedBodyPart` 类

添加 `last` 属性和覆盖 `isLast()` 方法：

```java
// 在类中添加属性
private boolean last = false;

@Override
public boolean isLast()
{
    return last;
}

public void setLast(boolean last)
{
    this.last = last;
}
```

## 步骤 5：修改 `HttpRequestPartDecoder` 解码器

### 5.1 修改 `parseRequestHeader` 方法

在 `parseBodyType()` 之后，如果是 `NO_BODY` 状态，设置 `reqHead.setLast(true)`：

```java
private boolean parseRequestHeader(ReadProcessorNode next)
{
    for (; lastCheck + 3 < accumulation.getWritePosi(); lastCheck++)
    {
        if (accumulation.get(lastCheck) == '\r' && accumulation.get(lastCheck + 1) == '\n' && accumulation.get(lastCheck + 2) == '\r' && accumulation.get(lastCheck + 3) == '\n')
        {
            int headEndPosi = lastCheck + 4;
            int headLength = headEndPosi - headStartPosi;
            accumulation.setReadPosi(headStartPosi);
            reqHead.setHeadBuffer(accumulation.slice(headLength));
            lastCheck = -1;
            HttpDecodeUtil.findAllHeaders(accumulation, reqHead::addHeader);
            HttpDecodeUtil.findContentLength(reqHead.getHeaders(), reqHead::setContentLength);
            parseBodyType();
            // 新增：如果没有 body，设置 last = true
            if (state == ParseState.NO_BODY)
            {
                reqHead.setLast(true);
            }
            next.fireRead(reqHead);
            // 新增：如果没有 body，直接重置状态，不再发送 End
            if (state == ParseState.NO_BODY)
            {
                resetState();
            }
            return accumulation != null && accumulation.remainRead() > 0;
        }
    }
    return false;
}
```

### 5.2 修改 `parseBodyFixLength` 方法

在最后一个 body part 上设置 `last = true`，不再发送 `HttpRequestPartEnd`：

```java
private boolean parseBodyFixLength(ReadProcessorNode next)
{
    if (accumulation == null || accumulation.remainRead() == 0)
    {
        return false;
    }
    int left   = reqHead.getContentLength() - bodyRead;
    int remain = accumulation.remainRead();
    if (remain >= left)
    {
        HttpRequestFixLengthBodyPart part = new HttpRequestFixLengthBodyPart();
        part.setLast(true);  // 新增：标记为最后一个 part
        if (remain > left)
        {
            part.setPart(accumulation.slice(left));
        }
        else
        {
            part.setPart(accumulation);
            accumulation = null;
        }
        next.fireRead(part);
        // 移除：不再发送 HttpRequestPartEnd
        resetState();
        return accumulation != null && accumulation.remainRead() > 0;
    }
    else
    {
        bodyRead += remain;
        HttpRequestFixLengthBodyPart part = new HttpRequestFixLengthBodyPart();
        part.setLast(false);  // 明确设置为非最后
        part.setPart(accumulation);
        accumulation = null;
        next.fireRead(part);
        return false;
    }
}
```

### 5.3 修改 `parseBodyChunked` 方法

当 `chunkSize == 0` 时设置 `last = true`，不再发送 `HttpRequestPartEnd`：

```java
private boolean parseBodyChunked(ReadProcessorNode next)
{
    if (chunkSize == -1)
    {
        int startPosi = accumulation.getReadPosi();
        for (int i = startPosi; i < accumulation.getWritePosi() - 1; i++)
        {
            if (i - startPosi > MAX_CHUNK_SIZE_LINE_LENGTH)
            {
                throw new IllegalStateException("Chunk size line exceeds " + MAX_CHUNK_SIZE_LINE_LENGTH + " bytes");
            }
            if (accumulation.get(i) == '\r' && accumulation.get(i + 1) == '\n')
            {
                chunkSize = Integer.parseInt(StandardCharsets.US_ASCII.decode(accumulation.readableByteBuffer(i)).toString().trim(), 16);
                chunkSizeLineLength = i + 2 - startPosi;
                break;
            }
        }
    }
    if (chunkSize == -1)
    {
        return false;
    }
    // 处理 chunk size 为 0 的情况（结束标志）
    if (chunkSize == 0)
    {
        int totalLength = chunkSizeLineLength + 2;
        if (accumulation.remainRead() < totalLength)
        {
            return false;
        }
        HttpRequestChunkedBodyPart part = new HttpRequestChunkedBodyPart();
        part.setHeadLength(chunkSizeLineLength);
        part.setChunkLength(totalLength);
        part.setPart(accumulation.slice(totalLength));
        part.setLast(true);  // 新增：标记为最后一个 part
        next.fireRead(part);
        // 移除：不再发送 HttpRequestPartEnd
        resetState();
        return accumulation != null && accumulation.remainRead() > 0;
    }

    int totalChunkLength = chunkSizeLineLength + chunkSize + 2;
    if (accumulation.remainRead() < totalChunkLength)
    {
        return false;
    }

    HttpRequestChunkedBodyPart part = new HttpRequestChunkedBodyPart();
    part.setHeadLength(chunkSizeLineLength);
    part.setChunkLength(totalChunkLength);
    part.setPart(accumulation.slice(totalChunkLength));
    part.setLast(false);  // 明确设置为非最后
    next.fireRead(part);
    chunkSize = -1;
    chunkSizeLineLength = -1;
    return true;
}
```

### 5.4 移除 `NO_BODY` 状态的处理分支

在 `process0` 方法中，`NO_BODY` 分支不再发送 `HttpRequestPartEnd`（已在 `parseRequestHeader` 中处理）：

原代码：
```java
case NO_BODY ->
{
    next.fireRead(new HttpRequestPartEnd());
    resetState();
    yield accumulation != null && accumulation.remainRead() > 0;
}
```

修改为：由于在 `parseRequestHeader` 中已经处理了 `NO_BODY` 的情况，此分支实际上不会被执行，可以移除或保留为空操作。建议直接移除该分支，因为 `NO_BODY` 状态在 `parseRequestHeader` 返回前就会被重置。

## 步骤 6：修改 `TransferProcessor` 类

移除对 `HttpRequestPartEnd` 的处理，改为在处理 head 和 body 时检查 `isLast()`：

```java
@Override
public void read(HttpRequestPart part, ReadProcessorNode next)
{
    if (part instanceof HttpRequestPartHead head)
    {
        processHead(head, next);
        // 新增：如果是无 body 请求，清除 currentHandler
        if (head.isLast())
        {
            currentHandler = null;
        }
    }
    else if (part instanceof HttpRequestFixLengthBodyPart || part instanceof HttpRequestChunkedBodyPart)
    {
        processBody(part, next);
        // 新增：如果是最后一个 body，清除 currentHandler
        if (part.isLast())
        {
            currentHandler = null;
        }
    }
    // 移除：不再处理 HttpRequestPartEnd
}

// 移除 processEnd 方法
```

## 步骤 7：修改 `ProxyHttpHandler` 类

### 7.1 修改 `process` 方法

移除对 `HttpRequestPartEnd` 的处理：

```java
@Override
public void process(HttpRequestPart part, Pipeline pipeline)
{
    if (part instanceof HttpRequestPartHead head)
    {
        processHead(head, pipeline);
    }
    else if (part instanceof HttpRequestFixLengthBodyPart || part instanceof HttpRequestChunkedBodyPart)
    {
        processBody(part, pipeline);
    }
    // 移除：不再处理 HttpRequestPartEnd
}
```

### 7.2 修改 `processHead` 方法

当 `head.isLast() == true` 时，设置 `requestEndReceived = true`：

在现有的 `processHead` 方法中，在 `httpConnection2.write(head, responsePart -> {...})` 调用之前添加：

```java
// 新增：如果是无 body 请求，直接标记请求已结束
if (head.isLast())
{
    requestEndReceived = true;
}
```

同时，对于“无 body”的场景，`head` 本身就是最后一个 part（请求已结束）。此时需要在 `processHead` 中触发一次“请求结束收尾逻辑”（见 7.4），用于：
- 当后端连接未成功建立时（如 borrow 超时），按“请求结束再返回 503”的约定，在此刻返回 503；
- 复用/迁移原 `processEnd` 中的清理与保护逻辑（避免误发 503 等）。

建议触发位置：在 `borrowConnection + write(head, ...)` 尝试完成之后（无论成功/失败），如果 `head.isLast()` 为 true，则调用一次 `onRequestEnd(pipeline)`，确保此时 `backendConnRef` 已体现“是否成功建立后端连接”。

### 7.3 修改 `processBody` 方法

当 `body.isLast() == true` 时，设置 `requestEndReceived = true`：

```java
protected void processBody(HttpRequestPart body, Pipeline pipeline)
{
    // 新增：最后一个 body 写入前置位，避免并发下 response End 先到导致误判
    if (body.isLast())
    {
        requestEndReceived = true;
    }
    if (dropCurrentRequest)
    {
        // 新增：请求结束时执行收尾逻辑（见 7.4）
        if (body.isLast())
        {
            onRequestEnd(pipeline);
        }
        body.close();
        return;
    }
    BackendConn ctx = backendConnRef.get();
    if (ctx == null)
    {
        // 新增：连接未建立时，按“请求结束再返回 503”的约定处理（见 7.4）
        if (body.isLast())
        {
            onRequestEnd(pipeline);
        }
        body.close();
        return;
    }
    ctx.conn().write(body);
    // 新增：如果是最后一个 body，触发请求结束收尾逻辑（见 7.4）
    if (body.isLast())
    {
        onRequestEnd(pipeline);
    }
}
```

### 7.4 移除 `processEnd` 方法

删除整个 `processEnd` 方法，因为不再有 `HttpRequestPartEnd`。

将原 `processEnd` 的关键逻辑迁移为一个“请求结束收尾方法”，并在 `head.isLast()`/`body.isLast()` 时调用：
- 清理 `dropCurrentRequest` / `responseEndedBeforeRequestEnd` 状态；
- 当后端连接未建立时，在“请求结束点”统一返回 503（按你的确认：等到请求结束再发送）；
- 若发生过 `responseEndedBeforeRequestEnd`，请求结束时只做清理，避免误发 503；
- 不在此处归还连接：连接仍以“收到后端 `HttpResponsePartEnd`”为准决定是否可复用。

示例（伪代码）：
```java
private void onRequestEnd(Pipeline pipeline)
{
    // 等价于原 processEnd 的收尾逻辑（不再依赖 HttpRequestPartEnd）
    if (dropCurrentRequest)
    {
        dropCurrentRequest            = false;
        responseEndedBeforeRequestEnd = false;
        return;
    }
    if (backendConnRef.get() == null)
    {
        if (responseEndedBeforeRequestEnd)
        {
            responseEndedBeforeRequestEnd = false;
            return;
        }
        // 没有连接，发送"连接过多"响应（保持原语义）
        sendErrorResponse(pipeline, 503, "Service Unavailable - Too Many Connections");
    }
}
```

## 步骤 8：修改 `AbstractIOResourceHandler` 类

移除对 `HttpRequestPartEnd` 的处理：

```java
@Override
public void process(HttpRequestPart part, Pipeline pipeline)
{
    // IO 资源处理器只处理 Head，忽略 Body
    if (part instanceof HttpRequestPartHead head)
    {
        String requestUrl = URLDecoder.decode(head.getPath(), StandardCharsets.UTF_8);
        requestUrl = HttpDecodeUtil.pureUrl(requestUrl);
        requestUrl = requestUrl.substring(len);
        if (StringUtil.isBlank(requestUrl))
        {
            requestUrl = "index.html";
        }
        else if (requestUrl.equals("/"))
        {
            requestUrl = "/index.html";
        }
        processHead(head, pipeline, requestUrl, HttpDecodeUtil.findContentType(requestUrl));
    }
    else
    {
        // Body 部分释放资源（包括 last=true 的 body）
        part.close();
    }
}
```

## 步骤 9：修改 `HttpRequestAggregator` 类

将对 `HttpRequestPartEnd` 的处理逻辑改为基于 `isLast()` 判断：

```java
@Override
public void read(HttpRequestPart data, ReadProcessorNode next)
{
    if (data instanceof HttpRequestPartHead)
    {
        head = (HttpRequestPartHead) data;
        // 新增：如果是无 body 请求，直接聚合并发送
        if (head.isLast())
        {
            fireAggregatedRequest(next);
        }
    }
    else if (data instanceof HttpRequestFixLengthBodyPart)
    {
        HttpRequestFixLengthBodyPart part = (HttpRequestFixLengthBodyPart) data;
        if (body == null)
        {
            body = part.getPart();
        }
        else
        {
            body.put(part.getPart());
            part.getPart().free();
        }
        // 新增：如果是最后一个 body，聚合并发送
        if (part.isLast())
        {
            fireAggregatedRequest(next);
        }
    }
    else if (data instanceof HttpRequestChunkedBodyPart)
    {
        HttpRequestChunkedBodyPart chunkedPart = (HttpRequestChunkedBodyPart) data;
        IoBuffer                   chunkBuffer = chunkedPart.getPart();
        int                        dataLength  = chunkedPart.getChunkLength() - chunkedPart.getHeadLength() - 2;
        chunkBuffer.setReadPosi(chunkedPart.getHeadLength());
        IoBuffer dataBuffer = chunkBuffer.slice(dataLength);
        chunkBuffer.free();
        if (body == null)
        {
            body = dataBuffer;
        }
        else
        {
            body.put(dataBuffer);
            dataBuffer.free();
        }
        // 新增：如果是最后一个 chunk，聚合并发送
        if (chunkedPart.isLast())
        {
            fireAggregatedRequest(next);
        }
    }
}

// 新增：提取聚合逻辑为独立方法
private void fireAggregatedRequest(ReadProcessorNode next)
{
    HttpRequest request = new HttpRequest();
    request.setMethod(head.getMethod());
    request.setPath(head.getPath());
    request.setVersion(head.getVersion());
    request.setHeaders(head.getHeaders());
    if (head.isChunked())
    {
        request.setContentLength(body == null ? 0 : body.remainRead());
    }
    else
    {
        request.setContentLength(head.getContentLength());
    }
    HttpDecodeUtil.findContentType(head.getHeaders(), request::setContentType);
    request.setBody(body);
    next.fireRead(request);
    head = null;
    body = null;
}
```

## 步骤 10：删除 `HttpRequestPartEnd` 类

删除文件 `src/main/java/cc/jfire/jnet/extend/http/dto/HttpRequestPartEnd.java`

# 待办列表

1. **修改 HttpRequestPart 接口** - 添加 `isLast()` 默认方法
2. **修改 HttpRequestPartHead 类** - 添加 `last` 属性和相关方法
3. **修改 HttpRequestFixLengthBodyPart 类** - 添加 `last` 属性和覆盖 `isLast()` 方法
4. **修改 HttpRequestChunkedBodyPart 类** - 添加 `last` 属性和覆盖 `isLast()` 方法
5. **修改 HttpRequestPartDecoder 解码器** - 在适当位置设置 `last` 属性，移除 `HttpRequestPartEnd` 的发送
6. **修改 TransferProcessor 类** - 移除对 `HttpRequestPartEnd` 的处理，基于 `isLast()` 清除 handler
7. **修改 ProxyHttpHandler 类** - 移除 `processEnd` 方法；在 `processHead`/`processBody` 基于 `isLast()` 前置位 `requestEndReceived`，并在请求结束点迁移原 `processEnd` 的收尾逻辑（含请求结束再发 503）
8. **修改 AbstractIOResourceHandler 类** - 移除对 `HttpRequestPartEnd` 的处理
9. **修改 HttpRequestAggregator 类** - 基于 `isLast()` 进行聚合，移除对 `HttpRequestPartEnd` 的处理
10. **删除 HttpRequestPartEnd 类** - 删除该类文件

# 需要修改或新增的类

## 需要修改的类

1. `cc.jfire.jnet.extend.http.dto.HttpRequestPart` - 添加 `isLast()` 默认方法
2. `cc.jfire.jnet.extend.http.dto.HttpRequestPartHead` - 添加 `last` 属性
3. `cc.jfire.jnet.extend.http.dto.HttpRequestFixLengthBodyPart` - 添加 `last` 属性
4. `cc.jfire.jnet.extend.http.dto.HttpRequestChunkedBodyPart` - 添加 `last` 属性
5. `cc.jfire.jnet.extend.http.coder.HttpRequestPartDecoder` - 修改解码逻辑，设置 `last` 属性
6. `cc.jfire.jnet.extend.reverse.proxy.TransferProcessor` - 移除 `HttpRequestPartEnd` 处理
7. `cc.jfire.jnet.extend.reverse.proxy.api.handler.ProxyHttpHandler` - 移除 `processEnd`，修改 `requestEndReceived` 设置逻辑
8. `cc.jfire.jnet.extend.reverse.proxy.api.handler.AbstractIOResourceHandler` - 移除 `HttpRequestPartEnd` 处理
9. `cc.jfire.jnet.extend.http.coder.HttpRequestAggregator` - 基于 `isLast()` 聚合

## 需要删除的类

1. `cc.jfire.jnet.extend.http.dto.HttpRequestPartEnd` - 废弃并删除
