# 目标

1. 提供一个解码器，可以支持 websocket
2. 提供一个编码器，支持 websocket

# 核心思路

1. 参考现有的 `HttpRequestPartDecoder` 实现模式，创建 `WebSocketFrameDecoder` 解码器
2. 解码器继承 `AbstractDecoder`，使用状态机模式解析 WebSocket 帧
3. 定义 WebSocket 帧的 DTO 类 `WebSocketFrame`，用于承载解码后的数据
4. WebSocket 帧格式遵循 RFC 6455 规范：
   - 第1字节：FIN(1bit) + RSV(3bit) + Opcode(4bit)
   - 第2字节：MASK(1bit) + Payload Length(7bit)
   - 扩展长度：若 Payload Length=126，后续2字节为实际长度；若=127，后续8字节为实际长度
   - Masking Key：若 MASK=1，后续4字节为掩码密钥
   - Payload Data：实际数据（若有掩码需解码）
5. 参考现在的HttpRespEncoder,创建`WebSocketFrameEncoder` 编码器，编码器主要处理 `WebSocketFrame`，同时允许 `IoBuffer` 透传
6. 创建 `WebSocketUpgradeDecoder` 继承 `HttpRequestPartDecoder`，通过重写 `doProcessRequestHead` 方法实现 WebSocket 升级检测、自动发送 101 响应，并切换到透传模式
7. 修改 `HttpRequestPartDecoder`，将原有的 `beforeRequestHeadFired` 钩子及后续处理逻辑合并为 `doProcessRequestHead` 方法，便于子类重写
8. 提供 `WebSocketHandshakeUtil` 工具类，用于计算 `Sec-WebSocket-Accept` 等握手相关逻辑
9. 场景边界说明：
   - `WebSocketUpgradeDecoder` 用于框架提供给业务方的 WebSocket 终端服务端：负责握手检测、自动响应 101，握手完成后进入 WebSocket 帧协议处理链路
   - 反向代理 WebSocket 透传与本次 `WebSocketUpgradeDecoder` 无关：反向代理场景继续沿用现有 `HttpRequestPartSupportWebSocketDecoderWithPassThough` 的透传模式（不做握手响应、不做帧解码）

# 详细实现思路

## 0. WebSocket 握手流程设计

### 0.1 握手流程概述
WebSocket 连接需要先通过 HTTP 协议进行握手升级：
1. 客户端发送 HTTP 升级请求（包含 `Upgrade: websocket` 和 `Sec-WebSocket-Key`）
2. 服务端验证请求，返回 101 Switching Protocols 响应
3. 握手成功后，后续数据按 WebSocket 帧协议传输

### 0.2 WebSocketUpgradeDecoder 设计方案

通过继承 `HttpRequestPartDecoder` 实现 WebSocket 升级支持，不直接修改父类的核心逻辑：

**适用场景说明**：
- `WebSocketUpgradeDecoder`：业务 WebSocket 终端服务端使用（自动回 101 并切换到后续 WebSocket 帧解码/编码链路）
- 反向代理 WebSocket：不使用本类，仍采用现有 `HttpRequestPartSupportWebSocketDecoderWithPassThough` 进入透传模式，由反向代理后续处理器对 `IoBuffer` 进行透传转发

**父类改动**（最小化改动）：
- 将原有的 `beforeRequestHeadFired` 钩子及后续处理逻辑（`fireRead`、`resetState`、`compact`）合并为 `doProcessRequestHead` 方法
- 删除 `beforeRequestHeadFired` 方法
- 子类可重写 `doProcessRequestHead` 方法来自定义请求头的处理逻辑

**子类 `WebSocketUpgradeDecoder` 职责**：
- 重写 `doProcessRequestHead` 方法，检测 WebSocket 升级请求
- 如果是升级请求：发送 101 响应，释放 head 资源，进入透传模式
- 如果不是升级请求：调用 `super.doProcessRequestHead()`，走正常 HTTP 流程
- 重写 `process0` 方法，在透传模式下直接传递 `IoBuffer`

### 0.3 WebSocketHandshakeUtil 工具类
提供以下静态方法：
- `isWebSocketUpgrade(HttpRequestPartHead)`: 判断是否为 WebSocket 升级请求
- `computeAcceptKey(String secWebSocketKey)`: 根据 RFC 6455 计算 `Sec-WebSocket-Accept` 值
- `buildUpgradeResponse(HttpRequestPartHead, BufferAllocator)`: 构建 101 响应

## 1. WebSocketFrame DTO 设计

`WebSocketFrame` 作为 WebSocket 帧的数据传输对象，需要包含以下信息：
- **fin**: 布尔值，表示是否为消息的最后一帧（FIN=1）
- **opcode**: 操作码（0=继续帧, 1=文本帧, 2=二进制帧, 8=关闭帧, 9=Ping帧, 10=Pong帧）
- **masked**: 布尔值，表示 payload 是否被掩码
- **payload**: IoBuffer，承载实际数据（已解码后的数据）
- **closeCode**: 关闭状态码（仅 Close 帧使用）
- **closeReason**: 关闭原因（仅 Close 帧使用）
- **last**: 布尔值，表示是否为消息流的最后一部分（组装后的完整消息）

## 2. WebSocketFrameDecoder 解码器设计

### 2.1 继承关系
- 继承 `AbstractDecoder`，复用累积缓冲区机制
- 实现状态机模式解析 WebSocket 帧

### 2.2 状态机设计
```
FRAME_HEADER    -> 解析第1-2字节（FIN/Opcode/MASK/PayloadLen）
EXTENDED_LENGTH -> 解析扩展长度（2字节或8字节）
MASKING_KEY     -> 解析4字节掩码（如果MASK=1）
PAYLOAD         -> 读取并解码payload数据
```

### 2.3 模式配置
通过构造参数 `boolean serverMode` 决定：
- **serverMode=true（服务端模式）**：要求接收的帧 MASK=1，否则抛出协议错误
- **serverMode=false（客户端模式）**：要求接收的帧 MASK=0，否则抛出协议错误

### 2.4 分片消息组装
- 当收到 FIN=0 的帧时，缓存到分片列表
- 收到 opcode=0（继续帧）时，继续追加到分片列表
- 收到 FIN=1 的继续帧时，组装所有分片为完整消息后输出
- 控制帧（opcode >= 8）不能被分片，必须 FIN=1

### 2.5 控制帧自动响应
解码器内部自动处理控制帧：
- **Ping帧**：通过 `next.pipeline().fireWrite()` 自动发送 Pong 响应
- **Close帧**：解析关闭状态码和原因，自动发送 Close 响应，然后关闭连接
- 控制帧处理完成后，仍然向上层传递该帧（让上层知晓事件）

### 2.6 掩码解码算法
```java
for (int i = 0; i < payloadLength; i++) {
    decoded[i] = (byte) (encoded[i] ^ maskingKey[i % 4]);
}
```

## 3. WebSocketFrameEncoder 编码器设计

### 3.1 实现接口
- 实现 `WriteProcessor<Object>` 接口
- 仅处理 `WebSocketFrame` 类型

### 3.2 模式配置
通过构造参数 `boolean clientMode` 决定：
- **clientMode=true（客户端模式）**：发送的帧需要添加掩码（MASK=1）
- **clientMode=false（服务端模式）**：发送的帧不添加掩码（MASK=0）

### 3.3 编码流程
1. 写入第1字节：FIN(1bit) + RSV(3bit=0) + Opcode(4bit)
2. 写入第2字节及扩展长度：
   - payload <= 125: 直接写入长度
   - payload <= 65535: 写入126 + 2字节扩展长度
   - payload > 65535: 写入127 + 8字节扩展长度
3. 如果是客户端模式，生成4字节随机掩码并写入
4. 写入 payload（客户端模式需要先进行掩码编码）

# 实施步骤

## 步骤1：创建 WebSocketHandshakeUtil 工具类

**文件位置**: `src/main/java/cc/jfire/jnet/extend/websocket/util/WebSocketHandshakeUtil.java`

```java
package cc.jfire.jnet.extend.websocket.util;

import cc.jfire.jnet.common.buffer.allocator.BufferAllocator;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.jnet.extend.http.dto.HttpRequestPartHead;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import java.util.Map;

public class WebSocketHandshakeUtil {

    /**
     * WebSocket GUID，RFC 6455 规定的固定值
     */
    private static final String WEBSOCKET_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";

    /**
     * 判断是否为 WebSocket 升级请求
     */
    public static boolean isWebSocketUpgrade(HttpRequestPartHead head) {
        if (head == null || head.getHeaders() == null) {
            return false;
        }
        Map<String, String> headers = head.getHeaders();

        // 检查必要的头部
        String upgrade = getHeaderIgnoreCase(headers, "Upgrade");
        String connection = getHeaderIgnoreCase(headers, "Connection");
        String secWebSocketKey = getHeaderIgnoreCase(headers, "Sec-WebSocket-Key");
        String secWebSocketVersion = getHeaderIgnoreCase(headers, "Sec-WebSocket-Version");

        return "websocket".equalsIgnoreCase(upgrade)
                && connection != null && connection.toLowerCase().contains("upgrade")
                && secWebSocketKey != null && !secWebSocketKey.isEmpty()
                && "13".equals(secWebSocketVersion);
    }

    /**
     * 获取 Sec-WebSocket-Key
     */
    public static String getSecWebSocketKey(HttpRequestPartHead head) {
        return getHeaderIgnoreCase(head.getHeaders(), "Sec-WebSocket-Key");
    }

    /**
     * 根据 RFC 6455 计算 Sec-WebSocket-Accept 值
     * Accept = Base64(SHA-1(Sec-WebSocket-Key + GUID))
     */
    public static String computeAcceptKey(String secWebSocketKey) {
        try {
            String combined = secWebSocketKey + WEBSOCKET_GUID;
            MessageDigest sha1 = MessageDigest.getInstance("SHA-1");
            byte[] hash = sha1.digest(combined.getBytes(StandardCharsets.US_ASCII));
            return Base64.getEncoder().encodeToString(hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("SHA-1 algorithm not available", e);
        }
    }

    /**
     * 构建 101 Switching Protocols 响应
     */
    public static IoBuffer buildUpgradeResponse(HttpRequestPartHead head, BufferAllocator allocator) {
        String secWebSocketKey = getSecWebSocketKey(head);
        String acceptKey = computeAcceptKey(secWebSocketKey);

        StringBuilder sb = new StringBuilder();
        sb.append("HTTP/1.1 101 Switching Protocols\r\n");
        sb.append("Upgrade: websocket\r\n");
        sb.append("Connection: Upgrade\r\n");
        sb.append("Sec-WebSocket-Accept: ").append(acceptKey).append("\r\n");
        sb.append("\r\n");

        byte[] responseBytes = sb.toString().getBytes(StandardCharsets.US_ASCII);
        IoBuffer buffer = allocator.allocate(responseBytes.length);
        buffer.put(responseBytes);
        return buffer;
    }

    /**
     * 忽略大小写获取 header 值
     */
    private static String getHeaderIgnoreCase(Map<String, String> headers, String name) {
        for (Map.Entry<String, String> entry : headers.entrySet()) {
            if (entry.getKey().equalsIgnoreCase(name)) {
                return entry.getValue();
            }
        }
        return null;
    }
}
```

## 步骤2：修改 HttpRequestPartDecoder 支持子类扩展

**文件位置**: `src/main/java/cc/jfire/jnet/extend/http/coder/HttpRequestPartDecoder.java`

**改动内容**:

1. 将原有的 `beforeRequestHeadFired` 钩子及后续处理逻辑合并为 `doProcessRequestHead` 方法
2. 子类可重写 `doProcessRequestHead` 方法来自定义请求头处理逻辑
3. 删除 `beforeRequestHeadFired` 方法

```java
// === 修改 parseRequestHeader 方法，提取 doProcessRequestHead ===
private boolean parseRequestHeader(ReadProcessorNode next)
{
    for (; lastCheck + 3 < accumulation.getWritePosi(); lastCheck++)
    {
        if (accumulation.get(lastCheck) == '\r' && accumulation.get(lastCheck + 1) == '\n' && accumulation.get(lastCheck + 2) == '\r' && accumulation.get(lastCheck + 3) == '\n')
        {
            int headEndPosi = lastCheck + 4;
            int headLength  = headEndPosi - headStartPosi;
            lastCheck = -1;
            HttpDecodeUtil.findAllHeaders(accumulation, reqHead::addHeader);
            HttpDecodeUtil.findContentLength(reqHead.getHeaders(), reqHead::setContentLength);
            accumulation.setReadPosi(headStartPosi);
            if (accumulation.remainRead() == headLength)
            {
                reqHead.setHeadBuffer(accumulation);
                accumulation = null;
            }
            else
            {
                reqHead.setHeadBuffer(accumulation.slice(headLength));
            }
            parseBodyType();
            // 如果没有 body，设置 last = true
            if (state == ParseState.NO_BODY)
            {
                reqHead.setLast(true);
            }
            // === 调用可重写的处理方法 ===
            return doProcessRequestHead(next, reqHead);
        }
    }
    return false;
}

// === 新增：可重写的请求头处理方法 ===
/**
 * 处理解析完成的请求头。
 * 子类可重写此方法来自定义请求头的处理逻辑（如 WebSocket 升级）。
 *
 * @param next 下一个处理节点
 * @param head 解析完成的请求头
 * @return true 表示需要继续处理（accumulation 中还有数据），false 表示处理完成
 */
protected boolean doProcessRequestHead(ReadProcessorNode next, HttpRequestPartHead head)
{
    next.fireRead(head);
    // 如果没有 body，直接重置状态
    if (state == ParseState.NO_BODY)
    {
        resetState();
    }
    if (accumulation == null)
    {
        return false;
    }
    else
    {
        accumulation.compact();
        return true;
    }
}

// === 删除原有的 beforeRequestHeadFired 方法 ===
```

## 步骤3：修改 HttpRequestPartSupportWebSocketDecoderWithPassThough 适配 doProcessRequestHead

**背景说明**：
- 当前项目中已存在反向代理 WebSocket 透传解码器 `HttpRequestPartSupportWebSocketDecoderWithPassThough`
- 该类目前通过覆写 `beforeRequestHeadFired` 来检测 `Upgrade: websocket` 并进入透传模式
- 本计划在步骤2中会删除 `beforeRequestHeadFired`，因此需要同步迁移该子类实现，否则会编译失败并影响反向代理 WebSocket 透传

**文件位置**: `src/main/java/cc/jfire/jnet/extend/http/coder/HttpRequestPartSupportWebSocketDecoderWithPassThough.java`

**改动内容**：
1. 将 `beforeRequestHeadFired(ReadProcessorNode next, HttpRequestPartHead head)` 的逻辑迁移到 `doProcessRequestHead(ReadProcessorNode next, HttpRequestPartHead head)`
2. 在 `doProcessRequestHead` 中：
   - 检测 `Upgrade: websocket`（header name 已规范化为 `Upgrade`）
   - 命中后设置 `head.setWebSocketUpgrade(true)` 并将 `webSocketMode=true`
   - 调用 `super.doProcessRequestHead(next, head)`，确保反向代理链路仍能收到 `HttpRequestPartHead`（下游如 `TransferProcessor` 会依赖 `head.isWebSocketUpgrade()`）
3. `process0` 中的透传逻辑保持不变：进入 `webSocketMode` 后直接透传 `IoBuffer`

```java
@Override
protected boolean doProcessRequestHead(ReadProcessorNode next, HttpRequestPartHead head)
{
    String upgrade = head.getHeaders().get("Upgrade");
    if ("websocket".equalsIgnoreCase(upgrade))
    {
        head.setWebSocketUpgrade(true);
        webSocketMode = true;
    }
    return super.doProcessRequestHead(next, head);
}
```

## 步骤4：创建 WebSocketUpgradeDecoder 解码器

**文件位置**: `src/main/java/cc/jfire/jnet/extend/websocket/coder/WebSocketUpgradeDecoder.java`

```java
package cc.jfire.jnet.extend.websocket.coder;

import cc.jfire.jnet.common.api.ReadProcessorNode;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.jnet.extend.http.coder.HttpRequestPartDecoder;
import cc.jfire.jnet.extend.http.dto.HttpRequestPartHead;
import cc.jfire.jnet.extend.websocket.util.WebSocketHandshakeUtil;
import lombok.extern.slf4j.Slf4j;

/**
 * 支持 WebSocket 升级的 HTTP 请求解码器。
 * 继承 HttpRequestPartDecoder，在检测到 WebSocket 握手请求后：
 * 1. 自动发送 101 Switching Protocols 响应
 * 2. 不向后传递 HTTP 请求头
 * 3. 切换到透传模式，后续数据作为 IoBuffer 直接传递给下一个处理器（WebSocketFrameDecoder）
 */
@Slf4j
public class WebSocketUpgradeDecoder extends HttpRequestPartDecoder
{
    private boolean webSocketMode = false;

    @Override
    protected void process0(ReadProcessorNode next)
    {
        // 如果已进入 WebSocket 透传模式，直接透传数据
        if (webSocketMode)
        {
            if (accumulation != null && accumulation.remainRead() > 0)
            {
                IoBuffer data = accumulation;
                accumulation = null;
                next.fireRead(data);
            }
            return;
        }
        // 否则使用父类的 HTTP 解析逻辑
        super.process0(next);
    }

    @Override
    protected boolean doProcessRequestHead(ReadProcessorNode next, HttpRequestPartHead head)
    {
        // 检查是否是 WebSocket 握手请求
        if (WebSocketHandshakeUtil.isWebSocketUpgrade(head))
        {
            // 发送 101 Switching Protocols 响应
            IoBuffer upgradeResponse = WebSocketHandshakeUtil.buildUpgradeResponse(
                    head, next.pipeline().allocator());
            next.pipeline().fireWrite(upgradeResponse);

            // 释放请求头资源
            head.close();

            // 进入 WebSocket 透传模式
            webSocketMode = true;

            log.debug("WebSocket upgrade completed, switching to passthrough mode");

            // 返回是否需要继续处理
            if (accumulation == null)
            {
                return false;
            }
            else
            {
                accumulation.compact();
                return true;
            }
        }

        // 非 WebSocket 请求，调用父类默认处理
        return super.doProcessRequestHead(next, head);
    }
}
```

## 步骤5：创建 WebSocketFrame DTO 类

**文件位置**: `src/main/java/cc/jfire/jnet/extend/websocket/dto/WebSocketFrame.java`

```java
package cc.jfire.jnet.extend.websocket.dto;

import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import lombok.Data;

@Data
public class WebSocketFrame {
    // 操作码常量
    public static final int OPCODE_CONTINUATION = 0;
    public static final int OPCODE_TEXT = 1;
    public static final int OPCODE_BINARY = 2;
    public static final int OPCODE_CLOSE = 8;
    public static final int OPCODE_PING = 9;
    public static final int OPCODE_PONG = 10;

    /**
     * 是否为消息的最后一帧
     */
    private boolean fin = true;

    /**
     * 操作码
     */
    private int opcode;

    /**
     * payload是否被掩码
     */
    private boolean masked;

    /**
     * 实际数据（已解码）
     */
    private IoBuffer payload;

    /**
     * 关闭状态码（仅Close帧使用）
     */
    private int closeCode;

    /**
     * 关闭原因（仅Close帧使用）
     */
    private String closeReason;

    /**
     * 是否为消息流的最后一部分
     */
    private boolean last = true;

    /**
     * 判断是否为控制帧
     */
    public boolean isControlFrame() {
        return opcode >= 8;
    }

    /**
     * 释放payload资源
     */
    public void free() {
        if (payload != null) {
            payload.free();
            payload = null;
        }
    }

    /**
     * 创建Pong响应帧
     */
    public static WebSocketFrame createPong(IoBuffer payload) {
        WebSocketFrame frame = new WebSocketFrame();
        frame.setFin(true);
        frame.setOpcode(OPCODE_PONG);
        frame.setPayload(payload);
        return frame;
    }

    /**
     * 创建Close响应帧
     */
    public static WebSocketFrame createClose(int code, String reason) {
        WebSocketFrame frame = new WebSocketFrame();
        frame.setFin(true);
        frame.setOpcode(OPCODE_CLOSE);
        frame.setCloseCode(code);
        frame.setCloseReason(reason);
        return frame;
    }
}
```

## 步骤6：创建 WebSocketFrameDecoder 解码器

**文件位置**: `src/main/java/cc/jfire/jnet/extend/websocket/coder/WebSocketFrameDecoder.java`

```java
package cc.jfire.jnet.extend.websocket.coder;

import cc.jfire.jnet.common.api.ReadProcessorNode;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.jnet.common.coder.AbstractDecoder;
import cc.jfire.jnet.extend.websocket.dto.WebSocketFrame;
import lombok.extern.slf4j.Slf4j;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

@Slf4j
public class WebSocketFrameDecoder extends AbstractDecoder {

    /**
     * true=服务端模式（要求MASK=1），false=客户端模式（要求MASK=0）
     */
    private final boolean serverMode;

    private DecodeState state = DecodeState.FRAME_HEADER;

    // 当前帧解析状态
    private boolean fin;
    private int opcode;
    private boolean masked;
    private long payloadLength;
    private byte[] maskingKey = new byte[4];
    private int extendedLengthBytes; // 0, 2, 或 8

    // 分片消息缓存
    private List<IoBuffer> fragmentBuffers = new ArrayList<>();
    private int fragmentOpcode = -1;

    public WebSocketFrameDecoder(boolean serverMode) {
        this.serverMode = serverMode;
    }

    @Override
    protected void process0(ReadProcessorNode next) {
        boolean continueProcessing;
        do {
            continueProcessing = switch (state) {
                case FRAME_HEADER -> parseFrameHeader();
                case EXTENDED_LENGTH -> parseExtendedLength();
                case MASKING_KEY -> parseMaskingKey();
                case PAYLOAD -> parsePayload(next);
            };
        } while (continueProcessing);
    }

    private boolean parseFrameHeader() {
        if (accumulation == null || accumulation.remainRead() < 2) {
            return false;
        }

        byte b1 = accumulation.get();
        byte b2 = accumulation.get();

        fin = (b1 & 0x80) != 0;
        opcode = b1 & 0x0F;
        masked = (b2 & 0x80) != 0;
        payloadLength = b2 & 0x7F;

        // 校验MASK
        if (serverMode && !masked) {
            throw new IllegalStateException("服务端模式要求客户端发送的帧必须有掩码");
        }
        if (!serverMode && masked) {
            throw new IllegalStateException("客户端模式要求服务端发送的帧不能有掩码");
        }

        // 控制帧校验
        if (opcode >= 8) {
            if (!fin) {
                throw new IllegalStateException("控制帧不能被分片");
            }
            if (payloadLength > 125) {
                throw new IllegalStateException("控制帧payload不能超过125字节");
            }
        }

        // 确定扩展长度
        if (payloadLength == 126) {
            extendedLengthBytes = 2;
            state = DecodeState.EXTENDED_LENGTH;
        } else if (payloadLength == 127) {
            extendedLengthBytes = 8;
            state = DecodeState.EXTENDED_LENGTH;
        } else {
            extendedLengthBytes = 0;
            state = masked ? DecodeState.MASKING_KEY : DecodeState.PAYLOAD;
        }

        return true;
    }

    private boolean parseExtendedLength() {
        if (accumulation.remainRead() < extendedLengthBytes) {
            return false;
        }

        if (extendedLengthBytes == 2) {
            payloadLength = accumulation.getShort() & 0xFFFF;
        } else {
            payloadLength = accumulation.getLong();
        }

        state = masked ? DecodeState.MASKING_KEY : DecodeState.PAYLOAD;
        return true;
    }

    private boolean parseMaskingKey() {
        if (accumulation.remainRead() < 4) {
            return false;
        }

        accumulation.get(maskingKey);
        state = DecodeState.PAYLOAD;
        return true;
    }

    private boolean parsePayload(ReadProcessorNode next) {
        if (accumulation.remainRead() < payloadLength) {
            return false;
        }

        // 读取payload
        IoBuffer payload = null;
        if (payloadLength > 0) {
            payload = accumulation.slice((int) payloadLength);

            // 如果有掩码，进行解码
            if (masked) {
                unmask(payload);
            }
        }

        // 处理帧
        handleFrame(next, payload);

        // 重置状态准备解析下一帧
        resetParseState();

        return accumulation != null && accumulation.remainRead() > 0;
    }

    private void unmask(IoBuffer payload) {
        int readPosi = payload.getReadPosi();
        int length = payload.remainRead();
        for (int i = 0; i < length; i++) {
            byte original = payload.get(readPosi + i);
            byte decoded = (byte) (original ^ maskingKey[i % 4]);
            payload.put(decoded, readPosi + i);
        }
    }

    private void handleFrame(ReadProcessorNode next, IoBuffer payload) {
        // 处理控制帧
        if (opcode >= 8) {
            handleControlFrame(next, payload);
            return;
        }

        // 处理数据帧（分片组装）
        if (opcode != WebSocketFrame.OPCODE_CONTINUATION) {
            // 新消息的第一帧
            fragmentOpcode = opcode;
            fragmentBuffers.clear();
        }

        if (payload != null) {
            fragmentBuffers.add(payload);
        }

        if (fin) {
            // 消息完整，组装并输出
            WebSocketFrame frame = new WebSocketFrame();
            frame.setFin(true);
            frame.setOpcode(fragmentOpcode);
            frame.setLast(true);

            if (fragmentBuffers.size() == 1) {
                frame.setPayload(fragmentBuffers.get(0));
            } else if (fragmentBuffers.size() > 1) {
                // 合并所有分片
                frame.setPayload(mergeBuffers(next));
            }

            fragmentBuffers.clear();
            fragmentOpcode = -1;

            next.fireRead(frame);
        }
    }

    private IoBuffer mergeBuffers(ReadProcessorNode next) {
        int totalLength = 0;
        for (IoBuffer buf : fragmentBuffers) {
            totalLength += buf.remainRead();
        }

        IoBuffer merged = next.pipeline().allocator().allocate(totalLength);
        for (IoBuffer buf : fragmentBuffers) {
            merged.put(buf);
            buf.free();
        }
        return merged;
    }

    private void handleControlFrame(ReadProcessorNode next, IoBuffer payload) {
        WebSocketFrame frame = new WebSocketFrame();
        frame.setFin(true);
        frame.setOpcode(opcode);
        frame.setPayload(payload);

        switch (opcode) {
            case WebSocketFrame.OPCODE_PING -> {
                // 自动发送Pong响应
                WebSocketFrame pong = WebSocketFrame.createPong(payload);
                next.pipeline().fireWrite(pong);
                // 传递Ping帧给上层（payload已交给pong，创建新帧）
                WebSocketFrame pingNotify = new WebSocketFrame();
                pingNotify.setFin(true);
                pingNotify.setOpcode(WebSocketFrame.OPCODE_PING);
                next.fireRead(pingNotify);
            }
            case WebSocketFrame.OPCODE_PONG -> {
                // 直接传递给上层
                next.fireRead(frame);
            }
            case WebSocketFrame.OPCODE_CLOSE -> {
                // 解析关闭状态码和原因
                int closeCode = 1000;
                String closeReason = "";
                if (payload != null && payload.remainRead() >= 2) {
                    closeCode = payload.getShort() & 0xFFFF;
                    if (payload.remainRead() > 0) {
                        byte[] reasonBytes = new byte[payload.remainRead()];
                        payload.get(reasonBytes);
                        closeReason = new String(reasonBytes, StandardCharsets.UTF_8);
                    }
                }

                frame.setCloseCode(closeCode);
                frame.setCloseReason(closeReason);

                // 自动发送Close响应
                WebSocketFrame closeResp = WebSocketFrame.createClose(closeCode, closeReason);
                next.pipeline().fireWrite(closeResp);

                // 传递Close帧给上层
                next.fireRead(frame);

                // 关闭输入
                next.pipeline().shutdownInput();
            }
        }
    }

    private void resetParseState() {
        state = DecodeState.FRAME_HEADER;
        fin = false;
        opcode = 0;
        masked = false;
        payloadLength = 0;
        extendedLengthBytes = 0;

        if (accumulation != null && accumulation.remainRead() > 0) {
            accumulation.compact();
        }
    }

    @Override
    public void readFailed(Throwable e, ReadProcessorNode next) {
        // 清理分片缓存
        for (IoBuffer buf : fragmentBuffers) {
            buf.free();
        }
        fragmentBuffers.clear();
        super.readFailed(e, next);
    }

    enum DecodeState {
        FRAME_HEADER,
        EXTENDED_LENGTH,
        MASKING_KEY,
        PAYLOAD
    }
}
```

## 步骤7：创建 WebSocketFrameEncoder 编码器

**文件位置**: `src/main/java/cc/jfire/jnet/extend/websocket/coder/WebSocketFrameEncoder.java`

```java
package cc.jfire.jnet.extend.websocket.coder;

import cc.jfire.jnet.common.api.WriteProcessor;
import cc.jfire.jnet.common.api.WriteProcessorNode;
import cc.jfire.jnet.common.buffer.allocator.BufferAllocator;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.jnet.extend.websocket.dto.WebSocketFrame;
import lombok.extern.slf4j.Slf4j;

import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;

@Slf4j
public class WebSocketFrameEncoder implements WriteProcessor<Object> {

    private final BufferAllocator allocator;

    /**
     * true=客户端模式（发送时添加掩码），false=服务端模式（发送时不加掩码）
     */
    private final boolean clientMode;

    private final SecureRandom random = new SecureRandom();

    public WebSocketFrameEncoder(BufferAllocator allocator, boolean clientMode) {
        this.allocator = allocator;
        this.clientMode = clientMode;
    }

    @Override
    public void write(Object obj, WriteProcessorNode next) {
        if (obj instanceof WebSocketFrame frame) {
            IoBuffer buffer = encodeFrame(frame);
            next.fireWrite(buffer);
        } else if (obj instanceof IoBuffer) {
            // 允许直接透传IoBuffer，便于与pipeline其他组件协作
            next.fireWrite(obj);
        } else {
            throw new IllegalArgumentException("WebSocketFrameEncoder不支持类型: " + obj.getClass());
        }
    }

    private IoBuffer encodeFrame(WebSocketFrame frame) {
        // 计算需要的缓冲区大小
        int payloadLength = 0;
        IoBuffer payload = frame.getPayload();

        // 处理Close帧的特殊payload
        byte[] closePayload = null;
        if (frame.getOpcode() == WebSocketFrame.OPCODE_CLOSE) {
            closePayload = buildClosePayload(frame);
            payloadLength = closePayload.length;
        } else if (payload != null) {
            payloadLength = payload.remainRead();
        }

        int headerSize = 2;
        if (payloadLength > 125 && payloadLength <= 65535) {
            headerSize += 2;
        } else if (payloadLength > 65535) {
            headerSize += 8;
        }
        if (clientMode) {
            headerSize += 4; // masking key
        }

        IoBuffer buffer = allocator.allocate(headerSize + payloadLength);

        // 第1字节: FIN + RSV + Opcode
        byte b1 = (byte) ((frame.isFin() ? 0x80 : 0) | (frame.getOpcode() & 0x0F));
        buffer.put(b1);

        // 第2字节: MASK + Payload Length
        byte b2 = (byte) (clientMode ? 0x80 : 0);
        if (payloadLength <= 125) {
            b2 |= payloadLength;
            buffer.put(b2);
        } else if (payloadLength <= 65535) {
            b2 |= 126;
            buffer.put(b2);
            buffer.putShort((short) payloadLength);
        } else {
            b2 |= 127;
            buffer.put(b2);
            buffer.putLong(payloadLength);
        }

        // Masking Key (仅客户端模式)
        byte[] maskingKey = null;
        if (clientMode) {
            maskingKey = new byte[4];
            random.nextBytes(maskingKey);
            buffer.put(maskingKey);
        }

        // Payload
        if (closePayload != null) {
            if (clientMode) {
                // 掩码编码
                for (int i = 0; i < closePayload.length; i++) {
                    buffer.put((byte) (closePayload[i] ^ maskingKey[i % 4]));
                }
            } else {
                buffer.put(closePayload);
            }
        } else if (payload != null && payloadLength > 0) {
            if (clientMode) {
                // 掩码编码
                int readPosi = payload.getReadPosi();
                for (int i = 0; i < payloadLength; i++) {
                    byte original = payload.get(readPosi + i);
                    buffer.put((byte) (original ^ maskingKey[i % 4]));
                }
            } else {
                buffer.put(payload, payloadLength);
            }
        }

        return buffer;
    }

    private byte[] buildClosePayload(WebSocketFrame frame) {
        int closeCode = frame.getCloseCode();
        String closeReason = frame.getCloseReason();

        if (closeCode == 0 && (closeReason == null || closeReason.isEmpty())) {
            return new byte[0];
        }

        byte[] reasonBytes = (closeReason != null) ? closeReason.getBytes(StandardCharsets.UTF_8) : new byte[0];
        byte[] result = new byte[2 + reasonBytes.length];
        result[0] = (byte) ((closeCode >> 8) & 0xFF);
        result[1] = (byte) (closeCode & 0xFF);
        System.arraycopy(reasonBytes, 0, result, 2, reasonBytes.length);
        return result;
    }
}
```

# 待办列表

1. [ ] 创建 WebSocket 包目录结构 `src/main/java/cc/jfire/jnet/extend/websocket/dto/`、`src/main/java/cc/jfire/jnet/extend/websocket/coder/` 和 `src/main/java/cc/jfire/jnet/extend/websocket/util/`
2. [ ] 创建 `WebSocketHandshakeUtil` 握手工具类
3. [ ] 修改 `HttpRequestPartDecoder`，将 `beforeRequestHeadFired` 及后续逻辑合并为 `doProcessRequestHead` 方法
4. [ ] 修改 `HttpRequestPartSupportWebSocketDecoderWithPassThough` 适配 `doProcessRequestHead`（反向代理 WebSocket 透传）
5. [ ] 创建 `WebSocketUpgradeDecoder` 解码器类（终端服务端场景，继承 `HttpRequestPartDecoder`）
6. [ ] 创建 `WebSocketFrame` DTO 类
7. [ ] 创建 `WebSocketFrameDecoder` 解码器类
8. [ ] 创建 `WebSocketFrameEncoder` 编码器类（允许 `IoBuffer` 透传）
9. [ ] 编写单元测试验证握手、解码器和编码器的正确性
10. [ ] 执行 `mvn compile` 验证代码编译通过

# 需要修改或新增的类

| 类型 | 类名 | 包路径 |
|------|------|--------|
| 新增 | `WebSocketHandshakeUtil` | `cc.jfire.jnet.extend.websocket.util` |
| 修改 | `HttpRequestPartDecoder` | `cc.jfire.jnet.extend.http.coder` |
| 修改 | `HttpRequestPartSupportWebSocketDecoderWithPassThough` | `cc.jfire.jnet.extend.http.coder` |
| 新增 | `WebSocketUpgradeDecoder` | `cc.jfire.jnet.extend.websocket.coder` |
| 新增 | `WebSocketFrame` | `cc.jfire.jnet.extend.websocket.dto` |
| 新增 | `WebSocketFrameDecoder` | `cc.jfire.jnet.extend.websocket.coder` |
| 新增 | `WebSocketFrameEncoder` | `cc.jfire.jnet.extend.websocket.coder` |
