# 目标

1. 提供一个解码器，可以支持 websocket

# 核心思路

1. 参考现有的 `HttpRequestPartDecoder` 实现模式，创建 `WebSocketFrameDecoder` 解码器
2. 解码器继承 `AbstractDecoder`，使用状态机模式解析 WebSocket 帧
3. 定义 WebSocket 帧的 DTO 类 `WebSocketFrame`，用于承载解码后的数据
4. WebSocket 帧格式遵循 RFC 6455 规范：
   - 第1字节：FIN(1bit) + RSV(3bit) + Opcode(4bit)
   - 第2字节：MASK(1bit) + Payload Length(7bit)
   - 扩展长度：若 Payload Length=126，后续2字节为实际长度；若=127，后续8字节为实际长度
   - Masking Key：若 MASK=1，后续4字节为掩码密钥
   - Payload Data：实际数据（若有掩码需解码）

# 详细实现思路

1. **WebSocketFrame DTO 类**：
   - 包含字段：fin、opcode、masked、payloadLength、maskingKey、payload（IoBuffer）
   - Opcode 类型：0x0(继续帧)、0x1(文本帧)、0x2(二进制帧)、0x8(关闭帧)、0x9(Ping)、0xA(Pong)

2. **WebSocketFrameDecoder 解码器**：
   - 状态机包含两个状态：READ_HEADER（读取帧头）、READ_PAYLOAD（读取负载）
   - READ_HEADER 阶段：解析前2字节获取基本信息，根据 payload length 判断是否需要读取扩展长度和掩码
   - READ_PAYLOAD 阶段：读取完整负载数据，若有掩码则进行解码
   - 解码完成后通过 `next.fireRead(frame)` 传递 WebSocketFrame 对象

3. **掩码解码**：客户端发送的数据必须使用掩码，服务端发送的数据不使用掩码。解码公式：`decoded[i] = encoded[i] ^ maskingKey[i % 4]`

# 实施步骤

## 步骤1：创建 WebSocketFrame DTO 类

在 `cc.jfire.jnet.extend.http.dto` 包下创建 `WebSocketFrame.java`：

```java
package cc.jfire.jnet.extend.http.dto;

import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import lombok.Data;

@Data
public class WebSocketFrame
{
    private boolean  fin;
    private int      opcode;
    private boolean  masked;
    private long     payloadLength;
    private byte[]   maskingKey;
    private IoBuffer payload;

    // Opcode 常量
    public static final int OPCODE_CONTINUATION = 0x0;
    public static final int OPCODE_TEXT         = 0x1;
    public static final int OPCODE_BINARY       = 0x2;
    public static final int OPCODE_CLOSE        = 0x8;
    public static final int OPCODE_PING         = 0x9;
    public static final int OPCODE_PONG         = 0xA;

    public void close()
    {
        if (payload != null)
        {
            payload.free();
            payload = null;
        }
    }
}
```

## 步骤2：创建 WebSocketFrameDecoder 解码器

在 `cc.jfire.jnet.extend.http.coder` 包下创建 `WebSocketFrameDecoder.java`：

```java
package cc.jfire.jnet.extend.http.coder;

import cc.jfire.jnet.common.api.ReadProcessorNode;
import cc.jfire.jnet.common.coder.AbstractDecoder;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.jnet.extend.http.dto.WebSocketFrame;

public class WebSocketFrameDecoder extends AbstractDecoder
{
    private static final int MAX_FRAME_SIZE = 65536; // 64KB 最大帧大小

    private ParseState state         = ParseState.READ_HEADER;
    private boolean    fin;
    private int        opcode;
    private boolean    masked;
    private long       payloadLength;
    private byte[]     maskingKey;
    private int        headerLength;

    @Override
    protected void process0(ReadProcessorNode next)
    {
        boolean goToNextState;
        do
        {
            goToNextState = switch (state)
            {
                case READ_HEADER -> parseHeader();
                case READ_PAYLOAD -> parsePayload(next);
            };
        } while (goToNextState);
    }

    private boolean parseHeader()
    {
        if (accumulation == null || accumulation.remainRead() < 2)
        {
            return false;
        }
        int startPosi = accumulation.getReadPosi();
        byte b0 = accumulation.get(startPosi);
        byte b1 = accumulation.get(startPosi + 1);

        fin    = (b0 & 0x80) != 0;
        opcode = b0 & 0x0F;
        masked = (b1 & 0x80) != 0;
        int len = b1 & 0x7F;

        headerLength = 2;
        if (len == 126)
        {
            headerLength += 2;
        }
        else if (len == 127)
        {
            headerLength += 8;
        }
        if (masked)
        {
            headerLength += 4;
        }

        if (accumulation.remainRead() < headerLength)
        {
            return false;
        }

        accumulation.addReadPosi(2);
        if (len == 126)
        {
            payloadLength = accumulation.getShort() & 0xFFFF;
        }
        else if (len == 127)
        {
            payloadLength = accumulation.getLong();
        }
        else
        {
            payloadLength = len;
        }

        if (payloadLength > MAX_FRAME_SIZE)
        {
            throw new IllegalStateException("WebSocket frame too large: " + payloadLength);
        }

        if (masked)
        {
            maskingKey = new byte[4];
            accumulation.get(maskingKey);
        }

        state = ParseState.READ_PAYLOAD;
        return true;
    }

    private boolean parsePayload(ReadProcessorNode next)
    {
        if (accumulation == null || accumulation.remainRead() < payloadLength)
        {
            return false;
        }

        WebSocketFrame frame = new WebSocketFrame();
        frame.setFin(fin);
        frame.setOpcode(opcode);
        frame.setMasked(masked);
        frame.setPayloadLength(payloadLength);
        frame.setMaskingKey(maskingKey);

        if (payloadLength > 0)
        {
            IoBuffer payload = accumulation.slice((int) payloadLength);
            if (masked && maskingKey != null)
            {
                unmask(payload);
            }
            frame.setPayload(payload);
        }

        next.fireRead(frame);
        resetState();

        if (accumulation != null && accumulation.remainRead() > 0)
        {
            accumulation.compact();
            return true;
        }
        if (accumulation != null && accumulation.remainRead() == 0)
        {
            accumulation.free();
            accumulation = null;
        }
        return false;
    }

    private void unmask(IoBuffer payload)
    {
        int len = payload.remainRead();
        int readPosi = payload.getReadPosi();
        for (int i = 0; i < len; i++)
        {
            byte b = payload.get(readPosi + i);
            payload.put((byte) (b ^ maskingKey[i % 4]), readPosi + i);
        }
    }

    private void resetState()
    {
        state         = ParseState.READ_HEADER;
        fin           = false;
        opcode        = 0;
        masked        = false;
        payloadLength = 0;
        maskingKey    = null;
        headerLength  = 0;
    }

    enum ParseState
    {
        READ_HEADER, READ_PAYLOAD
    }
}
```

# 待办列表

1. [ ] 创建 WebSocketFrame DTO 类
2. [ ] 创建 WebSocketFrameDecoder 解码器类

# 需要修改或新增的类

1. **新增** `cc.jfire.jnet.extend.http.dto.WebSocketFrame` - WebSocket 帧数据传输对象
2. **新增** `cc.jfire.jnet.extend.http.coder.WebSocketFrameDecoder` - WebSocket 帧解码器