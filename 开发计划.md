# 目标

1. 将HttpClient 中的实现修改为 HttpConnection2

# 核心思路

1. 将 `HttpClient` 中使用的 `HttpConnectionPool` 替换为 `HttpConnection2Pool`
2. 将 `HttpClient` 中使用的 `HttpConnection` 替换为 `HttpConnection2`
3. 调整 `HttpClient.newCall()` 方法的返回类型，从 `HttpReceiveResponse` 改为 `HttpResponse`
4. 更新连接借用和归还的逻辑，适配 `HttpConnection2Pool` 的 API
5. 新增流式调用方法 `newStreamCall()`，暴露 `HttpConnection2` 的流式处理能力

# 详细实现思路

## 1. 连接池替换

当前 `HttpClient` 使用 `HttpConnectionPool` 实例：
```java
HttpConnectionPool CONNECTION_POOL = new HttpConnectionPool();
```

需要替换为：
```java
HttpConnection2Pool CONNECTION_POOL = new HttpConnection2Pool();
```

## 2. 连接类型替换

当前使用 `HttpConnection`，需要替换为 `HttpConnection2`。两者的主要 API 差异：

| 功能 | HttpConnection | HttpConnection2 |
|------|---------------|-----------------|
| 同步写请求 | `write(HttpSendRequest, int)` 返回 `HttpReceiveResponse` | `write(HttpSendRequest, int)` 返回 `HttpResponse` |
| 流式写请求 | 无 | `write(HttpRequest, Consumer<HttpResponsePart>, Consumer<Throwable>)` 返回 `StreamableResponseFuture` |
| 连接状态检查 | `isConnectionClosed()` | `isConnectionClosed()` |
| 关闭连接 | `close()` | `close()` |

## 3. 连接池 API 差异

| 功能 | HttpConnectionPool | HttpConnection2Pool |
|------|-------------------|---------------------|
| 借用连接 | `borrowConnection(host, port, timeout, callback)` 带回调 | `borrowConnection(host, port, timeout)` 无回调 |
| 归还连接 | `returnConnection(host, port, connection)` | `returnConnection(host, port, connection)` |
| 移除连接 | `removeConnection(host, port, connection)` | 无此方法，直接关闭连接并依赖池自动处理 |

## 4. 返回类型变更

方法 `newCall()` 的返回类型从 `HttpReceiveResponse` 改为 `HttpResponse`。

`HttpResponse` 是一个更简洁的响应对象：
- `version`: HTTP 版本
- `statusCode`: 状态码
- `reasonPhrase`: 状态描述
- `headers`: 响应头
- `body`: 响应体 (IoBuffer)
- `free()`: 释放资源

## 5. 连接归还逻辑调整

原有实现通过回调在响应处理完成后归还连接。`HttpConnection2Pool` 不支持回调机制，需要在 `newCall()` 方法中显式管理连接的归还。

由于 `HttpConnection2.write()` 是同步阻塞方法，在返回 `HttpResponse` 时响应已完整接收，因此可以在返回响应前归还连接。

## 6. 新增流式调用方法

`HttpConnection2` 提供了流式处理响应的能力，通过以下方法：
```java
public StreamableResponseFuture write(HttpRequest request, Consumer<HttpResponsePart> partConsumer, Consumer<Throwable> errorConsumer)
```

需要在 `HttpClient` 中新增 `newStreamCall()` 方法暴露此能力。流式调用的特点：
- 使用 `HttpRequest`（来自 `cc.jfire.jnet.extend.http.dto` 包）作为请求参数
- 返回 `StreamableResponseFuture`，响应部分通过回调 `Consumer<HttpResponsePart>` 逐步接收
- 连接归还时机：由于流式响应是异步的，需要在响应完成后归还连接。可以通过包装 `partConsumer`，在收到最后一个 part（`part.isLast()` 为 true）时归还连接

# 实施步骤

## 步骤 1：修改 HttpClient 接口中的连接池类型

将：
```java
HttpConnectionPool CONNECTION_POOL = new HttpConnectionPool();
```

修改为：
```java
HttpConnection2Pool CONNECTION_POOL = new HttpConnection2Pool();
```

## 步骤 2：修改 newCall 方法的返回类型和实现

将方法签名从：
```java
static HttpReceiveResponse newCall(HttpSendRequest request) throws Exception
```

修改为：
```java
static HttpResponse newCall(HttpSendRequest request) throws Exception
```

## 步骤 3：修改 newCall 方法内部的连接类型

将：
```java
HttpConnection httpConnection = null;
```

修改为：
```java
HttpConnection2 httpConnection = null;
```

## 步骤 4：修改借用连接的调用

将：
```java
httpConnection = CONNECTION_POOL.borrowConnection(host, port, 60, res -> CONNECTION_POOL.returnConnection(host, port, res.getHttpConnection()));
```

修改为：
```java
httpConnection = CONNECTION_POOL.borrowConnection(host, port, 60);
```

## 步骤 5：修改请求执行和响应处理

将：
```java
HttpReceiveResponse response = httpConnection.write(request, 60);
return response;
```

修改为：
```java
HttpResponse response = httpConnection.write(request, 60);
CONNECTION_POOL.returnConnection(host, port, httpConnection);
return response;
```

注意：需要在成功获取响应后显式归还连接。

## 步骤 6：修改异常处理逻辑

将：
```java
if (httpConnection != null)
{
    // 异常时移除连接，不归还
    CONNECTION_POOL.removeConnection(host, port, httpConnection);
}
```

修改为：
```java
if (httpConnection != null)
{
    // 异常时关闭连接，连接池会自动处理
    httpConnection.close();
}
```

## 步骤 7：更新 import 语句

移除 `HttpConnection` 和 `HttpConnectionPool` 的导入（如果有），添加以下导入：
```java
import cc.jfire.jnet.extend.http.dto.HttpRequest;
import cc.jfire.jnet.extend.http.dto.HttpResponsePart;
import java.util.function.Consumer;
```

## 步骤 8：新增流式调用方法 newStreamCall

在 `HttpClient` 接口中新增以下方法：

```java
static StreamableResponseFuture newStreamCall(HttpRequest request, Consumer<HttpResponsePart> partConsumer, Consumer<Throwable> errorConsumer) throws Exception
{
    String          host           = request.getDomain();
    int             port           = request.getPort();
    HttpConnection2 httpConnection = null;
    try
    {
        httpConnection = CONNECTION_POOL.borrowConnection(host, port, 60);
        final HttpConnection2 finalConnection = httpConnection;
        // 包装 partConsumer，在响应完成时归还连接
        Consumer<HttpResponsePart> wrappedPartConsumer = part -> {
            try
            {
                if (partConsumer != null)
                {
                    partConsumer.accept(part);
                }
            }
            finally
            {
                if (part.isLast())
                {
                    CONNECTION_POOL.returnConnection(host, port, finalConnection);
                }
            }
        };
        // 包装 errorConsumer，在发生错误时关闭连接
        Consumer<Throwable> wrappedErrorConsumer = error -> {
            finalConnection.close();
            if (errorConsumer != null)
            {
                errorConsumer.accept(error);
            }
        };
        return httpConnection.write(request, wrappedPartConsumer, wrappedErrorConsumer);
    }
    catch (Throwable e)
    {
        request.close();
        if (httpConnection != null)
        {
            httpConnection.close();
        }
        throw e;
    }
}
```

# 待办列表

- [ ] 修改 HttpClient 中的连接池类型为 HttpConnection2Pool
- [ ] 修改 newCall 方法的返回类型为 HttpResponse
- [ ] 修改 newCall 方法内部的连接类型为 HttpConnection2
- [ ] 修改借用连接的调用，移除回调参数
- [ ] 修改响应处理逻辑，添加显式的连接归还
- [ ] 修改异常处理逻辑，使用 close() 代替 removeConnection()
- [ ] 添加 import 语句
- [ ] 新增流式调用方法 newStreamCall
- [ ] 编译验证修改是否正确

# 需要修改或新增的类

| 类名 | 操作类型 | 说明 |
|------|----------|------|
| HttpClient | 修改 | 修改连接池类型、返回类型、连接管理逻辑，并新增流式调用方法 newStreamCall |