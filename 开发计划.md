# 目标

1. ReverseProxyServer增加对 WebSocket的反代能力

# 核心思路

1. 创建一个单独的HttpRequestPartSupportWebSocketDecoder，可以考虑继承HttpRequestPartDecoder。如果识别到 websocket 的握手请求，则设定一个标志位，后续的请求全部当成 iobuffer 直接透传。

# 详细实现思路

## 1. WebSocket 握手识别

WebSocket 握手请求是一个标准的 HTTP 请求，其特征是包含 `Upgrade: websocket` 头部。识别方式：
- 在解析完请求头后，检查 `Upgrade` 头部是否为 `websocket`（不区分大小写）
- 如果匹配，则标记当前连接进入 WebSocket 透传模式

## 2. 解码器状态机扩展

在现有的 `HttpRequestPartDecoder` 基础上，新增“握手头已下发”的钩子方法，用于在 **请求头被 fireRead 之后、内部 resetState 之前** 做 WebSocket 识别并切换透传模式，避免在无 body 场景下 `reqHead` 被清空导致无法识别。

在新解码器进入 WebSocket 透传模式后：
- 握手请求头仍按 HTTP 正常解析并传递（`HttpRequestPartHead`）
- 握手后续所有数据直接作为 `IoBuffer` 透传，不再进行 HTTP 解析

## 3. 双向透传机制

WebSocket 需要支持双向透传：
- **客户端到后端**：由新的解码器 `HttpRequestPartSupportWebSocketDecoder` 处理，握手后直接透传 `IoBuffer`
- **后端到客户端**：由 `ProxyHttpHandler` 中的后端连接处理，当前已经是直接透传 `IoBuffer`，无需修改

## 4. 与现有架构的集成

- 新解码器继承 `HttpRequestPartDecoder`，复用现有的 HTTP 请求解析逻辑
- 在 `ReverseProxyServer` 中，将 `HttpRequestPartDecoder` 替换为 `HttpRequestPartSupportWebSocketDecoder`
- `ProxyHttpHandler`：后端到客户端已是 `IoBuffer` 直通，但仍需补充“客户端到后端”的 `IoBuffer` 写入逻辑
- `TransferProcessor`：需要增加对 `IoBuffer` 的处理逻辑，并在识别到 WebSocket 握手且路由成功后，将 `currentHandler` 绑定到该前端连接直到断开

## 5. TransferProcessor 的扩展

`TransferProcessor` 当前只处理 `HttpRequestPart` 类型的数据。为支持 WebSocket 透传，需要：
- 增加对 `IoBuffer` 类型数据的处理
- 当收到 `IoBuffer` 时，直接转发给当前的 `ResourceHandler`
- 在识别到 WebSocket 握手后，不再在 `head.isLast()` 时清空 `currentHandler`（因为 WebSocket 升级后连接将持续透传）

## 6. ResourceHandler 接口扩展

`ResourceHandler` 接口的 `process` 方法继续只接受 `HttpRequestPart` 类型。为支持 WebSocket 透传，新增一个处理 `IoBuffer` 的方法（默认实现释放 buffer）。

为避免在 `TransferProcessor` 中重复做 WebSocket 握手判定，建议在 `HttpRequestPartHead` 增加一个 `webSocketUpgrade` 标记字段，由解码器在识别到握手时置为 true。

# 实施步骤

## 步骤 1：创建 HttpRequestPartSupportWebSocketDecoder 类

**文件位置**：`src/main/java/cc/jfire/jnet/extend/http/coder/HttpRequestPartSupportWebSocketDecoder.java`

**代码内容**：

```java
package cc.jfire.jnet.extend.http.coder;

import cc.jfire.jnet.common.api.ReadProcessorNode;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.jnet.extend.http.dto.HttpRequestPartHead;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class HttpRequestPartSupportWebSocketDecoder extends HttpRequestPartDecoder
{
    private boolean webSocketMode = false;

    @Override
    protected void process0(ReadProcessorNode next)
    {
        // 如果已进入 WebSocket 透传模式，直接透传数据
        if (webSocketMode)
        {
            if (accumulation != null && accumulation.remainRead() > 0)
            {
                IoBuffer data = accumulation;
                accumulation = null;
                next.fireRead(data);
            }
            return;
        }
        // 否则使用父类的 HTTP 解析逻辑
        super.process0(next);
    }

    @Override
    protected void afterRequestHeadFired(ReadProcessorNode next, HttpRequestPartHead head)
    {
        // 检查是否是 WebSocket 握手请求（header name 已规范化为 Upgrade）
        String upgrade = head.getHeaders().get("Upgrade");
        if ("websocket".equalsIgnoreCase(upgrade))
        {
            head.setWebSocketUpgrade(true);
            webSocketMode = true;
            log.debug("检测到 WebSocket 握手请求，进入透传模式");
        }
    }
}
```

**说明**：
- 继承 `HttpRequestPartDecoder`，复用 HTTP 解析逻辑
- 新增 `webSocketMode` 标志位，标记是否进入 WebSocket 透传模式
- 重写 `process0` 方法，在透传模式下直接传递 `IoBuffer`
- 重写 `afterRequestHeadFired` 钩子方法，在握手请求头已 fireRead 且 resetState 之前检查 `Upgrade` 头部并打标记

## 步骤 2：修改 HttpRequestPartDecoder 类

**文件位置**：`src/main/java/cc/jfire/jnet/extend/http/coder/HttpRequestPartDecoder.java`

**修改内容**：
1. 新增一个钩子方法 `afterRequestHeadFired(ReadProcessorNode next, HttpRequestPartHead head)`（默认空实现）
2. 在 `parseRequestHeader` 中 `next.fireRead(reqHead);` 之后调用该钩子（确保在无 body 场景 `resetState()` 清空 `reqHead` 之前仍可读取头部信息）

**修改 1**：在 `resetState` 方法之前新增钩子方法：
```java
protected void afterRequestHeadFired(ReadProcessorNode next, HttpRequestPartHead head) {}
```

**修改 2**：在 `parseRequestHeader` 方法中，找到 `next.fireRead(reqHead);` 这一行（当前第 126 行），在其后、`// 如果没有 body，直接重置状态，不再发送 End` 注释之前插入：
```java
afterRequestHeadFired(next, reqHead);
```

## 步骤 3：修改 ResourceHandler 接口

**文件位置**：`src/main/java/cc/jfire/jnet/extend/reverse/proxy/api/ResourceHandler.java`

**修改内容**：新增处理 `IoBuffer` 的方法。

**修改后的完整代码**：
```java
package cc.jfire.jnet.extend.reverse.proxy.api;

import cc.jfire.jnet.common.api.Pipeline;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.jnet.extend.http.dto.HttpRequestPart;

public interface ResourceHandler
{
    /**
     * 处理请求部分
     *
     * @param part     请求部分
     * @param pipeline 管道
     * @return true表示该handler处理了这个请求，false表示未处理
     */
    boolean process(HttpRequestPart part, Pipeline pipeline);

    /**
     * 处理 WebSocket 透传数据
     *
     * @param buffer   数据缓冲区
     * @param pipeline 管道
     */
    default void processWebSocket(IoBuffer buffer, Pipeline pipeline)
    {
        // 默认实现：释放 buffer，不处理
        buffer.free();
    }

    default void readFailed(Throwable e) {}
}
```

## 步骤 4：修改 HttpRequestPartHead 类（增加 WebSocket 标记）

**文件位置**：`src/main/java/cc/jfire/jnet/extend/http/dto/HttpRequestPartHead.java`

**修改内容**：新增 `webSocketUpgrade` 字段。由于该类使用了 `@Data` 注解（Lombok），getter/setter 会自动生成。

**在 `last` 字段之后新增**：
```java
protected boolean webSocketUpgrade = false;
```

## 步骤 5：修改 TransferProcessor 类

**文件位置**：`src/main/java/cc/jfire/jnet/extend/reverse/proxy/TransferProcessor.java`

**修改内容**：
1. 将泛型参数从 `HttpRequestPart` 改为 `Object`
2. 增加对 `IoBuffer` 类型数据的处理
3. 增加连接级 `webSocketMode` 标志：当收到 `HttpRequestPartHead` 且 `head.isWebSocketUpgrade()==true` 并路由成功后，进入 WebSocket 模式；进入该模式后不再在 `head.isLast()` 时清空 `currentHandler`

**修改后的完整代码**：
```java
package cc.jfire.jnet.extend.reverse.proxy;

import cc.jfire.jnet.common.api.ReadProcessor;
import cc.jfire.jnet.common.api.ReadProcessorNode;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.jnet.extend.http.client.HttpConnectionPool;
import cc.jfire.jnet.extend.http.dto.*;
import cc.jfire.jnet.extend.reverse.proxy.api.ResourceConfig;
import cc.jfire.jnet.extend.reverse.proxy.api.ResourceHandler;
import lombok.extern.slf4j.Slf4j;

import java.util.Comparator;
import java.util.List;

@Slf4j
public class TransferProcessor implements ReadProcessor<Object>
{
    private final ResourceHandler[] handlers;
    private       ResourceHandler   currentHandler;
    private       boolean           webSocketMode = false;

    public TransferProcessor(List<ResourceConfig> configs, HttpConnectionPool pool)
    {
        handlers = configs.stream().sorted(Comparator.comparingInt(ResourceConfig::getOrder)).map(config -> config.parse(pool)).toArray(ResourceHandler[]::new);
    }

    @Override
    public void read(Object data, ReadProcessorNode next)
    {
        if (data instanceof IoBuffer buffer)
        {
            processWebSocketData(buffer, next);
        }
        else if (data instanceof HttpRequestPart part)
        {
            processHttpRequestPart(part, next);
        }
    }

    private void processWebSocketData(IoBuffer buffer, ReadProcessorNode next)
    {
        if (currentHandler != null)
        {
            currentHandler.processWebSocket(buffer, next.pipeline());
        }
        else
        {
            buffer.free();
        }
    }

    private void processHttpRequestPart(HttpRequestPart part, ReadProcessorNode next)
    {
        if (part instanceof HttpRequestPartHead head)
        {
            processHead(head, next);
            // WebSocket 模式下不清除 currentHandler
            if (head.isLast() && !webSocketMode)
            {
                currentHandler = null;
            }
        }
        else if (part instanceof HttpRequestFixLengthBodyPart || part instanceof HttpRequestChunkedBodyPart)
        {
            processBody(part, next);
            // WebSocket 模式下不清除 currentHandler
            if (part.isLast() && !webSocketMode)
            {
                currentHandler = null;
            }
        }
    }

    private void processHead(HttpRequestPartHead head, ReadProcessorNode next)
    {
        for (ResourceHandler handler : handlers)
        {
            if (handler.process(head, next.pipeline()))
            {
                currentHandler = handler;
                // 检查是否是 WebSocket 握手请求
                if (head.isWebSocketUpgrade())
                {
                    webSocketMode = true;
                }
                return;
            }
        }
        // 没有匹配的 handler
        String path = head.getPath();
        head.close();
        HttpResponse response = new HttpResponse();
        response.getHead().setStatusCode(404);
        response.getHead().setReasonPhrase("Not Found");
        response.setBodyText("not found address:" + path);
        next.pipeline().fireWrite(response);
    }

    private void processBody(HttpRequestPart body, ReadProcessorNode next)
    {
        if (currentHandler != null)
        {
            currentHandler.process(body, next.pipeline());
        }
        else
        {
            body.close();
        }
    }

    @Override
    public void readFailed(Throwable e, ReadProcessorNode next)
    {
        try
        {
            for (ResourceHandler handler : handlers)
            {
                handler.readFailed(e);
            }
        }
        finally
        {
            currentHandler = null;
            webSocketMode = false;
        }
        next.fireReadFailed(e);
    }
}
```

**说明**：
- WebSocket 模式下 `currentHandler` 与前端连接生命周期绑定，直到连接断开/`readFailed` 再清理

## 步骤 6：修改 ProxyHttpHandler 类

**文件位置**：`src/main/java/cc/jfire/jnet/extend/reverse/proxy/api/handler/ProxyHttpHandler.java`

**修改内容**：实现 `processWebSocket` 方法，将 WebSocket 数据转发到后端。

**新增方法**：
```java
@Override
public void processWebSocket(IoBuffer buffer, Pipeline pipeline)
{
    if (clientChannel != null && clientChannel.alive())
    {
        clientChannel.pipeline().fireWrite(buffer);
    }
    else
    {
        buffer.free();
    }
}
```

## 步骤 7：修改 ReverseProxyServer 类

**文件位置**：`src/main/java/cc/jfire/jnet/extend/reverse/proxy/ReverseProxyServer.java`

**修改内容**：将 `HttpRequestPartDecoder` 替换为 `HttpRequestPartSupportWebSocketDecoder`。

**修改前**：
```java
pipeline.addReadProcessor(new HttpRequestPartDecoder());
```

**修改后**：
```java
pipeline.addReadProcessor(new HttpRequestPartSupportWebSocketDecoder());
```

**注意**：需要在两处进行替换（SSL 和非 SSL 配置）。

# 待办列表

1. [ ] 修改 HttpRequestPartDecoder：新增 `afterRequestHeadFired` 钩子，并在 `next.fireRead(reqHead)` 后调用
2. [ ] 创建 HttpRequestPartSupportWebSocketDecoder：继承 HttpRequestPartDecoder，在钩子中识别 `Upgrade: websocket` 并进入透传模式
3. [ ] 修改 HttpRequestPartHead：新增 `webSocketUpgrade` 标记字段
4. [ ] 修改 ResourceHandler 接口：新增 `processWebSocket` 方法
5. [ ] 修改 TransferProcessor：支持处理 `IoBuffer` 类型数据，并在 WebSocket 模式下保持 `currentHandler` 绑定直到断开
6. [ ] 修改 ProxyHttpHandler：实现 `processWebSocket` 方法
7. [ ] 修改 ReverseProxyServer：将解码器替换为 HttpRequestPartSupportWebSocketDecoder

# 需要修改或新增的类

| 类名 | 操作 | 说明 |
|------|------|------|
| HttpRequestPartDecoder | 修改 | 新增 `afterRequestHeadFired` 钩子并在请求头 fireRead 后调用 |
| HttpRequestPartSupportWebSocketDecoder | 新增 | WebSocket 支持的 HTTP 请求解码器 |
| HttpRequestPartHead | 修改 | 新增 `webSocketUpgrade` 标记字段 |
| ResourceHandler | 修改 | 新增 `processWebSocket` 方法 |
| TransferProcessor | 修改 | 支持处理 IoBuffer 类型数据 |
| ProxyHttpHandler | 修改 | 实现 `processWebSocket` 方法 |
| ReverseProxyServer | 修改 | 使用新的解码器 |
