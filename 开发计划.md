# 目标

1. 保留 ProxyHttpHandler2，删除 ProxyHttpHandler。
2. 删除 FullMatchProxyHttpHandler 和 PrefixMatchProxyHttpHandler。
3. ProxyHttpHandler2 通过配置支持前缀匹配和完全匹配两种模式。

# 核心思路

采用方案1：让 ProxyHttpHandler2 通过配置区分匹配方式，而不是保留多个子类。

理由：
1. 匹配方式有限且稳定（前缀匹配、完全匹配），几乎不会扩展
2. 配置化更直观，调用者一眼就能看出配置含义
3. 从4个类减少到1个类，代码结构更清晰
4. ProxyHttpHandler2 已经实现了前缀匹配，只需增加完全匹配的分支逻辑

# 详细实现思路

## 1. 新增匹配模式枚举

在 ProxyHttpHandler2 中新增 `MatchMode` 枚举，区分两种匹配方式：
- `PREFIX`：前缀匹配（当前已有逻辑）
- `EXACT`：完全匹配

## 2. 修改构造函数

- 新增一个构造函数，接收 `MatchMode` 参数
- 保留原有构造函数作为默认前缀匹配的便捷方法
- 完全匹配模式下，`match` 参数不需要以 `/*` 结尾

## 3. 修改匹配逻辑

在 `processHead` 方法中根据 `MatchMode` 选择不同的匹配策略：
- `PREFIX`：请求路径以 `prefixMatch` 开头即匹配
- `EXACT`：请求路径（不含 query string 和 fragment）完全等于 `match` 才匹配

## 4. 修改后端URL计算逻辑

根据匹配模式计算后端路径：
- `PREFIX`：`backendBasePath + requestUrl.substring(prefixLen)`（当前逻辑）
- `EXACT`：直接使用 `backendBasePath`，但保留原始请求的 query string

## 5. 删除旧类

删除以下类：
- ProxyHttpHandler.java
- FullMatchProxyHttpHandler.java
- PrefixMatchProxyHttpHandler.java

# 实施步骤

## 步骤1：在 ProxyHttpHandler2 中新增 MatchMode 枚举

在类内部新增枚举定义：

```java
public enum MatchMode
{
    PREFIX,  // 前缀匹配
    EXACT    // 完全匹配
}
```

## 步骤2：新增成员变量和修改构造函数

新增成员变量：
```java
private final MatchMode matchMode;
private final String    match;      // 完全匹配时使用
```

新增支持 MatchMode 的构造函数：
```java
public ProxyHttpHandler2(String match, String proxy, MatchMode matchMode)
{
    this.matchMode = matchMode;
    this.proxy = proxy;

    // 解析后端地址
    HttpUrl httpUrl = HttpUrl.parse(proxy);
    this.backendHost = httpUrl.domain();
    this.backendPort = httpUrl.port();
    this.backendBasePath = httpUrl.path();
    this.backendHostHeader = (backendPort == 80 || backendPort == 443)
        ? backendHost : (backendHost + ":" + backendPort);

    if (matchMode == MatchMode.PREFIX)
    {
        // 前缀匹配：验证并处理前缀规则
        if (!match.endsWith("/*") || match.chars().filter(c -> c == '*').count() != 1)
        {
            throw new IllegalArgumentException(match + "不是合规的前缀匹配地址");
        }
        this.prefixMatch = match.substring(0, match.length() - 1);
        this.prefixLen = this.prefixMatch.length();
        this.match = null;
    }
    else
    {
        // 完全匹配：直接使用 match
        this.match = match;
        this.prefixMatch = null;
        this.prefixLen = 0;
    }
}
```

修改原有构造函数，默认使用前缀匹配：
```java
public ProxyHttpHandler2(String prefixMatch, String proxy)
{
    this(prefixMatch, proxy, MatchMode.PREFIX);
}
```

## 步骤3：修改 processHead 方法的匹配和URL计算逻辑

```java
private boolean processHead(HttpRequestPartHead head, Pipeline pipeline)
{
    // 获取请求URL并去除 fragment
    String requestUrl = head.getPath();
    int index = requestUrl.indexOf("#");
    if (index != -1)
    {
        requestUrl = requestUrl.substring(0, index);
    }

    String backendPath;

    if (matchMode == MatchMode.PREFIX)
    {
        // 前缀匹配
        if (!requestUrl.startsWith(prefixMatch))
        {
            return false;
        }
        backendPath = backendBasePath + requestUrl.substring(prefixLen);
    }
    else
    {
        // 完全匹配：提取路径部分（不含 query string）进行比较
        int queryIndex = requestUrl.indexOf("?");
        String pathPart = queryIndex == -1 ? requestUrl : requestUrl.substring(0, queryIndex);
        if (!pathPart.equals(match))
        {
            return false;
        }
        // 后端路径 = backendBasePath + 原始 query string
        backendPath = queryIndex == -1 ? backendBasePath : backendBasePath + requestUrl.substring(queryIndex);
    }

    // 设置后端请求属性
    head.setPath(backendPath);
    head.setDomain(backendHost);
    head.setPort(backendPort);
    head.getHeaders().put("Host", backendHostHeader);

    // ... 后续连接和转发逻辑保持不变
}
```

## 步骤4：删除旧类文件

删除以下三个文件：
- `src/main/java/cc/jfire/jnet/extend/reverse/proxy/api/handler/ProxyHttpHandler.java`
- `src/main/java/cc/jfire/jnet/extend/reverse/proxy/api/handler/FullMatchProxyHttpHandler.java`
- `src/main/java/cc/jfire/jnet/extend/reverse/proxy/api/handler/PrefixMatchProxyHttpHandler.java`

## 步骤5：更新引用处代码

搜索项目中所有使用 `FullMatchProxyHttpHandler` 和 `PrefixMatchProxyHttpHandler` 的地方，替换为：

```java
// 原来的前缀匹配
// new PrefixMatchProxyHttpHandler("/api/*", "http://backend:8080", pool)
// 改为
new ProxyHttpHandler2("/api/*", "http://backend:8080", MatchMode.PREFIX)
// 或简写
new ProxyHttpHandler2("/api/*", "http://backend:8080")

// 原来的完全匹配
// new FullMatchProxyHttpHandler("/health", "http://backend:8080/status", pool)
// 改为
new ProxyHttpHandler2("/health", "http://backend:8080/status", MatchMode.EXACT)
```

## 步骤6：编译验证

执行 `mvn compile` 验证代码编译通过。

# 待办列表

- [ ] 1. 在 ProxyHttpHandler2 中新增 MatchMode 枚举
- [ ] 2. 新增成员变量（matchMode、match）并修改构造函数
- [ ] 3. 修改 processHead 方法支持两种匹配模式
- [ ] 4. 删除 ProxyHttpHandler.java
- [ ] 5. 删除 FullMatchProxyHttpHandler.java
- [ ] 6. 删除 PrefixMatchProxyHttpHandler.java
- [ ] 7. 搜索并更新项目中的引用代码
- [ ] 8. 执行 mvn compile 验证编译通过

# 需要修改或新增的类

| 类名 | 操作 |
|------|------|
| ProxyHttpHandler2 | 修改 |
| ProxyHttpHandler | 删除 |
| FullMatchProxyHttpHandler | 删除 |
| PrefixMatchProxyHttpHandler | 删除 |