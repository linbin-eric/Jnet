# 目标

1. 比较方法：cc.jfire.jnet.extend.http.coder.ClientSSLDecoder.handshake和cc.jfire.jnet.extend.http.coder.SSLDecoder.handshake，两个方法是否是基本一致的？如果是的话，可以考虑抽象公共类。

# 核心思路

## 分析结论

经过详细对比，`ClientSSLDecoder.handshake` 和 `SSLDecoder.handshake` 两个方法的**核心逻辑基本一致**，可以抽象公共基类。

### 两个类的相同点

1. **handshake 方法结构完全一致**：
   - 都是 `while(true)` 循环的状态机模式
   - 处理相同的 `HandshakeStatus` 状态：`NEED_UNWRAP`、`NEED_UNWRAP_AGAIN`、`NEED_WRAP`、`NEED_TASK`、`FINISHED`、`NOT_HANDSHAKING`
   - 核心处理逻辑相同

2. **gracefulClose 方法完全一致**：
   - 关闭 SSL 入站和出站
   - 循环 wrap 发送关闭消息
   - 最后调用 `pipeline.shutdownInput()`

3. **handleData/handData 方法逻辑一致**：
   - 循环解密数据并传递给下一个处理器
   - 处理 `BUFFER_UNDERFLOW` 和 `CLOSED` 状态

4. **readFailed 方法完全一致**

5. **process0 方法结构一致**

### 两个类的差异点

| 特性 | ClientSSLDecoder | SSLDecoder |
|------|------------------|------------|
| 用途 | 客户端 SSL 解码器 | 服务端 SSL 解码器 |
| startHandshake 方法 | 有（主动发起握手） | 无 |
| handshakeLatch | 有（等待握手完成） | 无 |
| waitHandshake 方法 | 有 | 无 |
| count 字段 | 无 | 有（调试用，已注释） |
| NOT_HANDSHAKING 处理 | 视为握手完成 | 调用 gracefulClose |

### NOT_HANDSHAKING 状态分析

`NOT_HANDSHAKING` 表示 SSLEngine 当前不在进行握手，可能出现在以下场景：
1. **握手完成后的稳定状态** - 正常情况
2. **SSLEngine 刚创建但尚未开始握手** - 初始状态
3. **握手过程中出现异常导致中断** - 异常情况

原 `ClientSSLDecoder` 将 `NOT_HANDSHAKING` 视为握手完成是不够保守的做法。在握手过程中收到此状态，更可能意味着握手被中断或出现问题。

**决策**：统一采用保守方案，两个类都将 `NOT_HANDSHAKING` 视为异常，调用 `gracefulClose()` 关闭连接。

### 重构方案

创建抽象基类 `AbstractSSLDecoder`，将公共逻辑提取到基类中：
- 公共字段：`sslEngine`、`handshakeFinished`、`closeInbound`、`remote`
- 公共方法：`gracefulClose`、`handshake`、`handleData`、`readFailed`、`process0`
- 子类特有：`ClientSSLDecoder` 保留 `startHandshake`、`handshakeLatch`、`waitHandshake`
- `NOT_HANDSHAKING` 处理：统一在基类中调用 `gracefulClose()`，不再需要抽象方法

# 详细思路

## 1. 创建抽象基类 AbstractSSLDecoder

### 1.1 类定义

在 `cc.jfire.jnet.extend.http.coder` 包下创建 `AbstractSSLDecoder` 抽象类，继承 `AbstractDecoder`。

### 1.2 公共字段

```java
protected final SSLEngine sslEngine;
protected boolean handshakeFinished = false;
protected volatile boolean closeInbound = false;
protected String remote;
```

### 1.3 公共方法

#### gracefulClose(Pipeline pipeline)
- 完全相同的实现，直接提取到基类

#### handshake(ReadProcessorNode next, SSLEngineResult.HandshakeStatus hs)
- 核心逻辑相同
- `NOT_HANDSHAKING` 状态统一调用 `gracefulClose(next.pipeline())`，不再作为差异点

#### handleData(ReadProcessorNode next)
- 逻辑一致，直接提取到基类
- 统一方法名为 `handleData`

#### process0(ReadProcessorNode next)
- 结构一致，直接提取到基类

#### readFailed(Throwable e, ReadProcessorNode next)
- 完全相同，直接提取到基类

### 1.4 钩子方法

```java
/**
 * 握手完成时的回调
 */
protected void onHandshakeFinished() {
    // 默认空实现，子类可覆盖
}
```

## 2. 修改 SSLDecoder

### 2.1 继承关系
- 改为继承 `AbstractSSLDecoder`

### 2.2 移除的内容
- 移除 `count` 字段（调试用，已注释）
- 移除所有已提取到基类的方法和字段

### 2.3 最终代码
- 只需保留构造方法，无需实现任何抽象方法

## 3. 修改 ClientSSLDecoder

### 3.1 继承关系
- 改为继承 `AbstractSSLDecoder`

### 3.2 保留的特有字段
```java
private final CountDownLatch handshakeLatch = new CountDownLatch(1);
```

### 3.3 保留的特有方法
- `waitHandshake(long timeout, TimeUnit unit)`
- `startHandshake(Pipeline pipeline)`

### 3.4 覆盖钩子方法
```java
@Override
protected void onHandshakeFinished() {
    handshakeLatch.countDown();
}
```

## 4. 影响范围分析

### 4.1 使用 ClientSSLDecoder 的位置
- `HttpConnection.java`：直接 HTTPS 连接和 HTTPS 代理隧道模式
- 无需修改调用代码，因为公共接口不变

### 4.2 使用 SSLDecoder 的位置
- `ReverseProxyServer.java`：反向代理服务器
- 无需修改调用代码，因为公共接口不变

## 5. 重构后的类结构

```
AbstractDecoder (已存在)
    └── AbstractSSLDecoder (新建)
            ├── SSLDecoder (修改)
            └── ClientSSLDecoder (修改)
```