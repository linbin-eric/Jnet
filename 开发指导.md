# 目标

1. 实现 HttpConnection 和 HttpClient 对代理服务器的支持。要求同时支持 http 和 https 两种模式。

# 核心思路

HTTP 代理有两种工作模式，需要分别实现：

1. **HTTPS 代理（CONNECT 隧道模式）**：客户端先向代理服务器发送 `CONNECT host:port HTTP/1.1` 请求，代理服务器返回 `200 Connection Established` 后，建立一条透明隧道。之后客户端在隧道内进行 SSL 握手和加密通信，代理服务器只负责转发数据，无法解密内容。

2. **HTTP 代理（直接代理模式）**：客户端将请求发送给代理服务器，但请求行中的路径改为完整 URL（如 `GET http://example.com/path HTTP/1.1`）。代理服务器解析请求后转发给目标服务器，并将响应返回给客户端。

# 详细思路

## HTTPS 代理实现

### 连接流程
```
客户端 ──TCP连接──> 代理服务器
客户端 ──CONNECT请求──> 代理服务器
客户端 <──200响应── 代理服务器
客户端 ══SSL隧道══ 代理服务器 ══转发══ 目标服务器
```

### 管道设计
需要在现有 SSL 处理链之前插入隧道读处理器：

**读取链**：
```
IoBuffer → ProxyTunnelReadHandler → ClientSSLDecoder → HeartBeat → HttpResponsePartDecoder → 业务处理器
```
- `ProxyTunnelReadHandler`：隧道建立前拦截并解析 CONNECT 响应；隧道建立后透传数据给 SSL 解码器

**写入链**：
```
HttpRequest → HttpRequestPartEncoder → HeartBeat → ClientSSLEncoder → IoBuffer
```
- 写入链无需特殊处理器，CONNECT 请求通过 `Pipeline#directWrite` 直接写出，绕过整个写处理器链

### 关键点
1. 使用 `CountDownLatch` 同步等待隧道建立
2. CONNECT 请求通过 `directWrite` 直接写出，避免被 SSL 编码器处理
3. 隧道建立后再触发 SSL 握手

## HTTP 代理实现

### 连接流程
```
客户端 ──TCP连接──> 代理服务器
客户端 ──HTTP请求(完整URL)──> 代理服务器 ──转发──> 目标服务器
客户端 <──HTTP响应── 代理服务器 <──响应── 目标服务器
```

### 管道设计
使用专门的代理请求编码器替换标准编码器：

**读取链**：
```
IoBuffer → HeartBeat → HttpResponsePartDecoder → 业务处理器
```

**写入链**：
```
HttpRequest → ProxyHttpRequestEncoder → HeartBeat → IoBuffer
```
- `ProxyHttpRequestEncoder`：将请求行中的路径改为完整 URL（`http://host:port/path`）

## 连接池设计

在 `HttpConnectionPool` 中新增代理连接管理方法：
- 使用 `protocol://proxyHost:proxyPort->host:port` 作为连接池 key，区分不同代理和目标的组合
- 通过 `ssl` 参数区分 HTTPS 代理和 HTTP 代理

## HttpClient 接口设计

新增带代理参数的请求方法：
- `newCall(HttpRequest request, String proxyHost, int proxyPort)`：根据请求端口自动判断使用 HTTPS 代理还是 HTTP 代理
- `newStreamCall(...)` 的代理版本：支持流式响应
