# 目标

1. 简化服务端和客户端的 SSL 流程，通过接口：cc.jfire.jnet.common.api.Pipeline.directWrite

# 核心思路

1. 对于服务端的 SSLEncoder 而言，可以考虑去掉 SSLProtocol。在握手阶段和优雅关闭阶段，都可以由 SSLDecoder 直接构造对应的 IoBuffer，然后调用 directWrite 来传递这部分协议消息。SSLEncoder 的职责简化为单纯的对数据进行协议加密。
2. 客户端的流程也是相似的思路。

# 详细思路

## 当前实现分析

### 服务端 SSL（SSLDecoder + SSLEncoder + SSLProtocol）

- `SSLDecoder`：负责解密入站数据
  - 握手阶段 `NEED_WRAP` 时：调用 `sslEngine.wrap()` 生成握手数据，通过 `pipeline.fireWrite(new SSLProtocol().setData(dst))` 发送
  - 优雅关闭时：调用 `pipeline.fireWrite(new SSLProtocol().setCloseNotify(true))` 通知 Encoder 生成关闭消息
- `SSLEncoder`：处理两类数据
  - `SSLProtocol` 协议消息：处理握手数据透传和关闭通知生成
  - `IoBuffer` 业务数据：进行 SSL 加密
- `SSLProtocol`：内部类，包含 `closeNotify` 和 `data` 字段，用于 Decoder 和 Encoder 之间传递控制信息

### 客户端 SSL（ClientSSLDecoder + ClientSSLEncoder + ClientSSLProtocol）

- `ClientSSLDecoder`：负责解密入站数据
  - 握手阶段 `NEED_WRAP` 时：调用 `sslEngine.wrap()` 生成握手数据，通过 `pipeline.fireWrite(new ClientSSLProtocol().setData(dst))` 发送
  - 优雅关闭时：调用 `pipeline.fireWrite(new ClientSSLProtocol().setCloseNotify(true))` 通知 Encoder 生成关闭消息
- `ClientSSLEncoder`：处理三类数据
  - `ClientSSLProtocol.startHandshake`：客户端主动发起握手
  - `ClientSSLProtocol.closeNotify`：生成关闭通知
  - `ClientSSLProtocol.data`：握手数据透传
  - `IoBuffer` 业务数据：进行 SSL 加密
- `ClientSSLProtocol`：独立类，包含 `startHandshake`、`closeNotify`、`data` 三个字段

## 改进方案

### 服务端改进

1. **SSLDecoder 改进**：
   - 握手阶段 `NEED_WRAP` 时：直接调用 `pipeline.directWrite(dst)` 发送握手数据，不再通过 SSLProtocol
   - 优雅关闭时：直接在 `gracefulClose` 方法中调用 `sslEngine.wrap()` 生成关闭消息，然后调用 `pipeline.directWrite(dst)` 发送
   - 删除内部类 `SSLProtocol`

2. **SSLEncoder 改进**：
   - 移除对 `SSLProtocol` 的处理逻辑
   - 只保留对 `IoBuffer` 业务数据的 SSL 加密功能
   - 移除对 `SSLDecoder` 的依赖（不再需要调用 `sslDecoder.gracefulClose()`）

### 客户端改进

1. **ClientSSLDecoder 改进**：
   - 握手阶段 `NEED_WRAP` 时：直接调用 `pipeline.directWrite(dst)` 发送握手数据
   - 优雅关闭时：直接在 `gracefulClose` 方法中生成关闭消息并调用 `pipeline.directWrite(dst)` 发送
   - 新增 `startHandshake(Pipeline pipeline)` 方法：客户端主动发起握手时，直接生成握手数据并调用 `directWrite` 发送

2. **ClientSSLEncoder 改进**：
   - 移除对 `ClientSSLProtocol` 的处理逻辑
   - 只保留对 `IoBuffer` 业务数据的 SSL 加密功能
   - 移除对 `ClientSSLDecoder` 的依赖

3. **删除 ClientSSLProtocol 类**

### 调用方适配

需要检查 `HttpConnection` 等使用 SSL 的地方，将 `pipeline.fireWrite(new ClientSSLProtocol().setStartHandshake(true))` 改为调用 `ClientSSLDecoder.startHandshake(pipeline)`

