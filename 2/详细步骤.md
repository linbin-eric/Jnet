# 详细步骤

> 本文档引用了《开发指导.md》，请先阅读该文档了解目标和整体思路。

---

## 步骤 1：创建 ProxyTunnelReadHandler 类

**文件**: `src/main/java/cc/jfire/jnet/extend/http/coder/ProxyTunnelReadHandler.java`（新建文件）

**改动内容**:

```java
package cc.jfire.jnet.extend.http.coder;

import cc.jfire.jnet.common.api.ReadProcessor;
import cc.jfire.jnet.common.api.ReadProcessorNode;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import lombok.Setter;

import java.nio.charset.StandardCharsets;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

/**
 * 代理隧道读处理器
 * 在隧道建立前拦截并解析 CONNECT 响应，建立后透传数据给 SSL 解码器
 */
public class ProxyTunnelReadHandler implements ReadProcessor<IoBuffer>
{
    private final CountDownLatch              tunnelLatch;
    private final AtomicBoolean               tunnelEstablished;
    private final AtomicReference<Throwable>  errorRef;
    @Setter
    private       ProxyTunnelWriteHandler     writeHandler;

    private volatile boolean tunnelReady = false;
    private          IoBuffer accumulation;

    public ProxyTunnelReadHandler(CountDownLatch tunnelLatch,
                                  AtomicBoolean tunnelEstablished,
                                  AtomicReference<Throwable> errorRef)
    {
        this.tunnelLatch       = tunnelLatch;
        this.tunnelEstablished = tunnelEstablished;
        this.errorRef          = errorRef;
    }

    @Override
    public void read(IoBuffer data, ReadProcessorNode next)
    {
        if (tunnelReady)
        {
            // 隧道已建立，透传数据给 SSL 解码器
            next.fireRead(data);
            return;
        }

        // 累积数据
        if (accumulation == null)
        {
            accumulation = data;
        }
        else
        {
            accumulation.put(data);
            data.free();
        }

        // 尝试解析 CONNECT 响应
        if (parseConnectResponse())
        {
            tunnelReady = true;
            tunnelEstablished.set(true);
            // 通知写处理器也切换到透传模式
            if (writeHandler != null)
            {
                writeHandler.setTunnelReady(true);
            }
            tunnelLatch.countDown();

            // 如果有剩余数据，传递给 SSL 解码器
            if (accumulation != null && accumulation.remainRead() > 0)
            {
                next.fireRead(accumulation);
                accumulation = null;
            }
            else if (accumulation != null)
            {
                accumulation.free();
                accumulation = null;
            }
        }
    }

    /**
     * 解析 CONNECT 响应
     * 期望格式: HTTP/1.1 200 Connection Established\r\n...\r\n\r\n
     */
    private boolean parseConnectResponse()
    {
        if (accumulation == null || accumulation.remainRead() < 4)
        {
            return false;
        }

        // 查找 \r\n\r\n 标记响应头结束
        int readPosi  = accumulation.getReadPosi();
        int writePosi = accumulation.getWritePosi();

        for (int i = readPosi; i < writePosi - 3; i++)
        {
            if (accumulation.get(i) == '\r' &&
                accumulation.get(i + 1) == '\n' &&
                accumulation.get(i + 2) == '\r' &&
                accumulation.get(i + 3) == '\n')
            {
                // 找到响应头结束位置
                int headerEndPosi = i + 4;
                int headerLength  = headerEndPosi - readPosi;

                // 解析状态行
                byte[] headerBytes = new byte[headerLength];
                for (int j = 0; j < headerLength; j++)
                {
                    headerBytes[j] = accumulation.get(readPosi + j);
                }
                String headerStr = new String(headerBytes, StandardCharsets.US_ASCII);

                // 检查状态码是否为 200
                if (headerStr.startsWith("HTTP/") && headerStr.contains(" 200 "))
                {
                    // 移动读取位置
                    accumulation.setReadPosi(headerEndPosi);
                    return true;
                }
                else
                {
                    // 代理拒绝连接
                    String statusLine = headerStr.split("\r\n")[0];
                    errorRef.set(new RuntimeException("代理服务器返回非 200 响应: " + statusLine));
                    tunnelLatch.countDown();
                    return false;
                }
            }
        }

        return false;
    }

    @Override
    public void readFailed(Throwable e, ReadProcessorNode next)
    {
        if (!tunnelReady)
        {
            errorRef.set(e);
            tunnelLatch.countDown();
        }
        if (accumulation != null)
        {
            accumulation.free();
            accumulation = null;
        }
        next.fireReadFailed(e);
    }
}
```

---

## 步骤 2：创建 ProxyTunnelWriteHandler 类

**文件**: `src/main/java/cc/jfire/jnet/extend/http/coder/ProxyTunnelWriteHandler.java`（新建文件）

**改动内容**:

```java
package cc.jfire.jnet.extend.http.coder;

import cc.jfire.jnet.common.api.WriteProcessor;
import cc.jfire.jnet.common.api.WriteProcessorNode;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import lombok.Setter;

/**
 * 代理隧道写处理器
 * 在隧道建立前拦截 ProxyConnectRequest 并直接写出，建立后透传数据
 */
public class ProxyTunnelWriteHandler implements WriteProcessor<Object>
{
    @Setter
    private volatile boolean tunnelReady = false;

    @Override
    public void write(Object data, WriteProcessorNode next)
    {
        if (tunnelReady)
        {
            // 隧道已建立，透传数据
            next.fireWrite(data);
            return;
        }

        // 隧道未建立时，检查是否是 CONNECT 请求
        if (data instanceof ProxyConnectRequest connectRequest)
        {
            // 直接写出 CONNECT 请求（绕过 SSL 编码）
            next.fireWrite(connectRequest.getBuffer());
        }
        else if (data instanceof ClientSSLProtocol)
        {
            // SSL 协议消息在隧道建立前不处理，丢弃
            // 隧道建立后 tunnelReady=true，会走透传逻辑
        }
        else
        {
            // 其他数据透传
            next.fireWrite(data);
        }
    }
}
```

---

## 步骤 3：创建 ProxyConnectRequest 类

**文件**: `src/main/java/cc/jfire/jnet/extend/http/coder/ProxyConnectRequest.java`（新建文件）

**改动内容**:

```java
package cc.jfire.jnet.extend.http.coder;

import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import lombok.Data;
import lombok.experimental.Accessors;

/**
 * 代理 CONNECT 请求包装类
 * 用于标识这是一个需要绕过 SSL 编码直接发送的 CONNECT 请求
 */
@Data
@Accessors(chain = true)
public class ProxyConnectRequest
{
    private IoBuffer buffer;
}
```

---

## 步骤 4：在 HttpConnection 中新增支持代理的构造方法

**文件**: `src/main/java/cc/jfire/jnet/extend/http/client/HttpConnection.java`

**改动位置**: 在类中新增构造方法（在现有 SSL 构造方法之后）

**改动内容**:

```java
/**
 * 通过 HTTP 代理创建 HTTPS 连接（使用 CONNECT 隧道模式）
 *
 * @param domain             目标服务器域名
 * @param port               目标服务器端口
 * @param secondsOfKeepAlive 保活时间（秒）
 * @param proxyHost          代理服务器主机名
 * @param proxyPort          代理服务器端口
 */
public HttpConnection(String domain, int port, int secondsOfKeepAlive, String proxyHost, int proxyPort)
{
    // 连接到代理服务器
    ChannelConfig channelConfig = new ChannelConfig().setIp(proxyHost).setPort(proxyPort);
    ClientSSLDecoder[] sslDecoderHolder = new ClientSSLDecoder[1];
    CountDownLatch tunnelLatch = new CountDownLatch(1);
    AtomicBoolean tunnelEstablished = new AtomicBoolean(false);
    AtomicReference<Throwable> tunnelErrorRef = new AtomicReference<>();

    // 创建隧道处理器
    ProxyTunnelReadHandler readHandler = new ProxyTunnelReadHandler(tunnelLatch, tunnelEstablished, tunnelErrorRef);
    ProxyTunnelWriteHandler writeHandler = new ProxyTunnelWriteHandler();
    readHandler.setWriteHandler(writeHandler);

    clientChannel = ClientChannel.newClient(channelConfig, pipeline -> {
        try
        {
            // 初始化 SSL 引擎
            TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager()
            {
                public X509Certificate[] getAcceptedIssuers()                            {return new X509Certificate[0];}
                public void checkClientTrusted(X509Certificate[] certs, String authType) {}
                public void checkServerTrusted(X509Certificate[] certs, String authType) {}
            }};
            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(null, trustAllCerts, null);
            SSLEngine sslEngine = sslContext.createSSLEngine(domain, port);
            sslEngine.setUseClientMode(true);
            ClientSSLDecoder sslDecoder = new ClientSSLDecoder(sslEngine);
            ClientSSLEncoder sslEncoder = new ClientSSLEncoder(sslEngine, sslDecoder);
            sslDecoderHolder[0] = sslDecoder;
            sslEngine.beginHandshake();

            // 配置读取链: ProxyTunnelReadHandler -> ClientSSLDecoder -> HeartBeat -> HttpResponsePartDecoder -> 业务处理器
            pipeline.addReadProcessor(readHandler);
            pipeline.addReadProcessor(sslDecoder);
            pipeline.addReadProcessor(new HeartBeat(secondsOfKeepAlive, pipeline));
            pipeline.addReadProcessor(new HttpResponsePartDecoder());
            pipeline.addReadProcessor(new ReadProcessor<HttpResponsePart>()
            {
                @Override
                public void read(HttpResponsePart part, ReadProcessorNode next)
                {
                    try
                    {
                        ResponseFuture future = responseFuture;
                        if (future == null)
                        {
                            part.free();
                            next.fireRead(null);
                            return;
                        }
                        if (part.isLast())
                        {
                            responseFuture = null;
                        }
                        future.onReceive(part);
                    }
                    catch (Throwable e)
                    {
                        pipeline.shutdownInput();
                    }
                }

                @Override
                public void readFailed(Throwable e, ReadProcessorNode next)
                {
                    close();
                    ResponseFuture future = responseFuture;
                    responseFuture = null;
                    if (future != null)
                    {
                        future.onFail(e);
                    }
                }
            });

            // 配置写入链: HttpRequestPartEncoder -> HeartBeat -> ClientSSLEncoder -> ProxyTunnelWriteHandler
            pipeline.addWriteProcessor(new HttpRequestPartEncoder());
            pipeline.addWriteProcessor(new HeartBeat(secondsOfKeepAlive, pipeline));
            pipeline.addWriteProcessor(sslEncoder);
            pipeline.addWriteProcessor(writeHandler);
        }
        catch (Exception e)
        {
            tunnelErrorRef.set(e);
            tunnelLatch.countDown();
        }
    });

    if (!clientChannel.connect())
    {
        ReflectUtil.throwException(new RuntimeException("无法连接到代理服务器 " + proxyHost + ":" + proxyPort, clientChannel.getConnectionException()));
    }

    // 发送 CONNECT 请求
    String connectRequestStr = "CONNECT " + domain + ":" + port + " HTTP/1.1\r\n" +
                               "Host: " + domain + ":" + port + "\r\n" +
                               "\r\n";
    IoBuffer connectBuffer = clientChannel.pipeline().allocator().allocate(connectRequestStr.length());
    connectBuffer.put(connectRequestStr.getBytes(StandardCharsets.US_ASCII));
    clientChannel.pipeline().fireWrite(new ProxyConnectRequest().setBuffer(connectBuffer));

    // 等待隧道建立
    try
    {
        if (!tunnelLatch.await(30, TimeUnit.SECONDS))
        {
            clientChannel.pipeline().shutdownInput();
            ReflectUtil.throwException(new RuntimeException("代理隧道建立超时"));
        }
    }
    catch (InterruptedException e)
    {
        clientChannel.pipeline().shutdownInput();
        ReflectUtil.throwException(new RuntimeException("代理连接被中断", e));
    }

    if (tunnelErrorRef.get() != null)
    {
        clientChannel.pipeline().shutdownInput();
        ReflectUtil.throwException(new RuntimeException("代理隧道建立失败", tunnelErrorRef.get()));
    }

    if (!tunnelEstablished.get())
    {
        clientChannel.pipeline().shutdownInput();
        ReflectUtil.throwException(new RuntimeException("代理服务器拒绝 CONNECT 请求"));
    }

    // 启动 SSL 握手
    if (sslDecoderHolder[0] != null)
    {
        clientChannel.pipeline().fireWrite(new ClientSSLProtocol().setStartHandshake(true));
        try
        {
            if (!sslDecoderHolder[0].waitHandshake(30, TimeUnit.SECONDS))
            {
                clientChannel.pipeline().shutdownInput();
                ReflectUtil.throwException(new RuntimeException("SSL 握手超时"));
            }
        }
        catch (InterruptedException e)
        {
            clientChannel.pipeline().shutdownInput();
            ReflectUtil.throwException(new RuntimeException("SSL 握手被中断", e));
        }
    }
}
```

---

## 步骤 5：更新 HttpConnection 的 import 声明

**文件**: `src/main/java/cc/jfire/jnet/extend/http/client/HttpConnection.java`

**改动位置**: 文件开头的 import 区域

**新增 import**:

```java
import cc.jfire.jnet.extend.http.coder.ProxyConnectRequest;
import cc.jfire.jnet.extend.http.coder.ProxyTunnelReadHandler;
import cc.jfire.jnet.extend.http.coder.ProxyTunnelWriteHandler;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
```

---

## 步骤 6：在 HttpConnectionPool 中新增代理连接支持方法

**文件**: `src/main/java/cc/jfire/jnet/extend/http/client/HttpConnectionPool.java`

**改动位置**: 在类中新增方法

**改动内容**:

```java
/**
 * 构建代理连接的 key
 */
private String buildProxyKey(String host, int port, String proxyHost, int proxyPort)
{
    return proxyHost + ":" + proxyPort + "->" + host + ":" + port;
}

/**
 * 借用代理连接
 */
public HttpConnection borrowProxyConnection(String host, int port, String proxyHost, int proxyPort) throws TimeoutException, InterruptedException
{
    return borrowProxyConnection(host, port, proxyHost, proxyPort, DEFAULT_TIMEOUT_SECONDS);
}

/**
 * 借用代理连接（带超时）
 */
public HttpConnection borrowProxyConnection(String host, int port, String proxyHost, int proxyPort, int timeoutSeconds) throws TimeoutException, InterruptedException
{
    String key    = buildProxyKey(host, port, proxyHost, proxyPort);
    Bucket bucket = buckets.computeIfAbsent(key, k -> new Bucket(DEFAULT_MAX_CONNECTIONS_PER_HOST));
    // 尽可能从队列获取现有连接
    HttpConnection connection;
    while ((connection = bucket.queue.poll()) != null)
    {
        if (!connection.isConnectionClosed())
        {
            return connection;
        }
        // 连接已失效，释放许可并继续尝试下一个
        bucket.semaphore.release();
    }
    // 队列为空，尝试获取信号量许可
    if (bucket.semaphore.tryAcquire(timeoutSeconds, TimeUnit.SECONDS))
    {
        // 需要创建新连接
        try
        {
            connection = new HttpConnection(host, port, KEEP_ALIVE_SECONDS, proxyHost, proxyPort);
            return connection;
        }
        catch (Exception e)
        {
            // 创建失败，释放许可
            bucket.semaphore.release();
            throw new RuntimeException("创建代理连接失败: " + e.getMessage(), e);
        }
    }
    else
    {
        // 超时未获取到许可
        throw new TimeoutException("无法在 " + timeoutSeconds + " 秒内获取到可用代理连接，地址: " + key);
    }
}

/**
 * 归还代理连接
 */
public void returnProxyConnection(String host, int port, String proxyHost, int proxyPort, HttpConnection connection)
{
    if (connection == null)
    {
        return;
    }
    String key    = buildProxyKey(host, port, proxyHost, proxyPort);
    Bucket bucket = buckets.get(key);
    if (bucket == null)
    {
        connection.close();
        return;
    }
    // 检查连接是否有效
    if (connection.isConnectionClosed())
    {
        // 连接已失效，释放许可
        bucket.semaphore.release();
        return;
    }
    // 检查连接是否有未完成的响应
    if (connection.hasUnfinishedResponse())
    {
        // 连接状态不干净，不能复用，关闭并释放许可
        connection.close();
        bucket.semaphore.release();
        return;
    }
    // 连接有效，尝试放入队列
    boolean offered = bucket.queue.offer(connection);
    if (!offered)
    {
        // 队列已满，关闭连接并释放许可
        connection.close();
        bucket.semaphore.release();
    }
}
```

---

## 步骤 7：在 HttpClient 中新增代理请求方法

**文件**: `src/main/java/cc/jfire/jnet/extend/http/client/HttpClient.java`

**改动位置**: 在接口中新增静态方法

**改动内容**:

```java
/**
 * 通过代理服务器发送 HTTPS 请求
 *
 * @param request   HTTP 请求对象
 * @param proxyHost 代理服务器主机名
 * @param proxyPort 代理服务器端口
 * @return HTTP 响应
 */
static cc.jfire.jnet.extend.http.dto.HttpResponse newCall(HttpRequest request, String proxyHost, int proxyPort) throws Exception
{
    String         host           = request.getHead().getDomain();
    int            port           = request.getHead().getPort();
    HttpConnection httpConnection = null;
    try
    {
        // 从连接池借用代理连接（自动创建或复用）
        httpConnection = CONNECTION_POOL.borrowProxyConnection(host, port, proxyHost, proxyPort, 60);
        // 执行请求
        cc.jfire.jnet.extend.http.dto.HttpResponse response = httpConnection.write(request, 60);
        CONNECTION_POOL.returnProxyConnection(host, port, proxyHost, proxyPort, httpConnection);
        return response;
    }
    catch (Throwable e)
    {
        request.close();
        if (httpConnection != null)
        {
            // 异常时关闭连接
            httpConnection.close();
        }
        throw e;
    }
}

/**
 * 通过代理服务器发送流式 HTTPS 请求
 *
 * @param request       HTTP 请求对象
 * @param proxyHost     代理服务器主机名
 * @param proxyPort     代理服务器端口
 * @param partConsumer  响应分片消费者
 * @param errorConsumer 错误消费者
 * @return 流式响应 Future
 */
static StreamableResponseFuture newStreamCall(HttpRequest request, String proxyHost, int proxyPort,
                                               Consumer<HttpResponsePart> partConsumer,
                                               Consumer<Throwable> errorConsumer) throws Exception
{
    String         host           = request.getHead().getDomain();
    int            port           = request.getHead().getPort();
    HttpConnection httpConnection = null;
    try
    {
        httpConnection = CONNECTION_POOL.borrowProxyConnection(host, port, proxyHost, proxyPort, 60);
        final HttpConnection finalConnection = httpConnection;
        // 包装 partConsumer，在响应完成时归还连接
        Consumer<HttpResponsePart> wrappedPartConsumer = part -> {
            try
            {
                if (partConsumer != null)
                {
                    partConsumer.accept(part);
                }
            }
            finally
            {
                if (part.isLast())
                {
                    CONNECTION_POOL.returnProxyConnection(host, port, proxyHost, proxyPort, finalConnection);
                }
            }
        };
        // 包装 errorConsumer，在发生错误时关闭连接
        Consumer<Throwable> wrappedErrorConsumer = error -> {
            finalConnection.close();
            if (errorConsumer != null)
            {
                errorConsumer.accept(error);
            }
        };
        return httpConnection.write(request, wrappedPartConsumer, wrappedErrorConsumer);
    }
    catch (Throwable e)
    {
        request.close();
        if (httpConnection != null)
        {
            httpConnection.close();
        }
        throw e;
    }
}
```

---

## 总结

完成以上步骤后，客户端将支持通过 HTTP 代理服务器建立 HTTPS 连接。

---

# 第二部分：HTTP 代理支持（直接代理模式）

---

## 步骤 8：创建 ProxyHttpRequestEncoder 类

**文件**: `src/main/java/cc/jfire/jnet/extend/http/coder/ProxyHttpRequestEncoder.java`（新建文件）

**改动内容**:

```java
package cc.jfire.jnet.extend.http.coder;

import cc.jfire.baseutil.STR;
import cc.jfire.jnet.common.api.WriteProcessor;
import cc.jfire.jnet.common.api.WriteProcessorNode;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.jnet.extend.http.dto.HttpRequest;
import cc.jfire.jnet.extend.http.dto.HttpRequestChunkedBodyPart;
import cc.jfire.jnet.extend.http.dto.HttpRequestFixLengthBodyPart;
import cc.jfire.jnet.extend.http.dto.HttpRequestPartHead;

import java.nio.charset.StandardCharsets;
import java.util.Map;

import static cc.jfire.jnet.common.util.HttpCoderUtil.writeHeaderValue;

/**
 * HTTP 代理请求编码器
 * 将请求行中的路径改为完整 URL（http://host:port/path）
 */
public class ProxyHttpRequestEncoder implements WriteProcessor<Object>
{
    private static final byte[] NEW_LINE                 = "\r\n".getBytes(StandardCharsets.US_ASCII);
    private static final String CONTENT_LENGTH_HEADER    = "Content-Length";
    private static final String TRANSFER_ENCODING_HEADER = "Transfer-Encoding";

    private final String targetHost;
    private final int    targetPort;

    public ProxyHttpRequestEncoder(String targetHost, int targetPort)
    {
        this.targetHost = targetHost;
        this.targetPort = targetPort;
    }

    @Override
    public void write(Object data, WriteProcessorNode next)
    {
        if (data instanceof HttpRequest)
        {
            encodeHttpRequest((HttpRequest) data, next);
        }
        else if (data instanceof HttpRequestPartHead)
        {
            encodeHttpRequestPartHead((HttpRequestPartHead) data, next);
        }
        else if (data instanceof HttpRequestFixLengthBodyPart)
        {
            encodeFixLengthBody((HttpRequestFixLengthBodyPart) data, next);
        }
        else if (data instanceof HttpRequestChunkedBodyPart)
        {
            encodeChunkedBody((HttpRequestChunkedBodyPart) data, next);
        }
        else
        {
            next.fireWrite(data);
        }
    }

    /**
     * 构建代理请求的完整 URL
     */
    private String buildProxyUrl(String path)
    {
        if (targetPort == 80)
        {
            return "http://" + targetHost + path;
        }
        else
        {
            return "http://" + targetHost + ":" + targetPort + path;
        }
    }

    private void encodeHttpRequest(HttpRequest request, WriteProcessorNode next)
    {
        IoBuffer            buffer = next.pipeline().allocator().allocate(1024);
        HttpRequestPartHead head   = request.getHead();
        // 写入请求行（使用完整 URL）
        String proxyUrl    = buildProxyUrl(head.getPath());
        String requestLine = STR.format("{} {} {}\r\n", head.getMethod(), proxyUrl, head.getVersion() != null ? head.getVersion() : "HTTP/1.1");
        buffer.put(requestLine.getBytes(StandardCharsets.US_ASCII));
        // 计算 body 长度
        int    contentLength = 0;
        byte[] strBodyBytes  = null;
        if (request.getBody() != null)
        {
            contentLength = request.getBody().remainRead();
        }
        else if (request.getStrBody() != null)
        {
            strBodyBytes  = request.getStrBody().getBytes(StandardCharsets.UTF_8);
            contentLength = strBodyBytes.length;
        }
        boolean chunked = head.isChunked();
        if (chunked)
        {
            head.getHeaders().remove(CONTENT_LENGTH_HEADER);
            head.getHeaders().put(TRANSFER_ENCODING_HEADER, "chunked");
        }
        else
        {
            if (!head.getHeaders().containsKey(CONTENT_LENGTH_HEADER))
            {
                head.getHeaders().put(CONTENT_LENGTH_HEADER, String.valueOf(contentLength));
            }
        }
        // 写入 headers
        writeHeaderValue(head.getHeaders(), buffer);
        if (chunked)
        {
            if (contentLength > 0)
            {
                buffer.put(Integer.toHexString(contentLength).getBytes(StandardCharsets.US_ASCII));
                buffer.put(NEW_LINE);
                if (request.getBody() != null)
                {
                    buffer.put(request.getBody());
                }
                else
                {
                    buffer.put(strBodyBytes);
                }
                buffer.put(NEW_LINE);
            }
            buffer.put("0\r\n\r\n".getBytes(StandardCharsets.US_ASCII));
        }
        else
        {
            if (request.getBody() != null)
            {
                buffer.put(request.getBody());
            }
            else if (strBodyBytes != null && strBodyBytes.length > 0)
            {
                buffer.put(strBodyBytes);
            }
        }
        request.close();
        next.fireWrite(buffer);
    }

    private void encodeHttpRequestPartHead(HttpRequestPartHead head, WriteProcessorNode next)
    {
        // 代理模式下不使用 headBuffer，总是重新编码以使用完整 URL
        IoBuffer buffer      = next.pipeline().allocator().allocate(1024);
        String   proxyUrl    = buildProxyUrl(head.getPath());
        String   requestLine = STR.format("{} {} {}\r\n", head.getMethod(), proxyUrl, head.getVersion() != null ? head.getVersion() : "HTTP/1.1");
        buffer.put(requestLine.getBytes(StandardCharsets.US_ASCII));
        writeHeaderValue(head.getHeaders(), buffer);
        // 释放原始 headBuffer
        if (head.getHeadBuffer() != null)
        {
            head.getHeadBuffer().free();
            head.setHeadBuffer(null);
        }
        next.fireWrite(buffer);
    }

    private void encodeFixLengthBody(HttpRequestFixLengthBodyPart body, WriteProcessorNode next)
    {
        if (body.getPart() != null)
        {
            next.fireWrite(body.getPart());
        }
    }

    private void encodeChunkedBody(HttpRequestChunkedBodyPart body, WriteProcessorNode next)
    {
        if (body.getPart() != null)
        {
            next.fireWrite(body.getPart());
        }
    }
}
```

---

## 步骤 9：在 HttpConnection 中新增 HTTP 代理构造方法

**文件**: `src/main/java/cc/jfire/jnet/extend/http/client/HttpConnection.java`

**改动位置**: 在 HTTPS 代理构造方法之后新增

**改动内容**:

```java
/**
 * 通过 HTTP 代理创建 HTTP 连接（直接代理模式）
 *
 * @param domain             目标服务器域名
 * @param port               目标服务器端口
 * @param secondsOfKeepAlive 保活时间（秒）
 * @param proxyHost          代理服务器主机名
 * @param proxyPort          代理服务器端口
 * @param ssl                是否使用 SSL（false 表示 HTTP 直接代理模式）
 */
public HttpConnection(String domain, int port, int secondsOfKeepAlive, String proxyHost, int proxyPort, boolean ssl)
{
    if (ssl)
    {
        // HTTPS 代理：调用现有的 CONNECT 隧道模式构造方法逻辑
        // 注意：这里直接复制 HTTPS 代理逻辑，或者可以通过其他方式复用
        // 为简化，建议将 HTTPS 代理逻辑提取为私有方法
        initHttpsProxy(domain, port, secondsOfKeepAlive, proxyHost, proxyPort);
    }
    else
    {
        // HTTP 代理：直接代理模式
        initHttpProxy(domain, port, secondsOfKeepAlive, proxyHost, proxyPort);
    }
}

/**
 * 初始化 HTTP 代理连接（直接代理模式）
 */
private void initHttpProxy(String domain, int port, int secondsOfKeepAlive, String proxyHost, int proxyPort)
{
    // 连接到代理服务器
    ChannelConfig channelConfig = new ChannelConfig().setIp(proxyHost).setPort(proxyPort);
    clientChannel = ClientChannel.newClient(channelConfig, pipeline -> {
        // 配置读取链: HeartBeat -> HttpResponsePartDecoder -> 业务处理器
        pipeline.addReadProcessor(new HeartBeat(secondsOfKeepAlive, pipeline));
        pipeline.addReadProcessor(new HttpResponsePartDecoder());
        pipeline.addReadProcessor(new ReadProcessor<HttpResponsePart>()
        {
            @Override
            public void read(HttpResponsePart part, ReadProcessorNode next)
            {
                try
                {
                    ResponseFuture future = responseFuture;
                    if (future == null)
                    {
                        part.free();
                        next.fireRead(null);
                        return;
                    }
                    if (part.isLast())
                    {
                        responseFuture = null;
                    }
                    future.onReceive(part);
                }
                catch (Throwable e)
                {
                    pipeline.shutdownInput();
                }
            }

            @Override
            public void readFailed(Throwable e, ReadProcessorNode next)
            {
                close();
                ResponseFuture future = responseFuture;
                responseFuture = null;
                if (future != null)
                {
                    future.onFail(e);
                }
            }
        });

        // 配置写入链: ProxyHttpRequestEncoder -> HeartBeat
        pipeline.addWriteProcessor(new ProxyHttpRequestEncoder(domain, port));
        pipeline.addWriteProcessor(new HeartBeat(secondsOfKeepAlive, pipeline));
    });

    if (!clientChannel.connect())
    {
        ReflectUtil.throwException(new RuntimeException("无法连接到代理服务器 " + proxyHost + ":" + proxyPort, clientChannel.getConnectionException()));
    }
}

/**
 * 初始化 HTTPS 代理连接（CONNECT 隧道模式）
 * 将原有 5 参数构造方法的逻辑移到此处
 */
private void initHttpsProxy(String domain, int port, int secondsOfKeepAlive, String proxyHost, int proxyPort)
{
    // 连接到代理服务器
    ChannelConfig channelConfig = new ChannelConfig().setIp(proxyHost).setPort(proxyPort);
    ClientSSLDecoder[] sslDecoderHolder = new ClientSSLDecoder[1];
    CountDownLatch tunnelLatch = new CountDownLatch(1);
    AtomicBoolean tunnelEstablished = new AtomicBoolean(false);
    AtomicReference<Throwable> tunnelErrorRef = new AtomicReference<>();

    // 创建隧道处理器
    ProxyTunnelReadHandler readHandler = new ProxyTunnelReadHandler(tunnelLatch, tunnelEstablished, tunnelErrorRef);
    ProxyTunnelWriteHandler writeHandler = new ProxyTunnelWriteHandler();
    readHandler.setWriteHandler(writeHandler);

    clientChannel = ClientChannel.newClient(channelConfig, pipeline -> {
        try
        {
            // 初始化 SSL 引擎
            TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager()
            {
                public X509Certificate[] getAcceptedIssuers()                            {return new X509Certificate[0];}
                public void checkClientTrusted(X509Certificate[] certs, String authType) {}
                public void checkServerTrusted(X509Certificate[] certs, String authType) {}
            }};
            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(null, trustAllCerts, null);
            SSLEngine sslEngine = sslContext.createSSLEngine(domain, port);
            sslEngine.setUseClientMode(true);
            ClientSSLDecoder sslDecoder = new ClientSSLDecoder(sslEngine);
            ClientSSLEncoder sslEncoder = new ClientSSLEncoder(sslEngine, sslDecoder);
            sslDecoderHolder[0] = sslDecoder;
            sslEngine.beginHandshake();

            // 配置读取链
            pipeline.addReadProcessor(readHandler);
            pipeline.addReadProcessor(sslDecoder);
            pipeline.addReadProcessor(new HeartBeat(secondsOfKeepAlive, pipeline));
            pipeline.addReadProcessor(new HttpResponsePartDecoder());
            pipeline.addReadProcessor(new ReadProcessor<HttpResponsePart>()
            {
                @Override
                public void read(HttpResponsePart part, ReadProcessorNode next)
                {
                    try
                    {
                        ResponseFuture future = responseFuture;
                        if (future == null)
                        {
                            part.free();
                            next.fireRead(null);
                            return;
                        }
                        if (part.isLast())
                        {
                            responseFuture = null;
                        }
                        future.onReceive(part);
                    }
                    catch (Throwable e)
                    {
                        pipeline.shutdownInput();
                    }
                }

                @Override
                public void readFailed(Throwable e, ReadProcessorNode next)
                {
                    close();
                    ResponseFuture future = responseFuture;
                    responseFuture = null;
                    if (future != null)
                    {
                        future.onFail(e);
                    }
                }
            });

            // 配置写入链
            pipeline.addWriteProcessor(new HttpRequestPartEncoder());
            pipeline.addWriteProcessor(new HeartBeat(secondsOfKeepAlive, pipeline));
            pipeline.addWriteProcessor(sslEncoder);
            pipeline.addWriteProcessor(writeHandler);
        }
        catch (Exception e)
        {
            tunnelErrorRef.set(e);
            tunnelLatch.countDown();
        }
    });

    if (!clientChannel.connect())
    {
        ReflectUtil.throwException(new RuntimeException("无法连接到代理服务器 " + proxyHost + ":" + proxyPort, clientChannel.getConnectionException()));
    }

    // 发送 CONNECT 请求
    String connectRequestStr = "CONNECT " + domain + ":" + port + " HTTP/1.1\r\n" +
                               "Host: " + domain + ":" + port + "\r\n" +
                               "\r\n";
    IoBuffer connectBuffer = clientChannel.pipeline().allocator().allocate(connectRequestStr.length());
    connectBuffer.put(connectRequestStr.getBytes(StandardCharsets.US_ASCII));
    clientChannel.pipeline().fireWrite(new ProxyConnectRequest().setBuffer(connectBuffer));

    // 等待隧道建立
    try
    {
        if (!tunnelLatch.await(30, TimeUnit.SECONDS))
        {
            clientChannel.pipeline().shutdownInput();
            ReflectUtil.throwException(new RuntimeException("代理隧道建立超时"));
        }
    }
    catch (InterruptedException e)
    {
        clientChannel.pipeline().shutdownInput();
        ReflectUtil.throwException(new RuntimeException("代理连接被中断", e));
    }

    if (tunnelErrorRef.get() != null)
    {
        clientChannel.pipeline().shutdownInput();
        ReflectUtil.throwException(new RuntimeException("代理隧道建立失败", tunnelErrorRef.get()));
    }

    if (!tunnelEstablished.get())
    {
        clientChannel.pipeline().shutdownInput();
        ReflectUtil.throwException(new RuntimeException("代理服务器拒绝 CONNECT 请求"));
    }

    // 启动 SSL 握手
    if (sslDecoderHolder[0] != null)
    {
        clientChannel.pipeline().fireWrite(new ClientSSLProtocol().setStartHandshake(true));
        try
        {
            if (!sslDecoderHolder[0].waitHandshake(30, TimeUnit.SECONDS))
            {
                clientChannel.pipeline().shutdownInput();
                ReflectUtil.throwException(new RuntimeException("SSL 握手超时"));
            }
        }
        catch (InterruptedException e)
        {
            clientChannel.pipeline().shutdownInput();
            ReflectUtil.throwException(new RuntimeException("SSL 握手被中断", e));
        }
    }
}
```

---

## 步骤 10：修改原有 5 参数代理构造方法

**文件**: `src/main/java/cc/jfire/jnet/extend/http/client/HttpConnection.java`

**改动位置**: 将步骤 4 中的 5 参数构造方法修改为调用 `initHttpsProxy`

**改动内容**:

```java
/**
 * 通过 HTTP 代理创建 HTTPS 连接（使用 CONNECT 隧道模式）
 * 此构造方法默认用于 HTTPS 代理
 */
public HttpConnection(String domain, int port, int secondsOfKeepAlive, String proxyHost, int proxyPort)
{
    initHttpsProxy(domain, port, secondsOfKeepAlive, proxyHost, proxyPort);
}
```

---

## 步骤 11：更新 HttpConnection 的 import 声明（补充）

**文件**: `src/main/java/cc/jfire/jnet/extend/http/client/HttpConnection.java`

**改动位置**: 文件开头的 import 区域

**新增 import**:

```java
import cc.jfire.jnet.extend.http.coder.ProxyHttpRequestEncoder;
```

---

## 步骤 12：更新 HttpConnectionPool 支持 HTTP/HTTPS 代理区分

**文件**: `src/main/java/cc/jfire/jnet/extend/http/client/HttpConnectionPool.java`

**改动位置**: 修改代理连接相关方法

**改动内容**:

```java
/**
 * 构建代理连接的 key（区分 HTTP/HTTPS）
 */
private String buildProxyKey(String host, int port, String proxyHost, int proxyPort, boolean ssl)
{
    String protocol = ssl ? "https" : "http";
    return protocol + "://" + proxyHost + ":" + proxyPort + "->" + host + ":" + port;
}

/**
 * 借用代理连接（自动判断 HTTP/HTTPS）
 */
public HttpConnection borrowProxyConnection(String host, int port, String proxyHost, int proxyPort, boolean ssl) throws TimeoutException, InterruptedException
{
    return borrowProxyConnection(host, port, proxyHost, proxyPort, ssl, DEFAULT_TIMEOUT_SECONDS);
}

/**
 * 借用代理连接（带超时，区分 HTTP/HTTPS）
 */
public HttpConnection borrowProxyConnection(String host, int port, String proxyHost, int proxyPort, boolean ssl, int timeoutSeconds) throws TimeoutException, InterruptedException
{
    String key    = buildProxyKey(host, port, proxyHost, proxyPort, ssl);
    Bucket bucket = buckets.computeIfAbsent(key, k -> new Bucket(DEFAULT_MAX_CONNECTIONS_PER_HOST));
    // 尽可能从队列获取现有连接
    HttpConnection connection;
    while ((connection = bucket.queue.poll()) != null)
    {
        if (!connection.isConnectionClosed())
        {
            return connection;
        }
        bucket.semaphore.release();
    }
    // 队列为空，尝试获取信号量许可
    if (bucket.semaphore.tryAcquire(timeoutSeconds, TimeUnit.SECONDS))
    {
        try
        {
            connection = new HttpConnection(host, port, KEEP_ALIVE_SECONDS, proxyHost, proxyPort, ssl);
            return connection;
        }
        catch (Exception e)
        {
            bucket.semaphore.release();
            throw new RuntimeException("创建代理连接失败: " + e.getMessage(), e);
        }
    }
    else
    {
        throw new TimeoutException("无法在 " + timeoutSeconds + " 秒内获取到可用代理连接，地址: " + key);
    }
}

/**
 * 归还代理连接（区分 HTTP/HTTPS）
 */
public void returnProxyConnection(String host, int port, String proxyHost, int proxyPort, boolean ssl, HttpConnection connection)
{
    if (connection == null)
    {
        return;
    }
    String key    = buildProxyKey(host, port, proxyHost, proxyPort, ssl);
    Bucket bucket = buckets.get(key);
    if (bucket == null)
    {
        connection.close();
        return;
    }
    if (connection.isConnectionClosed())
    {
        bucket.semaphore.release();
        return;
    }
    if (connection.hasUnfinishedResponse())
    {
        connection.close();
        bucket.semaphore.release();
        return;
    }
    boolean offered = bucket.queue.offer(connection);
    if (!offered)
    {
        connection.close();
        bucket.semaphore.release();
    }
}
```

---

## 步骤 13：更新 HttpClient 代理方法以支持自动判断

**文件**: `src/main/java/cc/jfire/jnet/extend/http/client/HttpClient.java`

**改动位置**: 修改代理相关静态方法

**改动内容**:

```java
/**
 * 通过代理服务器发送请求（自动判断 HTTP/HTTPS）
 *
 * @param request   HTTP 请求对象
 * @param proxyHost 代理服务器主机名
 * @param proxyPort 代理服务器端口
 * @return HTTP 响应
 */
static cc.jfire.jnet.extend.http.dto.HttpResponse newCall(HttpRequest request, String proxyHost, int proxyPort) throws Exception
{
    String  host = request.getHead().getDomain();
    int     port = request.getHead().getPort();
    // 根据端口判断是否使用 SSL（443 为 HTTPS，其他为 HTTP）
    boolean ssl  = (port == 443);
    HttpConnection httpConnection = null;
    try
    {
        httpConnection = CONNECTION_POOL.borrowProxyConnection(host, port, proxyHost, proxyPort, ssl, 60);
        cc.jfire.jnet.extend.http.dto.HttpResponse response = httpConnection.write(request, 60);
        CONNECTION_POOL.returnProxyConnection(host, port, proxyHost, proxyPort, ssl, httpConnection);
        return response;
    }
    catch (Throwable e)
    {
        request.close();
        if (httpConnection != null)
        {
            httpConnection.close();
        }
        throw e;
    }
}

/**
 * 通过代理服务器发送流式请求（自动判断 HTTP/HTTPS）
 */
static StreamableResponseFuture newStreamCall(HttpRequest request, String proxyHost, int proxyPort,
                                               Consumer<HttpResponsePart> partConsumer,
                                               Consumer<Throwable> errorConsumer) throws Exception
{
    String  host = request.getHead().getDomain();
    int     port = request.getHead().getPort();
    boolean ssl  = (port == 443);
    HttpConnection httpConnection = null;
    try
    {
        httpConnection = CONNECTION_POOL.borrowProxyConnection(host, port, proxyHost, proxyPort, ssl, 60);
        final HttpConnection finalConnection = httpConnection;
        final boolean finalSsl = ssl;
        Consumer<HttpResponsePart> wrappedPartConsumer = part -> {
            try
            {
                if (partConsumer != null)
                {
                    partConsumer.accept(part);
                }
            }
            finally
            {
                if (part.isLast())
                {
                    CONNECTION_POOL.returnProxyConnection(host, port, proxyHost, proxyPort, finalSsl, finalConnection);
                }
            }
        };
        Consumer<Throwable> wrappedErrorConsumer = error -> {
            finalConnection.close();
            if (errorConsumer != null)
            {
                errorConsumer.accept(error);
            }
        };
        return httpConnection.write(request, wrappedPartConsumer, wrappedErrorConsumer);
    }
    catch (Throwable e)
    {
        request.close();
        if (httpConnection != null)
        {
            httpConnection.close();
        }
        throw e;
    }
}
```

---

## 总结

### 新增文件
1. `ProxyTunnelReadHandler.java` - HTTPS 代理隧道读处理器
2. `ProxyTunnelWriteHandler.java` - HTTPS 代理隧道写处理器
3. `ProxyConnectRequest.java` - CONNECT 请求包装类
4. `ProxyHttpRequestEncoder.java` - HTTP 代理请求编码器

### 修改文件
1. `HttpConnection.java` - 新增两个代理构造方法和私有初始化方法
2. `HttpConnectionPool.java` - 新增带 ssl 参数的代理连接池方法
3. `HttpClient.java` - 更新代理请求静态方法，自动判断 HTTP/HTTPS

### 使用示例

```java
// HTTPS 请求（自动使用 CONNECT 隧道模式）
HttpRequest httpsRequest = new HttpRequest()
    .setUrl("https://api.example.com/data")
    .get();
HttpResponse httpsResponse = HttpClient.newCall(httpsRequest, "127.0.0.1", 7879);

// HTTP 请求（自动使用直接代理模式）
HttpRequest httpRequest = new HttpRequest()
    .setUrl("http://api.example.com/data")
    .get();
HttpResponse httpResponse = HttpClient.newCall(httpRequest, "127.0.0.1", 7879);
```
