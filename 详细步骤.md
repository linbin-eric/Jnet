# 详细步骤

> 本文档引用了《开发指导.md》，请先阅读该文档了解目标和整体思路。

---

## 步骤 1：创建 ProxyTunnelReadHandler 类

**文件**: `src/main/java/cc/jfire/jnet/extend/http/coder/ProxyTunnelReadHandler.java`（新建文件）

**改动内容**:

```java
package cc.jfire.jnet.extend.http.coder;

import cc.jfire.jnet.common.api.ReadProcessor;
import cc.jfire.jnet.common.api.ReadProcessorNode;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;

import java.nio.charset.StandardCharsets;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

/**
 * 代理隧道读处理器
 * 在隧道建立前拦截并解析 CONNECT 响应，建立后透传数据给 SSL 解码器
 */
public class ProxyTunnelReadHandler implements ReadProcessor<IoBuffer>
{
    private final CountDownLatch             tunnelLatch;
    private final AtomicBoolean              tunnelEstablished;
    private final AtomicReference<Throwable> errorRef;

    private volatile boolean  tunnelReady = false;
    private          IoBuffer accumulation;

    public ProxyTunnelReadHandler(CountDownLatch tunnelLatch,
                                  AtomicBoolean tunnelEstablished,
                                  AtomicReference<Throwable> errorRef)
    {
        this.tunnelLatch       = tunnelLatch;
        this.tunnelEstablished = tunnelEstablished;
        this.errorRef          = errorRef;
    }

    @Override
    public void read(IoBuffer data, ReadProcessorNode next)
    {
        if (tunnelReady)
        {
            // 隧道已建立，透传数据给 SSL 解码器
            next.fireRead(data);
            return;
        }

        // 累积数据
        if (accumulation == null)
        {
            accumulation = data;
        }
        else
        {
            accumulation.put(data);
            data.free();
        }

        // 尝试解析 CONNECT 响应
        if (parseConnectResponse())
        {
            tunnelReady = true;
            tunnelEstablished.set(true);
            tunnelLatch.countDown();

            // 如果有剩余数据，传递给 SSL 解码器
            if (accumulation != null && accumulation.remainRead() > 0)
            {
                next.fireRead(accumulation);
                accumulation = null;
            }
            else if (accumulation != null)
            {
                accumulation.free();
                accumulation = null;
            }
        }
    }

    /**
     * 解析 CONNECT 响应
     * 期望格式: HTTP/1.1 200 Connection Established\r\n...\r\n\r\n
     */
    private boolean parseConnectResponse()
    {
        if (accumulation == null || accumulation.remainRead() < 4)
        {
            return false;
        }

        // 查找 \r\n\r\n 标记响应头结束
        int readPosi  = accumulation.getReadPosi();
        int writePosi = accumulation.getWritePosi();

        for (int i = readPosi; i < writePosi - 3; i++)
        {
            if (accumulation.get(i) == '\r' &&
                accumulation.get(i + 1) == '\n' &&
                accumulation.get(i + 2) == '\r' &&
                accumulation.get(i + 3) == '\n')
            {
                // 找到响应头结束位置
                int headerEndPosi = i + 4;
                int headerLength  = headerEndPosi - readPosi;

                // 解析状态行
                byte[] headerBytes = new byte[headerLength];
                for (int j = 0; j < headerLength; j++)
                {
                    headerBytes[j] = accumulation.get(readPosi + j);
                }
                String headerStr = new String(headerBytes, StandardCharsets.US_ASCII);

                // 检查状态码是否为 200
                if (headerStr.startsWith("HTTP/") && headerStr.contains(" 200 "))
                {
                    // 移动读取位置
                    accumulation.setReadPosi(headerEndPosi);
                    return true;
                }
                else
                {
                    // 代理拒绝连接
                    String statusLine = headerStr.split("\r\n")[0];
                    errorRef.set(new RuntimeException("代理服务器返回非 200 响应: " + statusLine));
                    tunnelLatch.countDown();
                    return false;
                }
            }
        }

        return false;
    }

    @Override
    public void readFailed(Throwable e, ReadProcessorNode next)
    {
        if (!tunnelReady)
        {
            errorRef.set(e);
            tunnelLatch.countDown();
        }
        if (accumulation != null)
        {
            accumulation.free();
            accumulation = null;
        }
        next.fireReadFailed(e);
    }
}
```

---

## 步骤 2：修改 HttpRequestPartEncoder 支持子类扩展

**文件**: `src/main/java/cc/jfire/jnet/extend/http/coder/HttpRequestPartEncoder.java`

**改动内容**:

1. 新增 `protected` 方法 `buildPath`，用于构建请求行中的路径部分，子类可重写此方法实现自定义路径格式
2. 将 `encodeHttpRequestPartHead` 方法改为 `protected`，允许子类重写

**具体改动**:

在类中新增以下方法（在 `write` 方法之后）：

```java
/**
 * 构建请求行中的路径部分
 * 子类可重写此方法以实现自定义路径格式（如代理模式下的完整 URL）
 *
 * @param head 请求头
 * @return 请求行中的路径部分
 */
protected String buildPath(HttpRequestPartHead head)
{
    return head.getPath();
}
```

将 `encodeHttpRequest` 方法中的请求行构建改为使用 `buildPath` 方法：

```java
// 原代码
String requestLine = STR.format("{} {} {}\r\n", head.getMethod(), head.getPath(), head.getVersion() != null ? head.getVersion() : "HTTP/1.1");

// 改为
String requestLine = STR.format("{} {} {}\r\n", head.getMethod(), buildPath(head), head.getVersion() != null ? head.getVersion() : "HTTP/1.1");
```

将 `encodeHttpRequestPartHead` 方法的访问修饰符从 `private` 改为 `protected`，并使用 `buildPath` 方法：

```java
// 原代码
private void encodeHttpRequestPartHead(HttpRequestPartHead head, WriteProcessorNode next)

// 改为
protected void encodeHttpRequestPartHead(HttpRequestPartHead head, WriteProcessorNode next)
```

同时将方法内的请求行构建也改为使用 `buildPath`：

```java
// 原代码
String requestLine = STR.format("{} {} {}\r\n", head.getMethod(), head.getPath(), head.getVersion() != null ? head.getVersion() : "HTTP/1.1");

// 改为
String requestLine = STR.format("{} {} {}\r\n", head.getMethod(), buildPath(head), head.getVersion() != null ? head.getVersion() : "HTTP/1.1");
```

---

## 步骤 3：创建 ProxyHttpRequestEncoder 类

**文件**: `src/main/java/cc/jfire/jnet/extend/http/coder/ProxyHttpRequestEncoder.java`（新建文件）

**改动内容**:

```java
package cc.jfire.jnet.extend.http.coder;

import cc.jfire.jnet.common.api.WriteProcessorNode;
import cc.jfire.jnet.extend.http.dto.HttpRequestPartHead;

/**
 * HTTP 代理请求编码器
 * 继承 HttpRequestPartEncoder，将请求行中的路径改为完整 URL（http://host:port/path）
 */
public class ProxyHttpRequestEncoder extends HttpRequestPartEncoder
{
    private final String targetHost;
    private final int    targetPort;

    public ProxyHttpRequestEncoder(String targetHost, int targetPort)
    {
        this.targetHost = targetHost;
        this.targetPort = targetPort;
    }

    /**
     * 重写 buildPath 方法，返回代理模式下的完整 URL
     */
    @Override
    protected String buildPath(HttpRequestPartHead head)
    {
        if (targetPort == 80)
        {
            return "http://" + targetHost + head.getPath();
        }
        else
        {
            return "http://" + targetHost + ":" + targetPort + head.getPath();
        }
    }

    /**
     * 重写 encodeHttpRequestPartHead 方法
     * 代理模式下不使用 headBuffer，总是重新编码以使用完整 URL
     */
    @Override
    protected void encodeHttpRequestPartHead(HttpRequestPartHead head, WriteProcessorNode next)
    {
        // 释放原始 headBuffer，强制重新编码
        if (head.getHeadBuffer() != null)
        {
            head.getHeadBuffer().free();
            head.setHeadBuffer(null);
        }
        // 调用父类方法进行编码（会使用重写的 buildPath 方法）
        super.encodeHttpRequestPartHead(head, next);
    }
}
```

---

## 步骤 4：在 HttpConnection 中新增代理连接支持

**文件**: `src/main/java/cc/jfire/jnet/extend/http/client/HttpConnection.java`

**改动位置**: 文件开头的 import 区域新增 import，并在类中新增构造方法和私有初始化方法

**新增 import**:

```java
import cc.jfire.jnet.extend.http.coder.ProxyHttpRequestEncoder;
import cc.jfire.jnet.extend.http.coder.ProxyTunnelReadHandler;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
```

**新增构造方法和私有方法**（在现有构造方法之后添加）:

```java
/**
 * 通过 HTTP 代理创建连接（支持 HTTP/HTTPS 两种模式）
 *
 * @param domain             目标服务器域名
 * @param port               目标服务器端口
 * @param config             客户端配置
 * @param proxyHost          代理服务器主机名
 * @param proxyPort          代理服务器端口
 * @param ssl                是否使用 SSL（true 为 HTTPS 代理隧道模式，false 为 HTTP 直接代理模式）
 */
public HttpConnection(String domain, int port, HttpClientConfig config, String proxyHost, int proxyPort, boolean ssl)
{
    if (ssl)
    {
        initHttpsProxy(domain, port, config.getKeepAliveSeconds(), proxyHost, proxyPort);
    }
    else
    {
        initHttpProxy(domain, port, config.getKeepAliveSeconds(), proxyHost, proxyPort);
    }
}

/**
 * 初始化 HTTP 代理连接（直接代理模式）
 */
private void initHttpProxy(String domain, int port, int secondsOfKeepAlive, String proxyHost, int proxyPort)
{
    // 连接到代理服务器
    ChannelConfig channelConfig = new ChannelConfig().setIp(proxyHost).setPort(proxyPort);
    clientChannel = ClientChannel.newClient(channelConfig, pipeline -> {
        // 配置读取链: HeartBeat -> HttpResponsePartDecoder -> 业务处理器
        pipeline.addReadProcessor(new HeartBeat(secondsOfKeepAlive, pipeline));
        pipeline.addReadProcessor(new HttpResponsePartDecoder());
        pipeline.addReadProcessor(new ReadProcessor<HttpResponsePart>()
        {
            @Override
            public void read(HttpResponsePart part, ReadProcessorNode next)
            {
                try
                {
                    ResponseFuture future = responseFuture;
                    if (future == null)
                    {
                        part.free();
                        next.fireRead(null);
                        return;
                    }
                    if (part.isLast())
                    {
                        responseFuture = null;
                    }
                    future.onReceive(part);
                }
                catch (Throwable e)
                {
                    pipeline.shutdownInput();
                }
            }

            @Override
            public void readFailed(Throwable e, ReadProcessorNode next)
            {
                close();
                ResponseFuture future = responseFuture;
                responseFuture = null;
                if (future != null)
                {
                    future.onFail(e);
                }
            }
        });

        // 配置写入链: ProxyHttpRequestEncoder -> HeartBeat
        pipeline.addWriteProcessor(new ProxyHttpRequestEncoder(domain, port));
        pipeline.addWriteProcessor(new HeartBeat(secondsOfKeepAlive, pipeline));
    });

    if (!clientChannel.connect())
    {
        ReflectUtil.throwException(new RuntimeException("无法连接到代理服务器 " + proxyHost + ":" + proxyPort, clientChannel.getConnectionException()));
    }
}

/**
 * 初始化 HTTPS 代理连接（CONNECT 隧道模式）
 */
private void initHttpsProxy(String domain, int port, int secondsOfKeepAlive, String proxyHost, int proxyPort)
{
    // 连接到代理服务器
    ChannelConfig channelConfig = new ChannelConfig().setIp(proxyHost).setPort(proxyPort);
    ClientSSLDecoder[] sslDecoderHolder = new ClientSSLDecoder[1];
    CountDownLatch tunnelLatch = new CountDownLatch(1);
    AtomicBoolean tunnelEstablished = new AtomicBoolean(false);
    AtomicReference<Throwable> tunnelErrorRef = new AtomicReference<>();

    // 创建隧道读处理器
    ProxyTunnelReadHandler tunnelReadHandler = new ProxyTunnelReadHandler(tunnelLatch, tunnelEstablished, tunnelErrorRef);

    clientChannel = ClientChannel.newClient(channelConfig, pipeline -> {
        try
        {
            // 初始化 SSL 引擎
            TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager()
            {
                public X509Certificate[] getAcceptedIssuers()                            {return new X509Certificate[0];}
                public void checkClientTrusted(X509Certificate[] certs, String authType) {}
                public void checkServerTrusted(X509Certificate[] certs, String authType) {}
            }};
            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(null, trustAllCerts, null);
            SSLEngine sslEngine = sslContext.createSSLEngine(domain, port);
            sslEngine.setUseClientMode(true);
            ClientSSLDecoder sslDecoder = new ClientSSLDecoder(sslEngine);
            ClientSSLEncoder sslEncoder = new ClientSSLEncoder(sslEngine, sslDecoder);
            sslDecoderHolder[0] = sslDecoder;
            sslEngine.beginHandshake();

            // 配置读取链: ProxyTunnelReadHandler -> ClientSSLDecoder -> HeartBeat -> HttpResponsePartDecoder -> 业务处理器
            pipeline.addReadProcessor(tunnelReadHandler);
            pipeline.addReadProcessor(sslDecoder);
            pipeline.addReadProcessor(new HeartBeat(secondsOfKeepAlive, pipeline));
            pipeline.addReadProcessor(new HttpResponsePartDecoder());
            pipeline.addReadProcessor(new ReadProcessor<HttpResponsePart>()
            {
                @Override
                public void read(HttpResponsePart part, ReadProcessorNode next)
                {
                    try
                    {
                        ResponseFuture future = responseFuture;
                        if (future == null)
                        {
                            part.free();
                            next.fireRead(null);
                            return;
                        }
                        if (part.isLast())
                        {
                            responseFuture = null;
                        }
                        future.onReceive(part);
                    }
                    catch (Throwable e)
                    {
                        pipeline.shutdownInput();
                    }
                }

                @Override
                public void readFailed(Throwable e, ReadProcessorNode next)
                {
                    close();
                    ResponseFuture future = responseFuture;
                    responseFuture = null;
                    if (future != null)
                    {
                        future.onFail(e);
                    }
                }
            });

            // 配置写入链: HttpRequestPartEncoder -> HeartBeat -> ClientSSLEncoder
            pipeline.addWriteProcessor(new HttpRequestPartEncoder());
            pipeline.addWriteProcessor(new HeartBeat(secondsOfKeepAlive, pipeline));
            pipeline.addWriteProcessor(sslEncoder);
        }
        catch (Exception e)
        {
            tunnelErrorRef.set(e);
            tunnelLatch.countDown();
        }
    });

    if (!clientChannel.connect())
    {
        ReflectUtil.throwException(new RuntimeException("无法连接到代理服务器 " + proxyHost + ":" + proxyPort, clientChannel.getConnectionException()));
    }

    // 发送 CONNECT 请求（使用 directWrite 直接写出，绕过写处理器链）
    String connectRequestStr = "CONNECT " + domain + ":" + port + " HTTP/1.1\r\n" +
                               "Host: " + domain + ":" + port + "\r\n" +
                               "\r\n";
    IoBuffer connectBuffer = clientChannel.pipeline().allocator().allocate(connectRequestStr.length());
    connectBuffer.put(connectRequestStr.getBytes(StandardCharsets.US_ASCII));
    clientChannel.pipeline().directWrite(connectBuffer);

    // 等待隧道建立
    try
    {
        if (!tunnelLatch.await(30, TimeUnit.SECONDS))
        {
            clientChannel.pipeline().shutdownInput();
            ReflectUtil.throwException(new RuntimeException("代理隧道建立超时"));
        }
    }
    catch (InterruptedException e)
    {
        clientChannel.pipeline().shutdownInput();
        ReflectUtil.throwException(new RuntimeException("代理连接被中断", e));
    }

    if (tunnelErrorRef.get() != null)
    {
        clientChannel.pipeline().shutdownInput();
        ReflectUtil.throwException(new RuntimeException("代理隧道建立失败", tunnelErrorRef.get()));
    }

    if (!tunnelEstablished.get())
    {
        clientChannel.pipeline().shutdownInput();
        ReflectUtil.throwException(new RuntimeException("代理服务器拒绝 CONNECT 请求"));
    }

    // 启动 SSL 握手
    if (sslDecoderHolder[0] != null)
    {
        clientChannel.pipeline().fireWrite(new ClientSSLProtocol().setStartHandshake(true));
        try
        {
            if (!sslDecoderHolder[0].waitHandshake(30, TimeUnit.SECONDS))
            {
                clientChannel.pipeline().shutdownInput();
                ReflectUtil.throwException(new RuntimeException("SSL 握手超时"));
            }
        }
        catch (InterruptedException e)
        {
            clientChannel.pipeline().shutdownInput();
            ReflectUtil.throwException(new RuntimeException("SSL 握手被中断", e));
        }
    }
}
```

---

## 步骤 5：在 HttpConnectionPool 中新增代理连接池方法

**文件**: `src/main/java/cc/jfire/jnet/extend/http/client/HttpConnectionPool.java`

**改动位置**: 在类中新增方法（在现有方法之后添加）

**改动内容**:

```java
/**
 * 构建代理连接的 key（区分 HTTP/HTTPS）
 */
private String buildProxyKey(String host, int port, String proxyHost, int proxyPort, boolean ssl)
{
    String protocol = ssl ? "https" : "http";
    return protocol + "://" + proxyHost + ":" + proxyPort + "->" + host + ":" + port;
}

/**
 * 借用代理连接
 */
public HttpConnection borrowProxyConnection(String host, int port, String proxyHost, int proxyPort, boolean ssl) throws TimeoutException, InterruptedException
{
    return borrowProxyConnection(host, port, proxyHost, proxyPort, ssl, config.getAcquireTimeoutSeconds());
}

/**
 * 借用代理连接（带超时）
 */
public HttpConnection borrowProxyConnection(String host, int port, String proxyHost, int proxyPort, boolean ssl, int timeoutSeconds) throws TimeoutException, InterruptedException
{
    String key    = buildProxyKey(host, port, proxyHost, proxyPort, ssl);
    Bucket bucket = buckets.computeIfAbsent(key, k -> new Bucket(config.getMaxConnectionsPerHost()));
    // 尽可能从队列获取现有连接
    HttpConnection connection;
    while ((connection = bucket.queue.poll()) != null)
    {
        if (!connection.isConnectionClosed())
        {
            return connection;
        }
        bucket.semaphore.release();
    }
    // 队列为空，尝试获取信号量许可
    if (bucket.semaphore.tryAcquire(timeoutSeconds, TimeUnit.SECONDS))
    {
        try
        {
            connection = new HttpConnection(host, port, config, proxyHost, proxyPort, ssl);
            return connection;
        }
        catch (Exception e)
        {
            bucket.semaphore.release();
            throw new RuntimeException("创建代理连接失败: " + e.getMessage(), e);
        }
    }
    else
    {
        throw new TimeoutException("无法在 " + timeoutSeconds + " 秒内获取到可用代理连接，地址: " + key);
    }
}

/**
 * 归还代理连接
 */
public void returnProxyConnection(String host, int port, String proxyHost, int proxyPort, boolean ssl, HttpConnection connection)
{
    if (connection == null)
    {
        return;
    }
    String key    = buildProxyKey(host, port, proxyHost, proxyPort, ssl);
    Bucket bucket = buckets.get(key);
    if (bucket == null)
    {
        connection.close();
        return;
    }
    if (connection.isConnectionClosed())
    {
        bucket.semaphore.release();
        return;
    }
    if (connection.hasUnfinishedResponse())
    {
        connection.close();
        bucket.semaphore.release();
        return;
    }
    boolean offered = bucket.queue.offer(connection);
    if (!offered)
    {
        connection.close();
        bucket.semaphore.release();
    }
}
```

---

## 步骤 6：在 HttpClient 中新增代理请求方法

**文件**: `src/main/java/cc/jfire/jnet/extend/http/client/HttpClient.java`

**改动位置**: 在类中新增实例方法和静态方法

**改动内容**:

```java
/**
 * 通过代理服务器发起同步 HTTP 请求
 *
 * @param request   HTTP 请求对象
 * @param proxyHost 代理服务器主机名
 * @param proxyPort 代理服务器端口
 * @return HTTP 响应
 */
public cc.jfire.jnet.extend.http.dto.HttpResponse callWithProxy(HttpRequest request, String proxyHost, int proxyPort) throws Exception
{
    String  host = request.getHead().getDomain();
    int     port = request.getHead().getPort();
    // 根据端口判断是否使用 SSL（443 为 HTTPS，其他为 HTTP）
    boolean ssl  = (port == 443);
    HttpConnection httpConnection = null;
    try
    {
        httpConnection = connectionPool.borrowProxyConnection(host, port, proxyHost, proxyPort, ssl);
        cc.jfire.jnet.extend.http.dto.HttpResponse response = httpConnection.write(request, config.getReadTimeoutSeconds());
        connectionPool.returnProxyConnection(host, port, proxyHost, proxyPort, ssl, httpConnection);
        return response;
    }
    catch (Throwable e)
    {
        request.close();
        if (httpConnection != null)
        {
            httpConnection.close();
        }
        throw e;
    }
}

/**
 * 通过代理服务器发起流式 HTTP 请求
 *
 * @param request       HTTP 请求对象
 * @param proxyHost     代理服务器主机名
 * @param proxyPort     代理服务器端口
 * @param partConsumer  响应分片消费者
 * @param errorConsumer 错误消费者
 * @return 流式响应 Future
 */
public StreamableResponseFuture streamCallWithProxy(HttpRequest request, String proxyHost, int proxyPort,
                                                     Consumer<HttpResponsePart> partConsumer,
                                                     Consumer<Throwable> errorConsumer) throws Exception
{
    String  host = request.getHead().getDomain();
    int     port = request.getHead().getPort();
    boolean ssl  = (port == 443);
    HttpConnection httpConnection = null;
    try
    {
        httpConnection = connectionPool.borrowProxyConnection(host, port, proxyHost, proxyPort, ssl);
        final HttpConnection finalConnection = httpConnection;
        final boolean finalSsl = ssl;
        Consumer<HttpResponsePart> wrappedPartConsumer = part -> {
            try
            {
                if (partConsumer != null)
                {
                    partConsumer.accept(part);
                }
            }
            finally
            {
                if (part.isLast())
                {
                    connectionPool.returnProxyConnection(host, port, proxyHost, proxyPort, finalSsl, finalConnection);
                }
            }
        };
        Consumer<Throwable> wrappedErrorConsumer = error -> {
            finalConnection.close();
            if (errorConsumer != null)
            {
                errorConsumer.accept(error);
            }
        };
        return httpConnection.write(request, wrappedPartConsumer, wrappedErrorConsumer);
    }
    catch (Throwable e)
    {
        request.close();
        if (httpConnection != null)
        {
            httpConnection.close();
        }
        throw e;
    }
}

// ==================== 代理相关静态便捷方法（向后兼容） ====================

/**
 * 使用默认实例通过代理发起同步 HTTP 请求（向后兼容）
 */
public static cc.jfire.jnet.extend.http.dto.HttpResponse newCall(HttpRequest request, String proxyHost, int proxyPort) throws Exception
{
    return DEFAULT_INSTANCE.callWithProxy(request, proxyHost, proxyPort);
}

/**
 * 使用默认实例通过代理发起流式 HTTP 请求（向后兼容）
 */
public static StreamableResponseFuture newStreamCall(HttpRequest request, String proxyHost, int proxyPort,
                                                      Consumer<HttpResponsePart> partConsumer,
                                                      Consumer<Throwable> errorConsumer) throws Exception
{
    return DEFAULT_INSTANCE.streamCallWithProxy(request, proxyHost, proxyPort, partConsumer, errorConsumer);
}
```

---

## 总结

### 新增文件（2 个）
1. `ProxyTunnelReadHandler.java` - HTTPS 代理隧道读处理器
2. `ProxyHttpRequestEncoder.java` - HTTP 代理请求编码器（继承 HttpRequestPartEncoder）

### 修改文件（4 个）
1. `HttpRequestPartEncoder.java` - 新增 `buildPath` 方法支持子类扩展
2. `HttpConnection.java` - 新增代理构造方法和两个私有初始化方法
3. `HttpConnectionPool.java` - 新增代理连接池管理方法
4. `HttpClient.java` - 新增代理请求的实例方法和静态方法

### 使用示例

```java
// HTTPS 请求（自动使用 CONNECT 隧道模式）
HttpRequest httpsRequest = new HttpRequest()
    .setUrl("https://api.example.com/data")
    .get();
HttpResponse httpsResponse = HttpClient.newCall(httpsRequest, "127.0.0.1", 7879);

// HTTP 请求（自动使用直接代理模式）
HttpRequest httpRequest = new HttpRequest()
    .setUrl("http://api.example.com/data")
    .get();
HttpResponse httpResponse = HttpClient.newCall(httpRequest, "127.0.0.1", 7879);

// 使用实例化方式（推荐）
HttpClient client = new HttpClient(new HttpClientConfig().setMaxConnectionsPerHost(20));
HttpResponse response = client.callWithProxy(request, "127.0.0.1", 7879);
```
