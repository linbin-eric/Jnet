# 详细步骤

> 本文档引用了《开发指导.md》，是对其详细思路的具体代码实现步骤。

---

## 步骤 1：修改 HttpUrl 类，新增 ssl 字段

**文件**：`src/main/java/cc/jfire/jnet/extend/http/dto/HttpUrl.java`

**改动内容**：

1. 在 record 声明中新增 `boolean ssl` 字段：

```java
public record HttpUrl(String domain, int port, String path, String hostHeader, boolean ssl)
```

2. 修改 `parse` 方法的返回语句，传入 `isHttps` 值：

```java
return new HttpUrl(domain, port, path, hostHeader, isHttps);
```

---

## 步骤 2：修改 HttpRequest 类，新增 ssl 字段

**文件**：`src/main/java/cc/jfire/jnet/extend/http/dto/HttpRequest.java`

**改动内容**：

1. 在类中新增字段（在 `strBody` 字段之后）：

```java
protected boolean ssl = false;
```

2. 修改 `setUrl` 方法，从 `HttpUrl` 获取并保存 ssl 信息：

```java
public HttpRequest setUrl(String url)
{
    HttpUrl parsed = HttpUrl.parse(url);
    this.ssl = parsed.ssl();
    head.setUrl(url);
    return this;
}
```

3. 添加 getter 方法：

```java
public boolean isSsl()
{
    return ssl;
}
```

---

## 步骤 3：修改 HttpConnectionPool，支持配置和 SSL

**文件**：`src/main/java/cc/jfire/jnet/extend/http/client/HttpConnectionPool.java`

**改动内容**：

1. 删除硬编码的静态常量 `DEFAULT_MAX_CONNECTIONS_PER_HOST`、`DEFAULT_TIMEOUT_SECONDS`、`KEEP_ALIVE_SECONDS`。

2. 新增实例字段：

```java
private final HttpClientConfig config;
```

3. 新增构造方法：

```java
public HttpConnectionPool(HttpClientConfig config)
{
    this.config = config;
}
```

4. 修改 `buildKey` 方法，区分 HTTP 和 HTTPS：

```java
private String buildKey(String host, int port, boolean ssl)
{
    return (ssl ? "https://" : "http://") + host + ":" + port;
}
```

5. 修改 `borrowConnection` 方法签名，新增 `ssl` 参数：

```java
public HttpConnection borrowConnection(String host, int port, boolean ssl) throws TimeoutException, InterruptedException
{
    return borrowConnection(host, port, ssl, config.getAcquireTimeoutSeconds());
}

public HttpConnection borrowConnection(String host, int port, boolean ssl, int timeoutSeconds) throws TimeoutException, InterruptedException
{
    String key    = buildKey(host, port, ssl);
    Bucket bucket = buckets.computeIfAbsent(key, k -> new Bucket(config.getMaxConnectionsPerHost()));
    // 尽可能从队列获取现有连接
    HttpConnection connection;
    while ((connection = bucket.queue.poll()) != null)
    {
        if (!connection.isConnectionClosed())
        {
            return connection;
        }
        // 连接已失效，释放许可并继续尝试下一个
        bucket.semaphore.release();
    }
    // 队列为空，尝试获取信号量许可
    if (bucket.semaphore.tryAcquire(timeoutSeconds, TimeUnit.SECONDS))
    {
        // 需要创建新连接
        try
        {
            connection = new HttpConnection(host, port, config, ssl);
            return connection;
        }
        catch (Exception e)
        {
            // 创建失败，释放许可
            bucket.semaphore.release();
            throw new RuntimeException("创建连接失败: " + e.getMessage(), e);
        }
    }
    else
    {
        // 超时未获取到许可
        throw new TimeoutException("无法在 " + timeoutSeconds + " 秒内获取到可用连接，地址: " + key);
    }
}
```

6. 修改 `returnConnection` 方法签名，新增 `ssl` 参数：

```java
public void returnConnection(String host, int port, boolean ssl, HttpConnection connection)
{
    if (connection == null)
    {
        return;
    }
    String key    = buildKey(host, port, ssl);
    Bucket bucket = buckets.get(key);
    if (bucket == null)
    {
        connection.close();
        return;
    }
    // 检查连接是否有效
    if (connection.isConnectionClosed())
    {
        // 连接已失效，释放许可
        bucket.semaphore.release();
        return;
    }
    // 检查连接是否有未完成的响应
    if (connection.hasUnfinishedResponse())
    {
        // 连接状态不干净，不能复用，关闭并释放许可
        connection.close();
        bucket.semaphore.release();
        return;
    }
    // 连接有效，尝试放入队列
    boolean offered = bucket.queue.offer(connection);
    if (!offered)
    {
        // 队列已满，关闭连接并释放许可
        connection.close();
        bucket.semaphore.release();
    }
}
```

7. 修改 `getConnectionCount`、`getPoolSize`、`getAvailablePermits` 方法，新增 `ssl` 参数：

```java
public int getConnectionCount(String host, int port, boolean ssl)
{
    String key    = buildKey(host, port, ssl);
    Bucket bucket = buckets.get(key);
    return bucket != null ? bucket.maxConnections - bucket.semaphore.availablePermits() : 0;
}

public int getPoolSize(String host, int port, boolean ssl)
{
    String key    = buildKey(host, port, ssl);
    Bucket bucket = buckets.get(key);
    return bucket != null ? bucket.queue.size() : 0;
}

public int getAvailablePermits(String host, int port, boolean ssl)
{
    String key    = buildKey(host, port, ssl);
    Bucket bucket = buckets.get(key);
    return bucket != null ? bucket.semaphore.availablePermits() : 0;
}
```

---

## 步骤 4：修改 HttpConnection，新增支持配置的构造方法

**文件**：`src/main/java/cc/jfire/jnet/extend/http/client/HttpConnection.java`

**改动内容**：

新增一个接收 `HttpClientConfig` 的构造方法。在现有的两个构造方法之后添加：

```java
public HttpConnection(String domain, int port, HttpClientConfig config, boolean ssl)
{
    ChannelConfig      channelConfig    = new ChannelConfig().setIp(domain).setPort(port);
    ClientSSLDecoder[] sslDecoderHolder = new ClientSSLDecoder[1];
    int                keepAliveSeconds = config.getKeepAliveSeconds();
    clientChannel = ClientChannel.newClient(channelConfig, pipeline -> {
        if (ssl)
        {
            try
            {
                TrustManager[] trustManagers = config.getTrustManagers();
                if (trustManagers == null)
                {
                    // 默认信任所有证书
                    trustManagers = new TrustManager[]{new X509TrustManager()
                    {
                        public X509Certificate[] getAcceptedIssuers()                            {return new X509Certificate[0];}

                        public void checkClientTrusted(X509Certificate[] certs, String authType) {}

                        public void checkServerTrusted(X509Certificate[] certs, String authType) {}
                    }};
                }
                SSLContext sslContext = SSLContext.getInstance("TLS");
                sslContext.init(null, trustManagers, null);
                SSLEngine sslEngine = sslContext.createSSLEngine(domain, port);
                sslEngine.setUseClientMode(true);
                ClientSSLDecoder sslDecoder = new ClientSSLDecoder(sslEngine);
                ClientSSLEncoder sslEncoder = new ClientSSLEncoder(sslEngine, sslDecoder);
                sslDecoderHolder[0] = sslDecoder;
                sslEngine.beginHandshake();
                pipeline.addReadProcessor(sslDecoder);
                pipeline.addReadProcessor(new HeartBeat(keepAliveSeconds, pipeline));
                pipeline.addReadProcessor(new HttpResponsePartDecoder());
                pipeline.addReadProcessor(new ReadProcessor<HttpResponsePart>()
                {
                    @Override
                    public void read(HttpResponsePart part, ReadProcessorNode next)
                    {
                        try
                        {
                            ResponseFuture future = responseFuture;
                            if (future == null)
                            {
                                part.free();
                                next.fireRead(null);
                                return;
                            }
                            if (part.isLast())
                            {
                                responseFuture = null;
                            }
                            future.onReceive(part);
                        }
                        catch (Throwable e)
                        {
                            pipeline.shutdownInput();
                        }
                    }

                    @Override
                    public void readFailed(Throwable e, ReadProcessorNode next)
                    {
                        close();
                        ResponseFuture future = responseFuture;
                        responseFuture = null;
                        if (future != null)
                        {
                            future.onFail(e);
                        }
                    }
                });
                pipeline.addWriteProcessor(new HttpRequestPartEncoder());
                pipeline.addWriteProcessor(new HeartBeat(keepAliveSeconds, pipeline));
                pipeline.addWriteProcessor(sslEncoder);
            }
            catch (Exception e)
            {
                ReflectUtil.throwException(new RuntimeException("SSL 初始化失败", e));
            }
        }
        else
        {
            pipeline.addReadProcessor(new HeartBeat(keepAliveSeconds, pipeline));
            pipeline.addReadProcessor(new HttpResponsePartDecoder());
            pipeline.addReadProcessor(new ReadProcessor<HttpResponsePart>()
            {
                @Override
                public void read(HttpResponsePart part, ReadProcessorNode next)
                {
                    try
                    {
                        ResponseFuture future = responseFuture;
                        if (future == null)
                        {
                            part.free();
                            next.fireRead(null);
                            return;
                        }
                        if (part.isLast())
                        {
                            responseFuture = null;
                        }
                        future.onReceive(part);
                    }
                    catch (Throwable e)
                    {
                        pipeline.shutdownInput();
                    }
                }

                @Override
                public void readFailed(Throwable e, ReadProcessorNode next)
                {
                    close();
                    ResponseFuture future = responseFuture;
                    responseFuture = null;
                    if (future != null)
                    {
                        future.onFail(e);
                    }
                }
            });
            pipeline.addWriteProcessor(new HttpRequestPartEncoder());
            pipeline.addWriteProcessor(new HeartBeat(keepAliveSeconds, pipeline));
        }
    });
    if (!clientChannel.connect())
    {
        ReflectUtil.throwException(new RuntimeException("无法连接 " + domain + ":" + port, clientChannel.getConnectionException()));
    }
    if (ssl && sslDecoderHolder[0] != null)
    {
        clientChannel.pipeline().fireWrite(new ClientSSLProtocol().setStartHandshake(true));
        try
        {
            if (!sslDecoderHolder[0].waitHandshake(config.getSslHandshakeTimeoutSeconds(), TimeUnit.SECONDS))
            {
                clientChannel.pipeline().shutdownInput();
                ReflectUtil.throwException(new RuntimeException("SSL 握手超时"));
            }
        }
        catch (InterruptedException e)
        {
            clientChannel.pipeline().shutdownInput();
            ReflectUtil.throwException(new RuntimeException("SSL 握手被中断", e));
        }
    }
}
```

---

## 步骤 5：将 HttpClient 从接口改为类

**文件**：`src/main/java/cc/jfire/jnet/extend/http/client/HttpClient.java`

**改动内容**：

将整个文件替换为以下内容：

```java
package cc.jfire.jnet.extend.http.client;

import cc.jfire.jnet.extend.http.dto.HttpRequest;
import cc.jfire.jnet.extend.http.dto.HttpResponsePart;

import java.util.function.Consumer;

public class HttpClient
{
    private static final HttpClient DEFAULT_INSTANCE = new HttpClient();

    private final HttpClientConfig   config;
    private final HttpConnectionPool connectionPool;

    public HttpClient()
    {
        this(new HttpClientConfig());
    }

    public HttpClient(HttpClientConfig config)
    {
        this.config         = config;
        this.connectionPool = new HttpConnectionPool(config);
    }

    public HttpClientConfig getConfig()
    {
        return config;
    }

    public HttpConnectionPool getConnectionPool()
    {
        return connectionPool;
    }

    /**
     * 发起同步 HTTP 请求
     */
    public cc.jfire.jnet.extend.http.dto.HttpResponse call(HttpRequest request) throws Exception
    {
        String         host           = request.getHead().getDomain();
        int            port           = request.getHead().getPort();
        boolean        ssl            = request.isSsl();
        HttpConnection httpConnection = null;
        try
        {
            httpConnection = connectionPool.borrowConnection(host, port, ssl);
            cc.jfire.jnet.extend.http.dto.HttpResponse response = httpConnection.write(request, config.getReadTimeoutSeconds());
            connectionPool.returnConnection(host, port, ssl, httpConnection);
            return response;
        }
        catch (Throwable e)
        {
            request.close();
            if (httpConnection != null)
            {
                httpConnection.close();
            }
            throw e;
        }
    }

    /**
     * 发起流式 HTTP 请求
     */
    public StreamableResponseFuture streamCall(HttpRequest request, Consumer<HttpResponsePart> partConsumer, Consumer<Throwable> errorConsumer) throws Exception
    {
        String         host           = request.getHead().getDomain();
        int            port           = request.getHead().getPort();
        boolean        ssl            = request.isSsl();
        HttpConnection httpConnection = null;
        try
        {
            httpConnection = connectionPool.borrowConnection(host, port, ssl);
            final HttpConnection finalConnection = httpConnection;
            final boolean        finalSsl        = ssl;
            Consumer<HttpResponsePart> wrappedPartConsumer = part -> {
                try
                {
                    if (partConsumer != null)
                    {
                        partConsumer.accept(part);
                    }
                }
                finally
                {
                    if (part.isLast())
                    {
                        connectionPool.returnConnection(host, port, finalSsl, finalConnection);
                    }
                }
            };
            Consumer<Throwable> wrappedErrorConsumer = error -> {
                finalConnection.close();
                if (errorConsumer != null)
                {
                    errorConsumer.accept(error);
                }
            };
            return httpConnection.write(request, wrappedPartConsumer, wrappedErrorConsumer);
        }
        catch (Throwable e)
        {
            request.close();
            if (httpConnection != null)
            {
                httpConnection.close();
            }
            throw e;
        }
    }

    // ==================== 静态便捷方法（向后兼容） ====================

    /**
     * 使用默认实例发起同步 HTTP 请求（向后兼容）
     */
    public static cc.jfire.jnet.extend.http.dto.HttpResponse newCall(HttpRequest request) throws Exception
    {
        return DEFAULT_INSTANCE.call(request);
    }

    /**
     * 使用默认实例发起流式 HTTP 请求（向后兼容）
     */
    public static StreamableResponseFuture newStreamCall(HttpRequest request, Consumer<HttpResponsePart> partConsumer, Consumer<Throwable> errorConsumer) throws Exception
    {
        return DEFAULT_INSTANCE.streamCall(request, partConsumer, errorConsumer);
    }

    /**
     * 获取默认实例
     */
    public static HttpClient getDefault()
    {
        return DEFAULT_INSTANCE;
    }
}
```

---

## 步骤 6：删除 HttpClient 接口中的旧静态字段

此步骤已在步骤 5 中完成。原接口中的 `CONNECTION_POOL` 静态字段已被移除，改为实例持有的 `connectionPool` 字段。
