# 详细步骤

> 本文档引用了《开发指导.md》，按照其中的详细思路进行具体代码改动。

## 步骤 1：修改 SSLDecoder - 握手阶段使用 directWrite

**文件**: `src/main/java/cc/jfire/jnet/extend/http/coder/SSLDecoder.java`

**改动位置**: `handshake` 方法中 `NEED_WRAP` 分支（约第 126-148 行）

**改动内容**: 将 `next.pipeline().fireWrite(new SSLProtocol().setData(dst))` 改为 `next.pipeline().directWrite(dst)`

```java
// 原代码
if (bytesProduced > 0)
{
    next.pipeline().fireWrite(new SSLProtocol().setData(dst));
}

// 改为
if (bytesProduced > 0)
{
    next.pipeline().directWrite(dst);
}
```

## 步骤 2：修改 SSLDecoder - gracefulClose 使用 directWrite

**文件**: `src/main/java/cc/jfire/jnet/extend/http/coder/SSLDecoder.java`

**改动位置**: `gracefulClose` 方法（约第 42-60 行）

**改动内容**: 将 `pipeline.fireWrite(new SSLProtocol().setCloseNotify(true))` 改为直接生成关闭消息并调用 `directWrite`

```java
// 原代码
public synchronized void gracefulClose(Pipeline pipeline)
{
    if (closeInbound)
    {
        return;
    }
    closeInbound = true;
    try
    {
        sslEngine.closeInbound();
    }
    catch (SSLException e)
    {
    }
    sslEngine.closeOutbound();
    pipeline.fireWrite(new SSLProtocol().setCloseNotify(true));
    pipeline.shutdownInput();
}

// 改为
public synchronized void gracefulClose(Pipeline pipeline)
{
    if (closeInbound)
    {
        return;
    }
    closeInbound = true;
    try
    {
        sslEngine.closeInbound();
    }
    catch (SSLException e)
    {
    }
    sslEngine.closeOutbound();
    while (true)
    {
        IoBuffer dst = pipeline.allocator().allocate(sslEngine.getSession().getPacketBufferSize());
        try
        {
            SSLEngineResult result = sslEngine.wrap(ByteBuffer.allocate(0), dst.writableByteBuffer());
            int bytesProduced = result.bytesProduced();
            dst.addWritePosi(bytesProduced);
            if (bytesProduced > 0)
            {
                pipeline.directWrite(dst);
            }
            else
            {
                dst.free();
            }
            dst = null;
            SSLEngineResult.Status status = result.getStatus();
            if (status == SSLEngineResult.Status.OK)
            {
                if (result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP)
                {
                    continue;
                }
                break;
            }
            else if (status == SSLEngineResult.Status.CLOSED)
            {
                break;
            }
        }
        catch (SSLException e)
        {
            if (dst != null)
            {
                dst.free();
            }
            break;
        }
    }
    pipeline.shutdownInput();
}
```

## 步骤 3：修改 SSLDecoder - 删除 SSLProtocol 内部类

**文件**: `src/main/java/cc/jfire/jnet/extend/http/coder/SSLDecoder.java`

**改动位置**: 文件末尾的 `SSLProtocol` 内部类（约第 304-314 行）

**改动内容**: 删除整个 `SSLProtocol` 内部类及相关 import

```java
// 删除以下代码
@Data
@Accessors(chain = true)
public static class SSLProtocol implements DataIgnore
{
    private boolean  closeNotify = false;
    private IoBuffer data;
}
```

同时删除不再需要的 import：
```java
import cc.jfire.jnet.common.util.DataIgnore;
import lombok.experimental.Accessors;
```

## 步骤 4：简化 SSLEncoder

**文件**: `src/main/java/cc/jfire/jnet/extend/http/coder/SSLEncoder.java`

**改动内容**: 移除对 `SSLProtocol` 的处理逻辑和对 `SSLDecoder` 的依赖，只保留 `IoBuffer` 加密功能

```java
package cc.jfire.jnet.extend.http.coder;

import cc.jfire.jnet.common.api.WriteProcessor;
import cc.jfire.jnet.common.api.WriteProcessorNode;
import cc.jfire.jnet.common.buffer.allocator.BufferAllocator;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import lombok.Data;

import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLException;
import java.nio.ByteBuffer;

@Data
public class SSLEncoder implements WriteProcessor<IoBuffer>
{
    private final SSLEngine sslEngine;
    private       String    remote;

    @Override
    public void write(IoBuffer buffer, WriteProcessorNode next)
    {
        if (remote == null)
        {
            remote = next.pipeline().getRemoteAddressWithoutException();
        }
        BufferAllocator allocator = next.pipeline().allocator();
        ByteBuffer      src       = buffer.readableByteBuffer();
        while (true)
        {
            IoBuffer dst = null;
            try
            {
                dst = allocator.allocate(sslEngine.getSession().getPacketBufferSize());
                SSLEngineResult        result        = sslEngine.wrap(src, dst.writableByteBuffer());
                SSLEngineResult.Status status        = result.getStatus();
                int                    bytesProduced = result.bytesProduced();
                dst.addWritePosi(bytesProduced);
                if (bytesProduced > 0)
                {
                    next.fireWrite(dst);
                }
                else
                {
                    dst.free();
                }
                dst = null;
                if (status == SSLEngineResult.Status.OK)
                {
                    if (src.hasRemaining())
                    {
                        continue;
                    }
                    else
                    {
                        buffer.free();
                        return;
                    }
                }
                else if (status == SSLEngineResult.Status.CLOSED)
                {
                    buffer.free();
                    return;
                }
            }
            catch (SSLException e)
            {
                if (dst != null)
                {
                    dst.free();
                }
                buffer.free();
                return;
            }
        }
    }
}
```

## 步骤 5：修改 ClientSSLDecoder - 握手阶段使用 directWrite

**文件**: `src/main/java/cc/jfire/jnet/extend/http/coder/ClientSSLDecoder.java`

**改动位置**: `handshake` 方法中 `NEED_WRAP` 分支（约第 115-148 行）

**改动内容**: 将 `next.pipeline().fireWrite(new ClientSSLProtocol().setData(dst))` 改为 `next.pipeline().directWrite(dst)`

```java
// 原代码
if (bytesProduced > 0)
{
    next.pipeline().fireWrite(new ClientSSLProtocol().setData(dst));
}

// 改为
if (bytesProduced > 0)
{
    next.pipeline().directWrite(dst);
}
```

## 步骤 6：修改 ClientSSLDecoder - gracefulClose 使用 directWrite

**文件**: `src/main/java/cc/jfire/jnet/extend/http/coder/ClientSSLDecoder.java`

**改动位置**: `gracefulClose` 方法（约第 47-65 行）

**改动内容**: 将 `pipeline.fireWrite(new ClientSSLProtocol().setCloseNotify(true))` 改为直接生成关闭消息并调用 `directWrite`

```java
// 原代码
public synchronized void gracefulClose(Pipeline pipeline)
{
    if (closeInbound)
    {
        return;
    }
    closeInbound = true;
    try
    {
        sslEngine.closeInbound();
    }
    catch (SSLException e)
    {
    }
    sslEngine.closeOutbound();
    pipeline.fireWrite(new ClientSSLProtocol().setCloseNotify(true));
    pipeline.shutdownInput();
}

// 改为
public synchronized void gracefulClose(Pipeline pipeline)
{
    if (closeInbound)
    {
        return;
    }
    closeInbound = true;
    try
    {
        sslEngine.closeInbound();
    }
    catch (SSLException e)
    {
    }
    sslEngine.closeOutbound();
    while (true)
    {
        IoBuffer dst = pipeline.allocator().allocate(sslEngine.getSession().getPacketBufferSize());
        try
        {
            SSLEngineResult result = sslEngine.wrap(ByteBuffer.allocate(0), dst.writableByteBuffer());
            int bytesProduced = result.bytesProduced();
            dst.addWritePosi(bytesProduced);
            if (bytesProduced > 0)
            {
                pipeline.directWrite(dst);
            }
            else
            {
                dst.free();
            }
            dst = null;
            SSLEngineResult.Status status = result.getStatus();
            if (status == SSLEngineResult.Status.OK)
            {
                if (result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP)
                {
                    continue;
                }
                break;
            }
            else if (status == SSLEngineResult.Status.CLOSED)
            {
                break;
            }
        }
        catch (SSLException e)
        {
            if (dst != null)
            {
                dst.free();
            }
            break;
        }
    }
    pipeline.shutdownInput();
}
```

## 步骤 7：ClientSSLDecoder 新增 startHandshake 方法

**文件**: `src/main/java/cc/jfire/jnet/extend/http/coder/ClientSSLDecoder.java`

**改动位置**: 在类中新增方法

**改动内容**: 新增 `startHandshake(Pipeline pipeline)` 方法，用于客户端主动发起握手

```java
public void startHandshake(Pipeline pipeline)
{
    while (true)
    {
        IoBuffer dst = pipeline.allocator().allocate(sslEngine.getSession().getPacketBufferSize());
        try
        {
            SSLEngineResult result = sslEngine.wrap(ByteBuffer.allocate(0), dst.writableByteBuffer());
            int bytesProduced = result.bytesProduced();
            dst.addWritePosi(bytesProduced);
            if (bytesProduced > 0)
            {
                pipeline.directWrite(dst);
            }
            else
            {
                dst.free();
            }
            dst = null;
            SSLEngineResult.HandshakeStatus hs = result.getHandshakeStatus();
            if (hs == SSLEngineResult.HandshakeStatus.NEED_WRAP)
            {
                continue;
            }
            return;
        }
        catch (SSLException e)
        {
            if (dst != null)
            {
                dst.free();
            }
            gracefulClose(pipeline);
            return;
        }
    }
}
```

## 步骤 8：简化 ClientSSLEncoder

**文件**: `src/main/java/cc/jfire/jnet/extend/http/coder/ClientSSLEncoder.java`

**改动内容**: 移除对 `ClientSSLProtocol` 的处理逻辑和对 `ClientSSLDecoder` 的依赖，只保留 `IoBuffer` 加密功能

```java
package cc.jfire.jnet.extend.http.coder;

import cc.jfire.jnet.common.api.WriteProcessor;
import cc.jfire.jnet.common.api.WriteProcessorNode;
import cc.jfire.jnet.common.buffer.allocator.BufferAllocator;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import lombok.Data;

import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLException;
import java.nio.ByteBuffer;

@Data
public class ClientSSLEncoder implements WriteProcessor<IoBuffer>
{
    private final SSLEngine sslEngine;
    private       String    remote;

    @Override
    public void write(IoBuffer buffer, WriteProcessorNode next)
    {
        if (remote == null)
        {
            remote = next.pipeline().getRemoteAddressWithoutException();
        }
        BufferAllocator allocator = next.pipeline().allocator();
        ByteBuffer      src       = buffer.readableByteBuffer();
        while (true)
        {
            IoBuffer dst = null;
            try
            {
                dst = allocator.allocate(sslEngine.getSession().getPacketBufferSize());
                SSLEngineResult        result        = sslEngine.wrap(src, dst.writableByteBuffer());
                SSLEngineResult.Status status        = result.getStatus();
                int                    bytesProduced = result.bytesProduced();
                dst.addWritePosi(bytesProduced);
                if (bytesProduced > 0)
                {
                    next.fireWrite(dst);
                }
                else
                {
                    dst.free();
                }
                dst = null;
                if (status == SSLEngineResult.Status.OK)
                {
                    if (src.hasRemaining())
                    {
                        continue;
                    }
                    else
                    {
                        buffer.free();
                        return;
                    }
                }
                else if (status == SSLEngineResult.Status.CLOSED)
                {
                    buffer.free();
                    return;
                }
            }
            catch (SSLException e)
            {
                if (dst != null)
                {
                    dst.free();
                }
                buffer.free();
                return;
            }
        }
    }
}
```

## 步骤 9：删除 ClientSSLProtocol 类

**文件**: `src/main/java/cc/jfire/jnet/extend/http/coder/ClientSSLProtocol.java`

**改动内容**: 删除整个文件

## 步骤 10：修改 HttpConnection - 适配新的握手调用方式

**文件**: `src/main/java/cc/jfire/jnet/extend/http/client/HttpConnection.java`

**改动位置**: 三处使用 `ClientSSLProtocol.setStartHandshake(true)` 的地方（约第 221、371、531 行）

**改动内容**: 将 `clientChannel.pipeline().fireWrite(new ClientSSLProtocol().setStartHandshake(true))` 改为 `sslDecoderHolder[0].startHandshake(clientChannel.pipeline())`

```java
// 原代码
clientChannel.pipeline().fireWrite(new ClientSSLProtocol().setStartHandshake(true));

// 改为
sslDecoderHolder[0].startHandshake(clientChannel.pipeline());
```

同时删除 `ClientSSLProtocol` 的 import 语句。
