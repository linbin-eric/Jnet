# 目标

1. 提供一个解码器，可以支持 websocket
2. 提供一个编码器，支持 websocket

# 核心思路

1. 参考现有的 `HttpRequestPartDecoder` 实现模式，创建 `WebSocketFrameDecoder` 解码器
2. 解码器继承 `AbstractDecoder`，使用状态机模式解析 WebSocket 帧
3. 定义 WebSocket 帧的 DTO 类 `WebSocketFrame`，用于承载解码后的数据
4. WebSocket 帧格式遵循 RFC 6455 规范：
   - 第1字节：FIN(1bit) + RSV(3bit) + Opcode(4bit)
   - 第2字节：MASK(1bit) + Payload Length(7bit)
   - 扩展长度：若 Payload Length=126，后续2字节为实际长度；若=127，后续8字节为实际长度
   - Masking Key：若 MASK=1，后续4字节为掩码密钥
   - Payload Data：实际数据（若有掩码需解码）
5. 参考现在的HttpRespEncoder,创建`WebSocketFrameEncoder` 编码器，编码器应该只处理WebSocketFrame
6. 修改 `HttpRequestPartDecoder`，支持检测 WebSocket 升级请求，自动发送 101 响应，并切换到透传模式
7. 提供 `WebSocketHandshakeUtil` 工具类，用于计算 `Sec-WebSocket-Accept` 等握手相关逻辑

# 详细实现思路

## 0. WebSocket 握手流程设计

### 0.1 握手流程概述
WebSocket 连接需要先通过 HTTP 协议进行握手升级：
1. 客户端发送 HTTP 升级请求（包含 `Upgrade: websocket` 和 `Sec-WebSocket-Key`）
2. 服务端验证请求，返回 101 Switching Protocols 响应
3. 握手成功后，后续数据按 WebSocket 帧协议传输

### 0.2 HttpRequestPartDecoder 改动方案
在 `HttpRequestPartDecoder` 中新增状态 `WEBSOCKET_PASSTHROUGH`：
- 解析完请求头后，检测是否为 WebSocket 升级请求
- 如果是，自动构造并发送 101 响应
- 切换到透传模式，后续数据直接透传给下一个处理器（WebSocketFrameDecoder）
- 透传的数据类型为 `IoBuffer`

### 0.3 WebSocketHandshakeUtil 工具类
提供以下静态方法：
- `isWebSocketUpgrade(HttpRequestPartHead)`: 判断是否为 WebSocket 升级请求
- `computeAcceptKey(String secWebSocketKey)`: 根据 RFC 6455 计算 `Sec-WebSocket-Accept` 值
- `buildUpgradeResponse(HttpRequestPartHead, BufferAllocator)`: 构建 101 响应

## 1. WebSocketFrame DTO 设计

`WebSocketFrame` 作为 WebSocket 帧的数据传输对象，需要包含以下信息：
- **fin**: 布尔值，表示是否为消息的最后一帧（FIN=1）
- **opcode**: 操作码（0=继续帧, 1=文本帧, 2=二进制帧, 8=关闭帧, 9=Ping帧, 10=Pong帧）
- **masked**: 布尔值，表示 payload 是否被掩码
- **payload**: IoBuffer，承载实际数据（已解码后的数据）
- **closeCode**: 关闭状态码（仅 Close 帧使用）
- **closeReason**: 关闭原因（仅 Close 帧使用）
- **last**: 布尔值，表示是否为消息流的最后一部分（组装后的完整消息）

## 2. WebSocketFrameDecoder 解码器设计

### 2.1 继承关系
- 继承 `AbstractDecoder`，复用累积缓冲区机制
- 实现状态机模式解析 WebSocket 帧

### 2.2 状态机设计
```
FRAME_HEADER    -> 解析第1-2字节（FIN/Opcode/MASK/PayloadLen）
EXTENDED_LENGTH -> 解析扩展长度（2字节或8字节）
MASKING_KEY     -> 解析4字节掩码（如果MASK=1）
PAYLOAD         -> 读取并解码payload数据
```

### 2.3 模式配置
通过构造参数 `boolean serverMode` 决定：
- **serverMode=true（服务端模式）**：要求接收的帧 MASK=1，否则抛出协议错误
- **serverMode=false（客户端模式）**：要求接收的帧 MASK=0，否则抛出协议错误

### 2.4 分片消息组装
- 当收到 FIN=0 的帧时，缓存到分片列表
- 收到 opcode=0（继续帧）时，继续追加到分片列表
- 收到 FIN=1 的继续帧时，组装所有分片为完整消息后输出
- 控制帧（opcode >= 8）不能被分片，必须 FIN=1

### 2.5 控制帧自动响应
解码器内部自动处理控制帧：
- **Ping帧**：通过 `next.pipeline().fireWrite()` 自动发送 Pong 响应
- **Close帧**：解析关闭状态码和原因，自动发送 Close 响应，然后关闭连接
- 控制帧处理完成后，仍然向上层传递该帧（让上层知晓事件）

### 2.6 掩码解码算法
```java
for (int i = 0; i < payloadLength; i++) {
    decoded[i] = (byte) (encoded[i] ^ maskingKey[i % 4]);
}
```

## 3. WebSocketFrameEncoder 编码器设计

### 3.1 实现接口
- 实现 `WriteProcessor<Object>` 接口
- 仅处理 `WebSocketFrame` 类型

### 3.2 模式配置
通过构造参数 `boolean clientMode` 决定：
- **clientMode=true（客户端模式）**：发送的帧需要添加掩码（MASK=1）
- **clientMode=false（服务端模式）**：发送的帧不添加掩码（MASK=0）

### 3.3 编码流程
1. 写入第1字节：FIN(1bit) + RSV(3bit=0) + Opcode(4bit)
2. 写入第2字节及扩展长度：
   - payload <= 125: 直接写入长度
   - payload <= 65535: 写入126 + 2字节扩展长度
   - payload > 65535: 写入127 + 8字节扩展长度
3. 如果是客户端模式，生成4字节随机掩码并写入
4. 写入 payload（客户端模式需要先进行掩码编码）

# 实施步骤

## 步骤1：创建 WebSocketHandshakeUtil 工具类

**文件位置**: `src/main/java/cc/jfire/jnet/extend/websocket/util/WebSocketHandshakeUtil.java`

```java
package cc.jfire.jnet.extend.websocket.util;

import cc.jfire.jnet.common.buffer.allocator.BufferAllocator;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.jnet.extend.http.dto.HttpRequestPartHead;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import java.util.Map;

public class WebSocketHandshakeUtil {

    /**
     * WebSocket GUID，RFC 6455 规定的固定值
     */
    private static final String WEBSOCKET_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";

    /**
     * 判断是否为 WebSocket 升级请求
     */
    public static boolean isWebSocketUpgrade(HttpRequestPartHead head) {
        if (head == null || head.getHeaders() == null) {
            return false;
        }
        Map<String, String> headers = head.getHeaders();

        // 检查必要的头部
        String upgrade = getHeaderIgnoreCase(headers, "Upgrade");
        String connection = getHeaderIgnoreCase(headers, "Connection");
        String secWebSocketKey = getHeaderIgnoreCase(headers, "Sec-WebSocket-Key");
        String secWebSocketVersion = getHeaderIgnoreCase(headers, "Sec-WebSocket-Version");

        return "websocket".equalsIgnoreCase(upgrade)
                && connection != null && connection.toLowerCase().contains("upgrade")
                && secWebSocketKey != null && !secWebSocketKey.isEmpty()
                && "13".equals(secWebSocketVersion);
    }

    /**
     * 获取 Sec-WebSocket-Key
     */
    public static String getSecWebSocketKey(HttpRequestPartHead head) {
        return getHeaderIgnoreCase(head.getHeaders(), "Sec-WebSocket-Key");
    }

    /**
     * 根据 RFC 6455 计算 Sec-WebSocket-Accept 值
     * Accept = Base64(SHA-1(Sec-WebSocket-Key + GUID))
     */
    public static String computeAcceptKey(String secWebSocketKey) {
        try {
            String combined = secWebSocketKey + WEBSOCKET_GUID;
            MessageDigest sha1 = MessageDigest.getInstance("SHA-1");
            byte[] hash = sha1.digest(combined.getBytes(StandardCharsets.US_ASCII));
            return Base64.getEncoder().encodeToString(hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("SHA-1 algorithm not available", e);
        }
    }

    /**
     * 构建 101 Switching Protocols 响应
     */
    public static IoBuffer buildUpgradeResponse(HttpRequestPartHead head, BufferAllocator allocator) {
        String secWebSocketKey = getSecWebSocketKey(head);
        String acceptKey = computeAcceptKey(secWebSocketKey);

        StringBuilder sb = new StringBuilder();
        sb.append("HTTP/1.1 101 Switching Protocols\r\n");
        sb.append("Upgrade: websocket\r\n");
        sb.append("Connection: Upgrade\r\n");
        sb.append("Sec-WebSocket-Accept: ").append(acceptKey).append("\r\n");
        sb.append("\r\n");

        byte[] responseBytes = sb.toString().getBytes(StandardCharsets.US_ASCII);
        IoBuffer buffer = allocator.allocate(responseBytes.length);
        buffer.put(responseBytes);
        return buffer;
    }

    /**
     * 忽略大小写获取 header 值
     */
    private static String getHeaderIgnoreCase(Map<String, String> headers, String name) {
        for (Map.Entry<String, String> entry : headers.entrySet()) {
            if (entry.getKey().equalsIgnoreCase(name)) {
                return entry.getValue();
            }
        }
        return null;
    }
}
```

## 步骤2：修改 HttpRequestPartDecoder 支持 WebSocket 升级

**文件位置**: `src/main/java/cc/jfire/jnet/extend/http/coder/HttpRequestPartDecoder.java`

**改动内容**:

1. 在 `ParseState` 枚举中新增 `WEBSOCKET_PASSTHROUGH` 状态
2. 在 `parseRequestHeader` 方法中，解析完头部后检测 WebSocket 升级请求
3. 如果是 WebSocket 升级，发送 101 响应并切换到透传模式
4. 新增 `passthroughWebSocket` 方法，直接透传 IoBuffer

```java
// === 需要新增的 import ===
import cc.jfire.jnet.extend.websocket.util.WebSocketHandshakeUtil;

// === 修改 ParseState 枚举 ===
enum ParseState
{
    REQUEST_LINE, REQUEST_HEADER, NO_BODY, BODY_FIX_LENGTH, BODY_CHUNKED, WEBSOCKET_PASSTHROUGH
}

// === 修改 process0 方法，在 switch 中添加 WEBSOCKET_PASSTHROUGH 分支 ===
@Override
protected void process0(ReadProcessorNode next)
{
    boolean goToNextState;
    do
    {
        goToNextState = switch (state)
        {
            case REQUEST_LINE -> parseRequestLine();
            case REQUEST_HEADER -> parseRequestHeader(next);
            case BODY_FIX_LENGTH -> parseBodyFixLength(next);
            case BODY_CHUNKED -> parseBodyChunked(next);
            case NO_BODY -> throw new IllegalStateException();
            case WEBSOCKET_PASSTHROUGH -> passthroughWebSocket(next);
        };
    } while (goToNextState);
}

// === 修改 parseRequestHeader 方法，在 parseBodyType() 后添加 WebSocket 检测 ===
private boolean parseRequestHeader(ReadProcessorNode next)
{
    for (; lastCheck + 3 < accumulation.getWritePosi(); lastCheck++)
    {
        if (accumulation.get(lastCheck) == '\r' && accumulation.get(lastCheck + 1) == '\n' && accumulation.get(lastCheck + 2) == '\r' && accumulation.get(lastCheck + 3) == '\n')
        {
            int headEndPosi = lastCheck + 4;
            int headLength  = headEndPosi - headStartPosi;
            lastCheck = -1;
            HttpDecodeUtil.findAllHeaders(accumulation, reqHead::addHeader);
            HttpDecodeUtil.findContentLength(reqHead.getHeaders(), reqHead::setContentLength);
            accumulation.setReadPosi(headStartPosi);
            if (accumulation.remainRead() == headLength)
            {
                reqHead.setHeadBuffer(accumulation);
                accumulation = null;
            }
            else
            {
                reqHead.setHeadBuffer(accumulation.slice(headLength));
            }

            // === 新增：检测 WebSocket 升级请求 ===
            if (WebSocketHandshakeUtil.isWebSocketUpgrade(reqHead))
            {
                // 发送 101 响应
                IoBuffer upgradeResponse = WebSocketHandshakeUtil.buildUpgradeResponse(reqHead, next.pipeline().allocator());
                next.pipeline().fireWrite(upgradeResponse);

                // 设置标记并向上层传递升级请求头
                reqHead.setLast(true);
                next.fireRead(reqHead);

                // 切换到 WebSocket 透传模式
                state = ParseState.WEBSOCKET_PASSTHROUGH;
                reqHead = null;
                headStartPosi = -1;

                if (accumulation == null)
                {
                    return false;
                }
                else
                {
                    accumulation.compact();
                    return true;
                }
            }

            parseBodyType();
            // 如果没有 body，设置 last = true
            if (state == ParseState.NO_BODY)
            {
                reqHead.setLast(true);
            }
            next.fireRead(reqHead);
            // 如果没有 body，直接重置状态，不再发送 End
            if (state == ParseState.NO_BODY)
            {
                resetState();
            }
            if (accumulation == null)
            {
                return false;
            }
            else
            {
                accumulation.compact();
                return true;
            }
        }
    }
    return false;
}

// === 新增方法：WebSocket 透传模式 ===
private boolean passthroughWebSocket(ReadProcessorNode next)
{
    if (accumulation == null || accumulation.remainRead() == 0)
    {
        return false;
    }
    // 直接将数据透传给下一个处理器
    next.fireRead(accumulation);
    accumulation = null;
    return false;
}
```

## 步骤3：创建 WebSocketFrame DTO 类

**文件位置**: `src/main/java/cc/jfire/jnet/extend/websocket/dto/WebSocketFrame.java`

```java
package cc.jfire.jnet.extend.websocket.dto;

import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import lombok.Data;

@Data
public class WebSocketFrame {
    // 操作码常量
    public static final int OPCODE_CONTINUATION = 0;
    public static final int OPCODE_TEXT = 1;
    public static final int OPCODE_BINARY = 2;
    public static final int OPCODE_CLOSE = 8;
    public static final int OPCODE_PING = 9;
    public static final int OPCODE_PONG = 10;

    /**
     * 是否为消息的最后一帧
     */
    private boolean fin = true;

    /**
     * 操作码
     */
    private int opcode;

    /**
     * payload是否被掩码
     */
    private boolean masked;

    /**
     * 实际数据（已解码）
     */
    private IoBuffer payload;

    /**
     * 关闭状态码（仅Close帧使用）
     */
    private int closeCode;

    /**
     * 关闭原因（仅Close帧使用）
     */
    private String closeReason;

    /**
     * 是否为消息流的最后一部分
     */
    private boolean last = true;

    /**
     * 判断是否为控制帧
     */
    public boolean isControlFrame() {
        return opcode >= 8;
    }

    /**
     * 释放payload资源
     */
    public void free() {
        if (payload != null) {
            payload.free();
            payload = null;
        }
    }

    /**
     * 创建Pong响应帧
     */
    public static WebSocketFrame createPong(IoBuffer payload) {
        WebSocketFrame frame = new WebSocketFrame();
        frame.setFin(true);
        frame.setOpcode(OPCODE_PONG);
        frame.setPayload(payload);
        return frame;
    }

    /**
     * 创建Close响应帧
     */
    public static WebSocketFrame createClose(int code, String reason) {
        WebSocketFrame frame = new WebSocketFrame();
        frame.setFin(true);
        frame.setOpcode(OPCODE_CLOSE);
        frame.setCloseCode(code);
        frame.setCloseReason(reason);
        return frame;
    }
}
```

## 步骤4：创建 WebSocketFrameDecoder 解码器

**文件位置**: `src/main/java/cc/jfire/jnet/extend/websocket/coder/WebSocketFrameDecoder.java`

```java
package cc.jfire.jnet.extend.websocket.coder;

import cc.jfire.jnet.common.api.ReadProcessorNode;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.jnet.common.coder.AbstractDecoder;
import cc.jfire.jnet.extend.websocket.dto.WebSocketFrame;
import lombok.extern.slf4j.Slf4j;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

@Slf4j
public class WebSocketFrameDecoder extends AbstractDecoder {

    /**
     * true=服务端模式（要求MASK=1），false=客户端模式（要求MASK=0）
     */
    private final boolean serverMode;

    private DecodeState state = DecodeState.FRAME_HEADER;

    // 当前帧解析状态
    private boolean fin;
    private int opcode;
    private boolean masked;
    private long payloadLength;
    private byte[] maskingKey = new byte[4];
    private int extendedLengthBytes; // 0, 2, 或 8

    // 分片消息缓存
    private List<IoBuffer> fragmentBuffers = new ArrayList<>();
    private int fragmentOpcode = -1;

    public WebSocketFrameDecoder(boolean serverMode) {
        this.serverMode = serverMode;
    }

    @Override
    protected void process0(ReadProcessorNode next) {
        boolean continueProcessing;
        do {
            continueProcessing = switch (state) {
                case FRAME_HEADER -> parseFrameHeader();
                case EXTENDED_LENGTH -> parseExtendedLength();
                case MASKING_KEY -> parseMaskingKey();
                case PAYLOAD -> parsePayload(next);
            };
        } while (continueProcessing);
    }

    private boolean parseFrameHeader() {
        if (accumulation == null || accumulation.remainRead() < 2) {
            return false;
        }

        byte b1 = accumulation.get();
        byte b2 = accumulation.get();

        fin = (b1 & 0x80) != 0;
        opcode = b1 & 0x0F;
        masked = (b2 & 0x80) != 0;
        payloadLength = b2 & 0x7F;

        // 校验MASK
        if (serverMode && !masked) {
            throw new IllegalStateException("服务端模式要求客户端发送的帧必须有掩码");
        }
        if (!serverMode && masked) {
            throw new IllegalStateException("客户端模式要求服务端发送的帧不能有掩码");
        }

        // 控制帧校验
        if (opcode >= 8) {
            if (!fin) {
                throw new IllegalStateException("控制帧不能被分片");
            }
            if (payloadLength > 125) {
                throw new IllegalStateException("控制帧payload不能超过125字节");
            }
        }

        // 确定扩展长度
        if (payloadLength == 126) {
            extendedLengthBytes = 2;
            state = DecodeState.EXTENDED_LENGTH;
        } else if (payloadLength == 127) {
            extendedLengthBytes = 8;
            state = DecodeState.EXTENDED_LENGTH;
        } else {
            extendedLengthBytes = 0;
            state = masked ? DecodeState.MASKING_KEY : DecodeState.PAYLOAD;
        }

        return true;
    }

    private boolean parseExtendedLength() {
        if (accumulation.remainRead() < extendedLengthBytes) {
            return false;
        }

        if (extendedLengthBytes == 2) {
            payloadLength = accumulation.getShort() & 0xFFFF;
        } else {
            payloadLength = accumulation.getLong();
        }

        state = masked ? DecodeState.MASKING_KEY : DecodeState.PAYLOAD;
        return true;
    }

    private boolean parseMaskingKey() {
        if (accumulation.remainRead() < 4) {
            return false;
        }

        accumulation.get(maskingKey);
        state = DecodeState.PAYLOAD;
        return true;
    }

    private boolean parsePayload(ReadProcessorNode next) {
        if (accumulation.remainRead() < payloadLength) {
            return false;
        }

        // 读取payload
        IoBuffer payload = null;
        if (payloadLength > 0) {
            payload = accumulation.slice((int) payloadLength);

            // 如果有掩码，进行解码
            if (masked) {
                unmask(payload);
            }
        }

        // 处理帧
        handleFrame(next, payload);

        // 重置状态准备解析下一帧
        resetParseState();

        return accumulation != null && accumulation.remainRead() > 0;
    }

    private void unmask(IoBuffer payload) {
        int readPosi = payload.getReadPosi();
        int length = payload.remainRead();
        for (int i = 0; i < length; i++) {
            byte original = payload.get(readPosi + i);
            byte decoded = (byte) (original ^ maskingKey[i % 4]);
            payload.put(decoded, readPosi + i);
        }
    }

    private void handleFrame(ReadProcessorNode next, IoBuffer payload) {
        // 处理控制帧
        if (opcode >= 8) {
            handleControlFrame(next, payload);
            return;
        }

        // 处理数据帧（分片组装）
        if (opcode != WebSocketFrame.OPCODE_CONTINUATION) {
            // 新消息的第一帧
            fragmentOpcode = opcode;
            fragmentBuffers.clear();
        }

        if (payload != null) {
            fragmentBuffers.add(payload);
        }

        if (fin) {
            // 消息完整，组装并输出
            WebSocketFrame frame = new WebSocketFrame();
            frame.setFin(true);
            frame.setOpcode(fragmentOpcode);
            frame.setLast(true);

            if (fragmentBuffers.size() == 1) {
                frame.setPayload(fragmentBuffers.get(0));
            } else if (fragmentBuffers.size() > 1) {
                // 合并所有分片
                frame.setPayload(mergeBuffers(next));
            }

            fragmentBuffers.clear();
            fragmentOpcode = -1;

            next.fireRead(frame);
        }
    }

    private IoBuffer mergeBuffers(ReadProcessorNode next) {
        int totalLength = 0;
        for (IoBuffer buf : fragmentBuffers) {
            totalLength += buf.remainRead();
        }

        IoBuffer merged = next.pipeline().allocator().allocate(totalLength);
        for (IoBuffer buf : fragmentBuffers) {
            merged.put(buf);
            buf.free();
        }
        return merged;
    }

    private void handleControlFrame(ReadProcessorNode next, IoBuffer payload) {
        WebSocketFrame frame = new WebSocketFrame();
        frame.setFin(true);
        frame.setOpcode(opcode);
        frame.setPayload(payload);

        switch (opcode) {
            case WebSocketFrame.OPCODE_PING -> {
                // 自动发送Pong响应
                WebSocketFrame pong = WebSocketFrame.createPong(payload);
                next.pipeline().fireWrite(pong);
                // 传递Ping帧给上层（payload已交给pong，创建新帧）
                WebSocketFrame pingNotify = new WebSocketFrame();
                pingNotify.setFin(true);
                pingNotify.setOpcode(WebSocketFrame.OPCODE_PING);
                next.fireRead(pingNotify);
            }
            case WebSocketFrame.OPCODE_PONG -> {
                // 直接传递给上层
                next.fireRead(frame);
            }
            case WebSocketFrame.OPCODE_CLOSE -> {
                // 解析关闭状态码和原因
                int closeCode = 1000;
                String closeReason = "";
                if (payload != null && payload.remainRead() >= 2) {
                    closeCode = payload.getShort() & 0xFFFF;
                    if (payload.remainRead() > 0) {
                        byte[] reasonBytes = new byte[payload.remainRead()];
                        payload.get(reasonBytes);
                        closeReason = new String(reasonBytes, StandardCharsets.UTF_8);
                    }
                }

                frame.setCloseCode(closeCode);
                frame.setCloseReason(closeReason);

                // 自动发送Close响应
                WebSocketFrame closeResp = WebSocketFrame.createClose(closeCode, closeReason);
                next.pipeline().fireWrite(closeResp);

                // 传递Close帧给上层
                next.fireRead(frame);

                // 关闭输入
                next.pipeline().shutdownInput();
            }
        }
    }

    private void resetParseState() {
        state = DecodeState.FRAME_HEADER;
        fin = false;
        opcode = 0;
        masked = false;
        payloadLength = 0;
        extendedLengthBytes = 0;

        if (accumulation != null && accumulation.remainRead() > 0) {
            accumulation.compact();
        }
    }

    @Override
    public void readFailed(Throwable e, ReadProcessorNode next) {
        // 清理分片缓存
        for (IoBuffer buf : fragmentBuffers) {
            buf.free();
        }
        fragmentBuffers.clear();
        super.readFailed(e, next);
    }

    enum DecodeState {
        FRAME_HEADER,
        EXTENDED_LENGTH,
        MASKING_KEY,
        PAYLOAD
    }
}
```

## 步骤5：创建 WebSocketFrameEncoder 编码器

**文件位置**: `src/main/java/cc/jfire/jnet/extend/websocket/coder/WebSocketFrameEncoder.java`

```java
package cc.jfire.jnet.extend.websocket.coder;

import cc.jfire.jnet.common.api.WriteProcessor;
import cc.jfire.jnet.common.api.WriteProcessorNode;
import cc.jfire.jnet.common.buffer.allocator.BufferAllocator;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.jnet.extend.websocket.dto.WebSocketFrame;
import lombok.extern.slf4j.Slf4j;

import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;

@Slf4j
public class WebSocketFrameEncoder implements WriteProcessor<Object> {

    private final BufferAllocator allocator;

    /**
     * true=客户端模式（发送时添加掩码），false=服务端模式（发送时不加掩码）
     */
    private final boolean clientMode;

    private final SecureRandom random = new SecureRandom();

    public WebSocketFrameEncoder(BufferAllocator allocator, boolean clientMode) {
        this.allocator = allocator;
        this.clientMode = clientMode;
    }

    @Override
    public void write(Object obj, WriteProcessorNode next) {
        if (obj instanceof WebSocketFrame frame) {
            IoBuffer buffer = encodeFrame(frame);
            next.fireWrite(buffer);
        } else if (obj instanceof IoBuffer) {
            // 直接透传IoBuffer
            next.fireWrite(obj);
        } else {
            throw new IllegalArgumentException("WebSocketFrameEncoder不支持类型: " + obj.getClass());
        }
    }

    private IoBuffer encodeFrame(WebSocketFrame frame) {
        // 计算需要的缓冲区大小
        int payloadLength = 0;
        IoBuffer payload = frame.getPayload();

        // 处理Close帧的特殊payload
        byte[] closePayload = null;
        if (frame.getOpcode() == WebSocketFrame.OPCODE_CLOSE) {
            closePayload = buildClosePayload(frame);
            payloadLength = closePayload.length;
        } else if (payload != null) {
            payloadLength = payload.remainRead();
        }

        int headerSize = 2;
        if (payloadLength > 125 && payloadLength <= 65535) {
            headerSize += 2;
        } else if (payloadLength > 65535) {
            headerSize += 8;
        }
        if (clientMode) {
            headerSize += 4; // masking key
        }

        IoBuffer buffer = allocator.allocate(headerSize + payloadLength);

        // 第1字节: FIN + RSV + Opcode
        byte b1 = (byte) ((frame.isFin() ? 0x80 : 0) | (frame.getOpcode() & 0x0F));
        buffer.put(b1);

        // 第2字节: MASK + Payload Length
        byte b2 = (byte) (clientMode ? 0x80 : 0);
        if (payloadLength <= 125) {
            b2 |= payloadLength;
            buffer.put(b2);
        } else if (payloadLength <= 65535) {
            b2 |= 126;
            buffer.put(b2);
            buffer.putShort((short) payloadLength);
        } else {
            b2 |= 127;
            buffer.put(b2);
            buffer.putLong(payloadLength);
        }

        // Masking Key (仅客户端模式)
        byte[] maskingKey = null;
        if (clientMode) {
            maskingKey = new byte[4];
            random.nextBytes(maskingKey);
            buffer.put(maskingKey);
        }

        // Payload
        if (closePayload != null) {
            if (clientMode) {
                // 掩码编码
                for (int i = 0; i < closePayload.length; i++) {
                    buffer.put((byte) (closePayload[i] ^ maskingKey[i % 4]));
                }
            } else {
                buffer.put(closePayload);
            }
        } else if (payload != null && payloadLength > 0) {
            if (clientMode) {
                // 掩码编码
                int readPosi = payload.getReadPosi();
                for (int i = 0; i < payloadLength; i++) {
                    byte original = payload.get(readPosi + i);
                    buffer.put((byte) (original ^ maskingKey[i % 4]));
                }
            } else {
                buffer.put(payload, payloadLength);
            }
        }

        return buffer;
    }

    private byte[] buildClosePayload(WebSocketFrame frame) {
        int closeCode = frame.getCloseCode();
        String closeReason = frame.getCloseReason();

        if (closeCode == 0 && (closeReason == null || closeReason.isEmpty())) {
            return new byte[0];
        }

        byte[] reasonBytes = (closeReason != null) ? closeReason.getBytes(StandardCharsets.UTF_8) : new byte[0];
        byte[] result = new byte[2 + reasonBytes.length];
        result[0] = (byte) ((closeCode >> 8) & 0xFF);
        result[1] = (byte) (closeCode & 0xFF);
        System.arraycopy(reasonBytes, 0, result, 2, reasonBytes.length);
        return result;
    }
}
```

# 待办列表

1. [ ] 创建 WebSocket 包目录结构 `src/main/java/cc/jfire/jnet/extend/websocket/dto/`、`src/main/java/cc/jfire/jnet/extend/websocket/coder/` 和 `src/main/java/cc/jfire/jnet/extend/websocket/util/`
2. [ ] 创建 `WebSocketHandshakeUtil` 握手工具类
3. [ ] 修改 `HttpRequestPartDecoder`，新增 WebSocket 升级检测和透传模式
4. [ ] 创建 `WebSocketFrame` DTO 类
5. [ ] 创建 `WebSocketFrameDecoder` 解码器类
6. [ ] 创建 `WebSocketFrameEncoder` 编码器类
7. [ ] 编写单元测试验证握手、解码器和编码器的正确性
8. [ ] 执行 `mvn compile` 验证代码编译通过

# 需要修改或新增的类

| 类型 | 类名 | 包路径 |
|------|------|--------|
| 新增 | `WebSocketHandshakeUtil` | `cc.jfire.jnet.extend.websocket.util` |
| 修改 | `HttpRequestPartDecoder` | `cc.jfire.jnet.extend.http.coder` |
| 新增 | `WebSocketFrame` | `cc.jfire.jnet.extend.websocket.dto` |
| 新增 | `WebSocketFrameDecoder` | `cc.jfire.jnet.extend.websocket.coder` |
| 新增 | `WebSocketFrameEncoder` | `cc.jfire.jnet.extend.websocket.coder` |
